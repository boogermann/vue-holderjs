/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Holder) {/*!\n\nHolder - client side image placeholders\nVersion 2.9.4+cabil\nÂ© 2016 Ivan Malopinsky - http://imsky.co\n\nSite:     http://holderjs.com\nIssues:   https://github.com/imsky/holder/issues\nLicense:  MIT\n\n*/\n(function (window) {\n  if (!window.document) return;\n  var document = window.document;\n\n  //https://github.com/inexorabletash/polyfill/blob/master/web.js\n    if (!document.querySelectorAll) {\n      document.querySelectorAll = function (selectors) {\n        var style = document.createElement('style'), elements = [], element;\n        document.documentElement.firstChild.appendChild(style);\n        document._qsa = [];\n\n        style.styleSheet.cssText = selectors + '{x-qsa:expression(document._qsa && document._qsa.push(this))}';\n        window.scrollBy(0, 0);\n        style.parentNode.removeChild(style);\n\n        while (document._qsa.length) {\n          element = document._qsa.shift();\n          element.style.removeAttribute('x-qsa');\n          elements.push(element);\n        }\n        document._qsa = null;\n        return elements;\n      };\n    }\n\n    if (!document.querySelector) {\n      document.querySelector = function (selectors) {\n        var elements = document.querySelectorAll(selectors);\n        return (elements.length) ? elements[0] : null;\n      };\n    }\n\n    if (!document.getElementsByClassName) {\n      document.getElementsByClassName = function (classNames) {\n        classNames = String(classNames).replace(/^|\\s+/g, '.');\n        return document.querySelectorAll(classNames);\n      };\n    }\n\n  //https://github.com/inexorabletash/polyfill\n  // ES5 15.2.3.14 Object.keys ( O )\n  // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      if (o !== Object(o)) { throw TypeError('Object.keys called on non-object'); }\n      var ret = [], p;\n      for (p in o) {\n        if (Object.prototype.hasOwnProperty.call(o, p)) {\n          ret.push(p);\n        }\n      }\n      return ret;\n    };\n  }\n\n  // ES5 15.4.4.18 Array.prototype.forEach ( callbackfn [ , thisArg ] )\n  // From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach\n  if (!Array.prototype.forEach) {\n    Array.prototype.forEach = function (fun /*, thisp */) {\n      if (this === void 0 || this === null) { throw TypeError(); }\n\n      var t = Object(this);\n      var len = t.length >>> 0;\n      if (typeof fun !== \"function\") { throw TypeError(); }\n\n      var thisp = arguments[1], i;\n      for (i = 0; i < len; i++) {\n        if (i in t) {\n          fun.call(thisp, t[i], i, t);\n        }\n      }\n    };\n  }\n\n  //https://github.com/inexorabletash/polyfill/blob/master/web.js\n  (function (global) {\n    var B64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    global.atob = global.atob || function (input) {\n      input = String(input);\n      var position = 0,\n          output = [],\n          buffer = 0, bits = 0, n;\n\n      input = input.replace(/\\s/g, '');\n      if ((input.length % 4) === 0) { input = input.replace(/=+$/, ''); }\n      if ((input.length % 4) === 1) { throw Error('InvalidCharacterError'); }\n      if (/[^+/0-9A-Za-z]/.test(input)) { throw Error('InvalidCharacterError'); }\n\n      while (position < input.length) {\n        n = B64_ALPHABET.indexOf(input.charAt(position));\n        buffer = (buffer << 6) | n;\n        bits += 6;\n\n        if (bits === 24) {\n          output.push(String.fromCharCode((buffer >> 16) & 0xFF));\n          output.push(String.fromCharCode((buffer >>  8) & 0xFF));\n          output.push(String.fromCharCode(buffer & 0xFF));\n          bits = 0;\n          buffer = 0;\n        }\n        position += 1;\n      }\n\n      if (bits === 12) {\n        buffer = buffer >> 4;\n        output.push(String.fromCharCode(buffer & 0xFF));\n      } else if (bits === 18) {\n        buffer = buffer >> 2;\n        output.push(String.fromCharCode((buffer >> 8) & 0xFF));\n        output.push(String.fromCharCode(buffer & 0xFF));\n      }\n\n      return output.join('');\n    };\n\n    global.btoa = global.btoa || function (input) {\n      input = String(input);\n      var position = 0,\n          out = [],\n          o1, o2, o3,\n          e1, e2, e3, e4;\n\n      if (/[^\\x00-\\xFF]/.test(input)) { throw Error('InvalidCharacterError'); }\n\n      while (position < input.length) {\n        o1 = input.charCodeAt(position++);\n        o2 = input.charCodeAt(position++);\n        o3 = input.charCodeAt(position++);\n\n        // 111111 112222 222233 333333\n        e1 = o1 >> 2;\n        e2 = ((o1 & 0x3) << 4) | (o2 >> 4);\n        e3 = ((o2 & 0xf) << 2) | (o3 >> 6);\n        e4 = o3 & 0x3f;\n\n        if (position === input.length + 2) {\n          e3 = 64; e4 = 64;\n        }\n        else if (position === input.length + 1) {\n          e4 = 64;\n        }\n\n        out.push(B64_ALPHABET.charAt(e1),\n                 B64_ALPHABET.charAt(e2),\n                 B64_ALPHABET.charAt(e3),\n                 B64_ALPHABET.charAt(e4));\n      }\n\n      return out.join('');\n    };\n  }(window));\n\n  //https://gist.github.com/jimeh/332357\n  if (!Object.prototype.hasOwnProperty){\n      /*jshint -W001, -W103 */\n      Object.prototype.hasOwnProperty = function(prop) {\n      var proto = this.__proto__ || this.constructor.prototype;\n      return (prop in this) && (!(prop in proto) || proto[prop] !== this[prop]);\n    };\n      /*jshint +W001, +W103 */\n  }\n\n  // @license http://opensource.org/licenses/MIT\n  // copyright Paul Irish 2015\n\n\n  // Date.now() is supported everywhere except IE8. For IE8 we use the Date.now polyfill\n  //   github.com/Financial-Times/polyfill-service/blob/master/polyfills/Date.now/polyfill.js\n  // as Safari 6 doesn't have support for NavigationTiming, we use a Date.now() timestamp for relative values\n\n  // if you want values similar to what you'd get with real perf.now, place this towards the head of the page\n  // but in reality, you're just getting the delta between now() calls, so it's not terribly important where it's placed\n\n\n  (function(){\n\n    if ('performance' in window === false) {\n        window.performance = {};\n    }\n    \n    Date.now = (Date.now || function () {  // thanks IE8\n      return new Date().getTime();\n    });\n\n    if ('now' in window.performance === false){\n      \n      var nowOffset = Date.now();\n      \n      if (performance.timing && performance.timing.navigationStart){\n        nowOffset = performance.timing.navigationStart;\n      }\n\n      window.performance.now = function now(){\n        return Date.now() - nowOffset;\n      };\n    }\n\n  })();\n\n  //requestAnimationFrame polyfill for older Firefox/Chrome versions\n  if (!window.requestAnimationFrame) {\n    if (window.webkitRequestAnimationFrame && window.webkitCancelAnimationFrame) {\n    //https://github.com/Financial-Times/polyfill-service/blob/master/polyfills/requestAnimationFrame/polyfill-webkit.js\n    (function (global) {\n      global.requestAnimationFrame = function (callback) {\n        return webkitRequestAnimationFrame(function () {\n          callback(global.performance.now());\n        });\n      };\n\n      global.cancelAnimationFrame = global.webkitCancelAnimationFrame;\n    }(window));\n    } else if (window.mozRequestAnimationFrame && window.mozCancelAnimationFrame) {\n      //https://github.com/Financial-Times/polyfill-service/blob/master/polyfills/requestAnimationFrame/polyfill-moz.js\n    (function (global) {\n      global.requestAnimationFrame = function (callback) {\n        return mozRequestAnimationFrame(function () {\n          callback(global.performance.now());\n        });\n      };\n\n      global.cancelAnimationFrame = global.mozCancelAnimationFrame;\n    }(window));\n    } else {\n    (function (global) {\n      global.requestAnimationFrame = function (callback) {\n        return global.setTimeout(callback, 1000 / 60);\n      };\n\n      global.cancelAnimationFrame = global.clearTimeout;\n    })(window);\n    }\n  }\n})(this);\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Holder\"] = factory();\n\telse\n\t\troot[\"Holder\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\tHolder.js - client side image placeholders\n\t(c) 2012-2015 Ivan Malopinsky - http://imsky.co\n\t*/\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*\n\tHolder.js - client side image placeholders\n\t(c) 2012-2016 Ivan Malopinsky - http://imsky.co\n\t*/\n\n\t//Libraries and functions\n\tvar onDomReady = __webpack_require__(2);\n\tvar querystring = __webpack_require__(3);\n\n\tvar SceneGraph = __webpack_require__(6);\n\tvar utils = __webpack_require__(7);\n\tvar SVG = __webpack_require__(8);\n\tvar DOM = __webpack_require__(9);\n\tvar Color = __webpack_require__(10);\n\tvar constants = __webpack_require__(11);\n\n\tvar svgRenderer = __webpack_require__(12);\n\tvar sgCanvasRenderer = __webpack_require__(15);\n\n\tvar extend = utils.extend;\n\tvar dimensionCheck = utils.dimensionCheck;\n\n\t//Constants and definitions\n\tvar SVG_NS = constants.svg_ns;\n\n\tvar Holder = {\n\t    version: constants.version,\n\n\t    /**\n\t     * Adds a theme to default settings\n\t     *\n\t     * @param {string} name Theme name\n\t     * @param {Object} theme Theme object, with foreground, background, size, font, and fontweight properties.\n\t     */\n\t    addTheme: function(name, theme) {\n\t        name != null && theme != null && (App.settings.themes[name] = theme);\n\t        delete App.vars.cache.themeKeys;\n\t        return this;\n\t    },\n\n\t    /**\n\t     * Appends a placeholder to an element\n\t     *\n\t     * @param {string} src Placeholder URL string\n\t     * @param el A selector or a reference to a DOM node\n\t     */\n\t    addImage: function(src, el) {\n\t        //todo: use jquery fallback if available for all QSA references\n\t        var nodes = DOM.getNodeArray(el);\n\t        nodes.forEach(function (node) {\n\t            var img = DOM.newEl('img');\n\t            var domProps = {};\n\t            domProps[App.setup.dataAttr] = src;\n\t            DOM.setAttr(img, domProps);\n\t            node.appendChild(img);\n\t        });\n\t        return this;\n\t    },\n\n\t    /**\n\t     * Sets whether or not an image is updated on resize.\n\t     * If an image is set to be updated, it is immediately rendered.\n\t     *\n\t     * @param {Object} el Image DOM element\n\t     * @param {Boolean} value Resizable update flag value\n\t     */\n\t    setResizeUpdate: function(el, value) {\n\t        if (el.holderData) {\n\t            el.holderData.resizeUpdate = !!value;\n\t            if (el.holderData.resizeUpdate) {\n\t                updateResizableElements(el);\n\t            }\n\t        }\n\t    },\n\n\t    /**\n\t     * Runs Holder with options. By default runs Holder on all images with \"holder.js\" in their source attributes.\n\t     *\n\t     * @param {Object} userOptions Options object, can contain domain, themes, images, and bgnodes properties\n\t     */\n\t    run: function(userOptions) {\n\t        //todo: split processing into separate queues\n\t        userOptions = userOptions || {};\n\t        var engineSettings = {};\n\t        var options = extend(App.settings, userOptions);\n\n\t        App.vars.preempted = true;\n\t        App.vars.dataAttr = options.dataAttr || App.setup.dataAttr;\n\n\t        engineSettings.renderer = options.renderer ? options.renderer : App.setup.renderer;\n\t        if (App.setup.renderers.join(',').indexOf(engineSettings.renderer) === -1) {\n\t            engineSettings.renderer = App.setup.supportsSVG ? 'svg' : (App.setup.supportsCanvas ? 'canvas' : 'html');\n\t        }\n\n\t        var images = DOM.getNodeArray(options.images);\n\t        var bgnodes = DOM.getNodeArray(options.bgnodes);\n\t        var stylenodes = DOM.getNodeArray(options.stylenodes);\n\t        var objects = DOM.getNodeArray(options.objects);\n\n\t        engineSettings.stylesheets = [];\n\t        engineSettings.svgXMLStylesheet = true;\n\t        engineSettings.noFontFallback = !!options.noFontFallback;\n\t        engineSettings.noBackgroundSize = !!options.noBackgroundSize;\n\n\t        stylenodes.forEach(function (styleNode) {\n\t            if (styleNode.attributes.rel && styleNode.attributes.href && styleNode.attributes.rel.value == 'stylesheet') {\n\t                var href = styleNode.attributes.href.value;\n\t                //todo: write isomorphic relative-to-absolute URL function\n\t                var proxyLink = DOM.newEl('a');\n\t                proxyLink.href = href;\n\t                var stylesheetURL = proxyLink.protocol + '//' + proxyLink.host + proxyLink.pathname + proxyLink.search;\n\t                engineSettings.stylesheets.push(stylesheetURL);\n\t            }\n\t        });\n\n\t        bgnodes.forEach(function (bgNode) {\n\t            //Skip processing background nodes if getComputedStyle is unavailable, since only modern browsers would be able to use canvas or SVG to render to background\n\t            if (!global.getComputedStyle) return;\n\t            var backgroundImage = global.getComputedStyle(bgNode, null).getPropertyValue('background-image');\n\t            var dataBackgroundImage = bgNode.getAttribute('data-background-src');\n\t            var rawURL = dataBackgroundImage || backgroundImage;\n\n\t            var holderURL = null;\n\t            var holderString = options.domain + '/';\n\t            var holderStringIndex = rawURL.indexOf(holderString);\n\n\t            if (holderStringIndex === 0) {\n\t                holderURL = rawURL;\n\t            } else if (holderStringIndex === 1 && rawURL[0] === '?') {\n\t                holderURL = rawURL.slice(1);\n\t            } else {\n\t                var fragment = rawURL.substr(holderStringIndex).match(/([^\\\"]*)\"?\\)/);\n\t                if (fragment !== null) {\n\t                    holderURL = fragment[1];\n\t                } else if (rawURL.indexOf('url(') === 0) {\n\t                    throw 'Holder: unable to parse background URL: ' + rawURL;\n\t                }\n\t            }\n\n\t            if (holderURL) {\n\t                var holderFlags = parseURL(holderURL, options);\n\t                if (holderFlags) {\n\t                    prepareDOMElement({\n\t                        mode: 'background',\n\t                        el: bgNode,\n\t                        flags: holderFlags,\n\t                        engineSettings: engineSettings\n\t                    });\n\t                }\n\t            }\n\t        });\n\n\t        objects.forEach(function (object) {\n\t            var objectAttr = {};\n\n\t            try {\n\t                objectAttr.data = object.getAttribute('data');\n\t                objectAttr.dataSrc = object.getAttribute(App.vars.dataAttr);\n\t            } catch (e) {}\n\n\t            var objectHasSrcURL = objectAttr.data != null && objectAttr.data.indexOf(options.domain) === 0;\n\t            var objectHasDataSrcURL = objectAttr.dataSrc != null && objectAttr.dataSrc.indexOf(options.domain) === 0;\n\n\t            if (objectHasSrcURL) {\n\t                prepareImageElement(options, engineSettings, objectAttr.data, object);\n\t            } else if (objectHasDataSrcURL) {\n\t                prepareImageElement(options, engineSettings, objectAttr.dataSrc, object);\n\t            }\n\t        });\n\n\t        images.forEach(function (image) {\n\t            var imageAttr = {};\n\n\t            try {\n\t                imageAttr.src = image.getAttribute('src');\n\t                imageAttr.dataSrc = image.getAttribute(App.vars.dataAttr);\n\t                imageAttr.rendered = image.getAttribute('data-holder-rendered');\n\t            } catch (e) {}\n\n\t            var imageHasSrc = imageAttr.src != null;\n\t            var imageHasDataSrcURL = imageAttr.dataSrc != null && imageAttr.dataSrc.indexOf(options.domain) === 0;\n\t            var imageRendered = imageAttr.rendered != null && imageAttr.rendered == 'true';\n\n\t            if (imageHasSrc) {\n\t                if (imageAttr.src.indexOf(options.domain) === 0) {\n\t                    prepareImageElement(options, engineSettings, imageAttr.src, image);\n\t                } else if (imageHasDataSrcURL) {\n\t                    //Image has a valid data-src and an invalid src\n\t                    if (imageRendered) {\n\t                        //If the placeholder has already been render, re-render it\n\t                        prepareImageElement(options, engineSettings, imageAttr.dataSrc, image);\n\t                    } else {\n\t                        //If the placeholder has not been rendered, check if the image exists and render a fallback if it doesn't\n\t                        (function(src, options, engineSettings, dataSrc, image) {\n\t                            utils.imageExists(src, function(exists) {\n\t                                if (!exists) {\n\t                                    prepareImageElement(options, engineSettings, dataSrc, image);\n\t                                }\n\t                            });\n\t                        })(imageAttr.src, options, engineSettings, imageAttr.dataSrc, image);\n\t                    }\n\t                }\n\t            } else if (imageHasDataSrcURL) {\n\t                prepareImageElement(options, engineSettings, imageAttr.dataSrc, image);\n\t            }\n\t        });\n\n\t        return this;\n\t    }\n\t};\n\n\tvar App = {\n\t    settings: {\n\t        domain: 'holder.js',\n\t        images: 'img',\n\t        objects: 'object',\n\t        bgnodes: 'body .holderjs',\n\t        stylenodes: 'head link.holderjs',\n\t        themes: {\n\t            'gray': {\n\t                bg: '#EEEEEE',\n\t                fg: '#AAAAAA'\n\t            },\n\t            'social': {\n\t                bg: '#3a5a97',\n\t                fg: '#FFFFFF'\n\t            },\n\t            'industrial': {\n\t                bg: '#434A52',\n\t                fg: '#C2F200'\n\t            },\n\t            'sky': {\n\t                bg: '#0D8FDB',\n\t                fg: '#FFFFFF'\n\t            },\n\t            'vine': {\n\t                bg: '#39DBAC',\n\t                fg: '#1E292C'\n\t            },\n\t            'lava': {\n\t                bg: '#F8591A',\n\t                fg: '#1C2846'\n\t            }\n\t        }\n\t    },\n\t    defaults: {\n\t        size: 10,\n\t        units: 'pt',\n\t        scale: 1 / 16\n\t    }\n\t};\n\n\t/**\n\t * Processes provided source attribute and sets up the appropriate rendering workflow\n\t *\n\t * @private\n\t * @param options Instance options from Holder.run\n\t * @param renderSettings Instance configuration\n\t * @param src Image URL\n\t * @param el Image DOM element\n\t */\n\tfunction prepareImageElement(options, engineSettings, src, el) {\n\t    var holderFlags = parseURL(src.substr(src.lastIndexOf(options.domain)), options);\n\t    if (holderFlags) {\n\t        prepareDOMElement({\n\t            mode: null,\n\t            el: el,\n\t            flags: holderFlags,\n\t            engineSettings: engineSettings\n\t        });\n\t    }\n\t}\n\n\t/**\n\t * Processes a Holder URL and extracts configuration from query string\n\t *\n\t * @private\n\t * @param url URL\n\t * @param instanceOptions Instance options from Holder.run\n\t */\n\tfunction parseURL(url, instanceOptions) {\n\t    var holder = {\n\t        theme: extend(App.settings.themes.gray, null),\n\t        stylesheets: instanceOptions.stylesheets,\n\t        instanceOptions: instanceOptions\n\t    };\n\n\t    var firstQuestionMark = url.indexOf('?');\n\t    var parts = [url];\n\n\t    if (firstQuestionMark !== -1) {\n\t        parts = [url.slice(0, firstQuestionMark), url.slice(firstQuestionMark + 1)];\n\t    }\n\n\t    var basics = parts[0].split('/');\n\n\t    holder.holderURL = url;\n\n\t    var dimensions = basics[1];\n\t    var dimensionData = dimensions.match(/([\\d]+p?)x([\\d]+p?)/);\n\n\t    if (!dimensionData) return false;\n\n\t    holder.fluid = dimensions.indexOf('p') !== -1;\n\n\t    holder.dimensions = {\n\t        width: dimensionData[1].replace('p', '%'),\n\t        height: dimensionData[2].replace('p', '%')\n\t    };\n\n\t    if (parts.length === 2) {\n\t        var options = querystring.parse(parts[1]);\n\n\t        // Dimensions\n\n\t        if (utils.truthy(options.ratio)) {\n\t            holder.fluid = true;\n\t            var ratioWidth = parseFloat(holder.dimensions.width.replace('%', ''));\n\t            var ratioHeight = parseFloat(holder.dimensions.height.replace('%', ''));\n\n\t            ratioHeight = Math.floor(100 * (ratioHeight / ratioWidth));\n\t            ratioWidth = 100;\n\n\t            holder.dimensions.width = ratioWidth + '%';\n\t            holder.dimensions.height = ratioHeight + '%';\n\t        }\n\n\t        holder.auto = utils.truthy(options.auto);\n\n\t        // Colors\n\n\t        if (options.bg) {\n\t            holder.theme.bg = utils.parseColor(options.bg);\n\t        }\n\n\t        if (options.fg) {\n\t            holder.theme.fg = utils.parseColor(options.fg);\n\t        }\n\n\t        //todo: add automatic foreground to themes without foreground\n\t        if (options.bg && !options.fg) {\n\t            holder.autoFg = true;\n\t        }\n\n\t        if (options.theme && holder.instanceOptions.themes.hasOwnProperty(options.theme)) {\n\t            holder.theme = extend(holder.instanceOptions.themes[options.theme], null);\n\t        }\n\n\t        // Text\n\n\t        if (options.text) {\n\t            holder.text = options.text;\n\t        }\n\n\t        if (options.textmode) {\n\t            holder.textmode = options.textmode;\n\t        }\n\n\t        if (options.size) {\n\t            holder.size = options.size;\n\t        }\n\n\t        if (options.font) {\n\t            holder.font = options.font;\n\t        }\n\n\t        if (options.align) {\n\t            holder.align = options.align;\n\t        }\n\n\t        if (options.lineWrap) {\n\t            holder.lineWrap = options.lineWrap;\n\t        }\n\n\t        holder.nowrap = utils.truthy(options.nowrap);\n\n\t        // Miscellaneous\n\n\t        holder.outline = utils.truthy(options.outline);\n\n\t        if (utils.truthy(options.random)) {\n\t            App.vars.cache.themeKeys = App.vars.cache.themeKeys || Object.keys(holder.instanceOptions.themes);\n\t            var _theme = App.vars.cache.themeKeys[0 | Math.random() * App.vars.cache.themeKeys.length];\n\t            holder.theme = extend(holder.instanceOptions.themes[_theme], null);\n\t        }\n\t    }\n\n\t    return holder;\n\t}\n\n\t/**\n\t * Modifies the DOM to fit placeholders and sets up resizable image callbacks (for fluid and automatically sized placeholders)\n\t *\n\t * @private\n\t * @param settings DOM prep settings\n\t */\n\tfunction prepareDOMElement(prepSettings) {\n\t    var mode = prepSettings.mode;\n\t    var el = prepSettings.el;\n\t    var flags = prepSettings.flags;\n\t    var _engineSettings = prepSettings.engineSettings;\n\t    var dimensions = flags.dimensions,\n\t        theme = flags.theme;\n\t    var dimensionsCaption = dimensions.width + 'x' + dimensions.height;\n\t    mode = mode == null ? (flags.fluid ? 'fluid' : 'image') : mode;\n\t    var holderTemplateRe = /holder_([a-z]+)/g;\n\t    var dimensionsInText = false;\n\n\t    if (flags.text != null) {\n\t        theme.text = flags.text;\n\n\t        //<object> SVG embedding doesn't parse Unicode properly\n\t        if (el.nodeName.toLowerCase() === 'object') {\n\t            var textLines = theme.text.split('\\\\n');\n\t            for (var k = 0; k < textLines.length; k++) {\n\t                textLines[k] = utils.encodeHtmlEntity(textLines[k]);\n\t            }\n\t            theme.text = textLines.join('\\\\n');\n\t        }\n\t    }\n\n\t    if (theme.text) {\n\t        var holderTemplateMatches = theme.text.match(holderTemplateRe);\n\n\t        if (holderTemplateMatches !== null) {\n\t            //todo: optimize template replacement\n\t            holderTemplateMatches.forEach(function (match) {\n\t                if (match === 'holder_dimensions') {\n\t                    theme.text = theme.text.replace(match, dimensionsCaption);\n\t                }\n\t            });\n\t        }\n\t    }\n\n\t    var holderURL = flags.holderURL;\n\t    var engineSettings = extend(_engineSettings, null);\n\n\t    if (flags.font) {\n\t        /*\n\t        If external fonts are used in a <img> placeholder rendered with SVG, Holder falls back to canvas.\n\n\t        This is done because Firefox and Chrome disallow embedded SVGs from referencing external assets.\n\t        The workaround is either to change the placeholder tag from <img> to <object> or to use the canvas renderer.\n\t        */\n\t        theme.font = flags.font;\n\t        if (!engineSettings.noFontFallback && el.nodeName.toLowerCase() === 'img' && App.setup.supportsCanvas && engineSettings.renderer === 'svg') {\n\t            engineSettings = extend(engineSettings, {\n\t                renderer: 'canvas'\n\t            });\n\t        }\n\t    }\n\n\t    //Chrome and Opera require a quick 10ms re-render if web fonts are used with canvas\n\t    if (flags.font && engineSettings.renderer == 'canvas') {\n\t        engineSettings.reRender = true;\n\t    }\n\n\t    if (mode == 'background') {\n\t        if (el.getAttribute('data-background-src') == null) {\n\t            DOM.setAttr(el, {\n\t                'data-background-src': holderURL\n\t            });\n\t        }\n\t    } else {\n\t        var domProps = {};\n\t        domProps[App.vars.dataAttr] = holderURL;\n\t        DOM.setAttr(el, domProps);\n\t    }\n\n\t    flags.theme = theme;\n\n\t    //todo consider using all renderSettings in holderData\n\t    el.holderData = {\n\t        flags: flags,\n\t        engineSettings: engineSettings\n\t    };\n\n\t    if (mode == 'image' || mode == 'fluid') {\n\t        DOM.setAttr(el, {\n\t            'alt': theme.text ? (dimensionsInText ? theme.text : theme.text + ' [' + dimensionsCaption + ']') : dimensionsCaption\n\t        });\n\t    }\n\n\t    var renderSettings = {\n\t        mode: mode,\n\t        el: el,\n\t        holderSettings: {\n\t            dimensions: dimensions,\n\t            theme: theme,\n\t            flags: flags\n\t        },\n\t        engineSettings: engineSettings\n\t    };\n\n\t    if (mode == 'image') {\n\t        if (!flags.auto) {\n\t            el.style.width = dimensions.width + 'px';\n\t            el.style.height = dimensions.height + 'px';\n\t        }\n\n\t        if (engineSettings.renderer == 'html') {\n\t            el.style.backgroundColor = theme.bg;\n\t        } else {\n\t            render(renderSettings);\n\n\t            if (flags.textmode == 'exact') {\n\t                el.holderData.resizeUpdate = true;\n\t                App.vars.resizableImages.push(el);\n\t                updateResizableElements(el);\n\t            }\n\t        }\n\t    } else if (mode == 'background' && engineSettings.renderer != 'html') {\n\t        render(renderSettings);\n\t    } else if (mode == 'fluid') {\n\t        el.holderData.resizeUpdate = true;\n\n\t        if (dimensions.height.slice(-1) == '%') {\n\t            el.style.height = dimensions.height;\n\t        } else if (flags.auto == null || !flags.auto) {\n\t            el.style.height = dimensions.height + 'px';\n\t        }\n\t        if (dimensions.width.slice(-1) == '%') {\n\t            el.style.width = dimensions.width;\n\t        } else if (flags.auto == null || !flags.auto) {\n\t            el.style.width = dimensions.width + 'px';\n\t        }\n\t        if (el.style.display == 'inline' || el.style.display === '' || el.style.display == 'none') {\n\t            el.style.display = 'block';\n\t        }\n\n\t        setInitialDimensions(el);\n\n\t        if (engineSettings.renderer == 'html') {\n\t            el.style.backgroundColor = theme.bg;\n\t        } else {\n\t            App.vars.resizableImages.push(el);\n\t            updateResizableElements(el);\n\t        }\n\t    }\n\t}\n\n\t/**\n\t * Core function that takes output from renderers and sets it as the source or background-image of the target element\n\t *\n\t * @private\n\t * @param renderSettings Renderer settings\n\t */\n\tfunction render(renderSettings) {\n\t    var image = null;\n\t    var mode = renderSettings.mode;\n\t    var el = renderSettings.el;\n\t    var holderSettings = renderSettings.holderSettings;\n\t    var engineSettings = renderSettings.engineSettings;\n\n\t    switch (engineSettings.renderer) {\n\t        case 'svg':\n\t            if (!App.setup.supportsSVG) return;\n\t            break;\n\t        case 'canvas':\n\t            if (!App.setup.supportsCanvas) return;\n\t            break;\n\t        default:\n\t            return;\n\t    }\n\n\t    //todo: move generation of scene up to flag generation to reduce extra object creation\n\t    var scene = {\n\t        width: holderSettings.dimensions.width,\n\t        height: holderSettings.dimensions.height,\n\t        theme: holderSettings.theme,\n\t        flags: holderSettings.flags\n\t    };\n\n\t    var sceneGraph = buildSceneGraph(scene);\n\n\t    function getRenderedImage() {\n\t        var image = null;\n\t        switch (engineSettings.renderer) {\n\t            case 'canvas':\n\t                image = sgCanvasRenderer(sceneGraph, renderSettings);\n\t                break;\n\t            case 'svg':\n\t                image = svgRenderer(sceneGraph, renderSettings);\n\t                break;\n\t            default:\n\t                throw 'Holder: invalid renderer: ' + engineSettings.renderer;\n\t        }\n\n\t        return image;\n\t    }\n\n\t    image = getRenderedImage();\n\n\t    if (image == null) {\n\t        throw 'Holder: couldn\\'t render placeholder';\n\t    }\n\n\t    //todo: add <object> canvas rendering\n\t    if (mode == 'background') {\n\t        el.style.backgroundImage = 'url(' + image + ')';\n\n\t        if (!engineSettings.noBackgroundSize) {\n\t            el.style.backgroundSize = scene.width + 'px ' + scene.height + 'px';\n\t        }\n\t    } else {\n\t        if (el.nodeName.toLowerCase() === 'img') {\n\t            DOM.setAttr(el, {\n\t                'src': image\n\t            });\n\t        } else if (el.nodeName.toLowerCase() === 'object') {\n\t            DOM.setAttr(el, {\n\t                'data': image,\n\t                'type': 'image/svg+xml'\n\t            });\n\t        }\n\t        if (engineSettings.reRender) {\n\t            global.setTimeout(function () {\n\t                var image = getRenderedImage();\n\t                if (image == null) {\n\t                    throw 'Holder: couldn\\'t render placeholder';\n\t                }\n\t                //todo: refactor this code into a function\n\t                if (el.nodeName.toLowerCase() === 'img') {\n\t                    DOM.setAttr(el, {\n\t                        'src': image\n\t                    });\n\t                } else if (el.nodeName.toLowerCase() === 'object') {\n\t                    DOM.setAttr(el, {\n\t                        'data': image,\n\t                        'type': 'image/svg+xml'\n\t                    });\n\t                }\n\t            }, 150);\n\t        }\n\t    }\n\t    //todo: account for re-rendering\n\t    DOM.setAttr(el, {\n\t        'data-holder-rendered': true\n\t    });\n\t}\n\n\t/**\n\t * Core function that takes a Holder scene description and builds a scene graph\n\t *\n\t * @private\n\t * @param scene Holder scene object\n\t */\n\t//todo: make this function reusable\n\t//todo: merge app defaults and setup properties into the scene argument\n\tfunction buildSceneGraph(scene) {\n\t    var fontSize = App.defaults.size;\n\t    if (parseFloat(scene.theme.size)) {\n\t        fontSize = scene.theme.size;\n\t    } else if (parseFloat(scene.flags.size)) {\n\t        fontSize = scene.flags.size;\n\t    }\n\n\t    scene.font = {\n\t        family: scene.theme.font ? scene.theme.font : 'Arial, Helvetica, Open Sans, sans-serif',\n\t        size: textSize(scene.width, scene.height, fontSize, App.defaults.scale),\n\t        units: scene.theme.units ? scene.theme.units : App.defaults.units,\n\t        weight: scene.theme.fontweight ? scene.theme.fontweight : 'bold'\n\t    };\n\n\t    scene.text = scene.theme.text || Math.floor(scene.width) + 'x' + Math.floor(scene.height);\n\n\t    scene.noWrap = scene.theme.nowrap || scene.flags.nowrap;\n\n\t    scene.align = scene.theme.align || scene.flags.align || 'center';\n\n\t    switch (scene.flags.textmode) {\n\t        case 'literal':\n\t            scene.text = scene.flags.dimensions.width + 'x' + scene.flags.dimensions.height;\n\t            break;\n\t        case 'exact':\n\t            if (!scene.flags.exactDimensions) break;\n\t            scene.text = Math.floor(scene.flags.exactDimensions.width) + 'x' + Math.floor(scene.flags.exactDimensions.height);\n\t            break;\n\t    }\n\n\t    var lineWrap = scene.flags.lineWrap || App.setup.lineWrapRatio;\n\t    var sceneMargin = scene.width * lineWrap;\n\t    var maxLineWidth = sceneMargin;\n\n\t    var sceneGraph = new SceneGraph({\n\t        width: scene.width,\n\t        height: scene.height\n\t    });\n\n\t    var Shape = sceneGraph.Shape;\n\n\t    var holderBg = new Shape.Rect('holderBg', {\n\t        fill: scene.theme.bg\n\t    });\n\n\t    holderBg.resize(scene.width, scene.height);\n\t    sceneGraph.root.add(holderBg);\n\n\t    if (scene.flags.outline) {\n\t        var outlineColor = new Color(holderBg.properties.fill);\n\t        outlineColor = outlineColor.lighten(outlineColor.lighterThan('7f7f7f') ? -0.1 : 0.1);\n\t        holderBg.properties.outline = {\n\t            fill: outlineColor.toHex(true),\n\t            width: 2\n\t        };\n\t    }\n\n\t    var holderTextColor = scene.theme.fg;\n\n\t    if (scene.flags.autoFg) {\n\t        var holderBgColor = new Color(holderBg.properties.fill);\n\t        var lightColor = new Color('fff');\n\t        var darkColor = new Color('000', {\n\t            'alpha': 0.285714\n\t        });\n\n\t        holderTextColor = holderBgColor.blendAlpha(holderBgColor.lighterThan('7f7f7f') ? darkColor : lightColor).toHex(true);\n\t    }\n\n\t    var holderTextGroup = new Shape.Group('holderTextGroup', {\n\t        text: scene.text,\n\t        align: scene.align,\n\t        font: scene.font,\n\t        fill: holderTextColor\n\t    });\n\n\t    holderTextGroup.moveTo(null, null, 1);\n\t    sceneGraph.root.add(holderTextGroup);\n\n\t    var tpdata = holderTextGroup.textPositionData = stagingRenderer(sceneGraph);\n\t    if (!tpdata) {\n\t        throw 'Holder: staging fallback not supported yet.';\n\t    }\n\t    holderTextGroup.properties.leading = tpdata.boundingBox.height;\n\n\t    var textNode = null;\n\t    var line = null;\n\n\t    function finalizeLine(parent, line, width, height) {\n\t        line.width = width;\n\t        line.height = height;\n\t        parent.width = Math.max(parent.width, line.width);\n\t        parent.height += line.height;\n\t    }\n\n\t    if (tpdata.lineCount > 1) {\n\t        var offsetX = 0;\n\t        var offsetY = 0;\n\t        var lineIndex = 0;\n\t        var lineKey;\n\t        line = new Shape.Group('line' + lineIndex);\n\n\t        //Double margin so that left/right-aligned next is not flush with edge of image\n\t        if (scene.align === 'left' || scene.align === 'right') {\n\t            maxLineWidth = scene.width * (1 - (1 - lineWrap) * 2);\n\t        }\n\n\t        for (var i = 0; i < tpdata.words.length; i++) {\n\t            var word = tpdata.words[i];\n\t            textNode = new Shape.Text(word.text);\n\t            var newline = word.text == '\\\\n';\n\t            if (!scene.noWrap && (offsetX + word.width >= maxLineWidth || newline === true)) {\n\t                finalizeLine(holderTextGroup, line, offsetX, holderTextGroup.properties.leading);\n\t                holderTextGroup.add(line);\n\t                offsetX = 0;\n\t                offsetY += holderTextGroup.properties.leading;\n\t                lineIndex += 1;\n\t                line = new Shape.Group('line' + lineIndex);\n\t                line.y = offsetY;\n\t            }\n\t            if (newline === true) {\n\t                continue;\n\t            }\n\t            textNode.moveTo(offsetX, 0);\n\t            offsetX += tpdata.spaceWidth + word.width;\n\t            line.add(textNode);\n\t        }\n\n\t        finalizeLine(holderTextGroup, line, offsetX, holderTextGroup.properties.leading);\n\t        holderTextGroup.add(line);\n\n\t        if (scene.align === 'left') {\n\t            holderTextGroup.moveTo(scene.width - sceneMargin, null, null);\n\t        } else if (scene.align === 'right') {\n\t            for (lineKey in holderTextGroup.children) {\n\t                line = holderTextGroup.children[lineKey];\n\t                line.moveTo(scene.width - line.width, null, null);\n\t            }\n\n\t            holderTextGroup.moveTo(0 - (scene.width - sceneMargin), null, null);\n\t        } else {\n\t            for (lineKey in holderTextGroup.children) {\n\t                line = holderTextGroup.children[lineKey];\n\t                line.moveTo((holderTextGroup.width - line.width) / 2, null, null);\n\t            }\n\n\t            holderTextGroup.moveTo((scene.width - holderTextGroup.width) / 2, null, null);\n\t        }\n\n\t        holderTextGroup.moveTo(null, (scene.height - holderTextGroup.height) / 2, null);\n\n\t        //If the text exceeds vertical space, move it down so the first line is visible\n\t        if ((scene.height - holderTextGroup.height) / 2 < 0) {\n\t            holderTextGroup.moveTo(null, 0, null);\n\t        }\n\t    } else {\n\t        textNode = new Shape.Text(scene.text);\n\t        line = new Shape.Group('line0');\n\t        line.add(textNode);\n\t        holderTextGroup.add(line);\n\n\t        if (scene.align === 'left') {\n\t            holderTextGroup.moveTo(scene.width - sceneMargin, null, null);\n\t        } else if (scene.align === 'right') {\n\t            holderTextGroup.moveTo(0 - (scene.width - sceneMargin), null, null);\n\t        } else {\n\t            holderTextGroup.moveTo((scene.width - tpdata.boundingBox.width) / 2, null, null);\n\t        }\n\n\t        holderTextGroup.moveTo(null, (scene.height - tpdata.boundingBox.height) / 2, null);\n\t    }\n\n\t    //todo: renderlist\n\t    return sceneGraph;\n\t}\n\n\t/**\n\t * Adaptive text sizing function\n\t *\n\t * @private\n\t * @param width Parent width\n\t * @param height Parent height\n\t * @param fontSize Requested text size\n\t * @param scale Proportional scale of text\n\t */\n\tfunction textSize(width, height, fontSize, scale) {\n\t    var stageWidth = parseInt(width, 10);\n\t    var stageHeight = parseInt(height, 10);\n\n\t    var bigSide = Math.max(stageWidth, stageHeight);\n\t    var smallSide = Math.min(stageWidth, stageHeight);\n\n\t    var newHeight = 0.8 * Math.min(smallSide, bigSide * scale);\n\t    return Math.round(Math.max(fontSize, newHeight));\n\t}\n\n\t/**\n\t * Iterates over resizable (fluid or auto) placeholders and renders them\n\t *\n\t * @private\n\t * @param element Optional element selector, specified only if a specific element needs to be re-rendered\n\t */\n\tfunction updateResizableElements(element) {\n\t    var images;\n\t    if (element == null || element.nodeType == null) {\n\t        images = App.vars.resizableImages;\n\t    } else {\n\t        images = [element];\n\t    }\n\t    for (var i = 0, l = images.length; i < l; i++) {\n\t        var el = images[i];\n\t        if (el.holderData) {\n\t            var flags = el.holderData.flags;\n\t            var dimensions = dimensionCheck(el);\n\t            if (dimensions) {\n\t                if (!el.holderData.resizeUpdate) {\n\t                    continue;\n\t                }\n\n\t                if (flags.fluid && flags.auto) {\n\t                    var fluidConfig = el.holderData.fluidConfig;\n\t                    switch (fluidConfig.mode) {\n\t                        case 'width':\n\t                            dimensions.height = dimensions.width / fluidConfig.ratio;\n\t                            break;\n\t                        case 'height':\n\t                            dimensions.width = dimensions.height * fluidConfig.ratio;\n\t                            break;\n\t                    }\n\t                }\n\n\t                var settings = {\n\t                    mode: 'image',\n\t                    holderSettings: {\n\t                        dimensions: dimensions,\n\t                        theme: flags.theme,\n\t                        flags: flags\n\t                    },\n\t                    el: el,\n\t                    engineSettings: el.holderData.engineSettings\n\t                };\n\n\t                if (flags.textmode == 'exact') {\n\t                    flags.exactDimensions = dimensions;\n\t                    settings.holderSettings.dimensions = flags.dimensions;\n\t                }\n\n\t                render(settings);\n\t            } else {\n\t                setInvisible(el);\n\t            }\n\t        }\n\t    }\n\t}\n\n\t/**\n\t * Sets up aspect ratio metadata for fluid placeholders, in order to preserve proportions when resizing\n\t *\n\t * @private\n\t * @param el Image DOM element\n\t */\n\tfunction setInitialDimensions(el) {\n\t    if (el.holderData) {\n\t        var dimensions = dimensionCheck(el);\n\t        if (dimensions) {\n\t            var flags = el.holderData.flags;\n\n\t            var fluidConfig = {\n\t                fluidHeight: flags.dimensions.height.slice(-1) == '%',\n\t                fluidWidth: flags.dimensions.width.slice(-1) == '%',\n\t                mode: null,\n\t                initialDimensions: dimensions\n\t            };\n\n\t            if (fluidConfig.fluidWidth && !fluidConfig.fluidHeight) {\n\t                fluidConfig.mode = 'width';\n\t                fluidConfig.ratio = fluidConfig.initialDimensions.width / parseFloat(flags.dimensions.height);\n\t            } else if (!fluidConfig.fluidWidth && fluidConfig.fluidHeight) {\n\t                fluidConfig.mode = 'height';\n\t                fluidConfig.ratio = parseFloat(flags.dimensions.width) / fluidConfig.initialDimensions.height;\n\t            }\n\n\t            el.holderData.fluidConfig = fluidConfig;\n\t        } else {\n\t            setInvisible(el);\n\t        }\n\t    }\n\t}\n\n\t/**\n\t * Iterates through all current invisible images, and if they're visible, renders them and removes them from further checks. Runs every animation frame.\n\t *\n\t * @private\n\t */\n\tfunction visibilityCheck() {\n\t    var renderableImages = [];\n\t    var keys = Object.keys(App.vars.invisibleImages);\n\t    var el;\n\n\t    keys.forEach(function (key) {\n\t        el = App.vars.invisibleImages[key];\n\t        if (dimensionCheck(el) && el.nodeName.toLowerCase() == 'img') {\n\t            renderableImages.push(el);\n\t            delete App.vars.invisibleImages[key];\n\t        }\n\t    });\n\n\t    if (renderableImages.length) {\n\t        Holder.run({\n\t            images: renderableImages\n\t        });\n\t    }\n\n\t    // Done to prevent 100% CPU usage via aggressive calling of requestAnimationFrame\n\t    setTimeout(function () {\n\t        global.requestAnimationFrame(visibilityCheck);\n\t    }, 10);\n\t}\n\n\t/**\n\t * Starts checking for invisible placeholders if not doing so yet. Does nothing otherwise.\n\t *\n\t * @private\n\t */\n\tfunction startVisibilityCheck() {\n\t    if (!App.vars.visibilityCheckStarted) {\n\t        global.requestAnimationFrame(visibilityCheck);\n\t        App.vars.visibilityCheckStarted = true;\n\t    }\n\t}\n\n\t/**\n\t * Sets a unique ID for an image detected to be invisible and adds it to the map of invisible images checked by visibilityCheck\n\t *\n\t * @private\n\t * @param el Invisible DOM element\n\t */\n\tfunction setInvisible(el) {\n\t    if (!el.holderData.invisibleId) {\n\t        App.vars.invisibleId += 1;\n\t        App.vars.invisibleImages['i' + App.vars.invisibleId] = el;\n\t        el.holderData.invisibleId = App.vars.invisibleId;\n\t    }\n\t}\n\n\t//todo: see if possible to convert stagingRenderer to use HTML only\n\tvar stagingRenderer = (function() {\n\t    var svg = null,\n\t        stagingText = null,\n\t        stagingTextNode = null;\n\t    return function(graph) {\n\t        var rootNode = graph.root;\n\t        if (App.setup.supportsSVG) {\n\t            var firstTimeSetup = false;\n\t            var tnode = function(text) {\n\t                return document.createTextNode(text);\n\t            };\n\t            if (svg == null || svg.parentNode !== document.body) {\n\t                firstTimeSetup = true;\n\t            }\n\n\t            svg = SVG.initSVG(svg, rootNode.properties.width, rootNode.properties.height);\n\t            //Show staging element before staging\n\t            svg.style.display = 'block';\n\n\t            if (firstTimeSetup) {\n\t                stagingText = DOM.newEl('text', SVG_NS);\n\t                stagingTextNode = tnode(null);\n\t                DOM.setAttr(stagingText, {\n\t                    x: 0\n\t                });\n\t                stagingText.appendChild(stagingTextNode);\n\t                svg.appendChild(stagingText);\n\t                document.body.appendChild(svg);\n\t                svg.style.visibility = 'hidden';\n\t                svg.style.position = 'absolute';\n\t                svg.style.top = '-100%';\n\t                svg.style.left = '-100%';\n\t                //todo: workaround for zero-dimension <svg> tag in Opera 12\n\t                //svg.setAttribute('width', 0);\n\t                //svg.setAttribute('height', 0);\n\t            }\n\n\t            var holderTextGroup = rootNode.children.holderTextGroup;\n\t            var htgProps = holderTextGroup.properties;\n\t            DOM.setAttr(stagingText, {\n\t                'y': htgProps.font.size,\n\t                'style': utils.cssProps({\n\t                    'font-weight': htgProps.font.weight,\n\t                    'font-size': htgProps.font.size + htgProps.font.units,\n\t                    'font-family': htgProps.font.family\n\t                })\n\t            });\n\n\t            //Get bounding box for the whole string (total width and height)\n\t            stagingTextNode.nodeValue = htgProps.text;\n\t            var stagingTextBBox = stagingText.getBBox();\n\n\t            //Get line count and split the string into words\n\t            var lineCount = Math.ceil(stagingTextBBox.width / rootNode.properties.width);\n\t            var words = htgProps.text.split(' ');\n\t            var newlines = htgProps.text.match(/\\\\n/g);\n\t            lineCount += newlines == null ? 0 : newlines.length;\n\n\t            //Get bounding box for the string with spaces removed\n\t            stagingTextNode.nodeValue = htgProps.text.replace(/[ ]+/g, '');\n\t            var computedNoSpaceLength = stagingText.getComputedTextLength();\n\n\t            //Compute average space width\n\t            var diffLength = stagingTextBBox.width - computedNoSpaceLength;\n\t            var spaceWidth = Math.round(diffLength / Math.max(1, words.length - 1));\n\n\t            //Get widths for every word with space only if there is more than one line\n\t            var wordWidths = [];\n\t            if (lineCount > 1) {\n\t                stagingTextNode.nodeValue = '';\n\t                for (var i = 0; i < words.length; i++) {\n\t                    if (words[i].length === 0) continue;\n\t                    stagingTextNode.nodeValue = utils.decodeHtmlEntity(words[i]);\n\t                    var bbox = stagingText.getBBox();\n\t                    wordWidths.push({\n\t                        text: words[i],\n\t                        width: bbox.width\n\t                    });\n\t                }\n\t            }\n\n\t            //Hide staging element after staging\n\t            svg.style.display = 'none';\n\n\t            return {\n\t                spaceWidth: spaceWidth,\n\t                lineCount: lineCount,\n\t                boundingBox: stagingTextBBox,\n\t                words: wordWidths\n\t            };\n\t        } else {\n\t            //todo: canvas fallback for measuring text on android 2.3\n\t            return false;\n\t        }\n\t    };\n\t})();\n\n\t//Helpers\n\n\t/**\n\t * Prevents a function from being called too often, waits until a timer elapses to call it again\n\t *\n\t * @param fn Function to call\n\t */\n\tfunction debounce(fn) {\n\t    if (!App.vars.debounceTimer) fn.call(this);\n\t    if (App.vars.debounceTimer) global.clearTimeout(App.vars.debounceTimer);\n\t    App.vars.debounceTimer = global.setTimeout(function() {\n\t        App.vars.debounceTimer = null;\n\t        fn.call(this);\n\t    }, App.setup.debounce);\n\t}\n\n\t/**\n\t * Holder-specific resize/orientation change callback, debounced to prevent excessive execution\n\t */\n\tfunction resizeEvent() {\n\t    debounce(function() {\n\t        updateResizableElements(null);\n\t    });\n\t}\n\n\t//Set up flags\n\n\tfor (var flag in App.flags) {\n\t    if (!App.flags.hasOwnProperty(flag)) continue;\n\t    App.flags[flag].match = function(val) {\n\t        return val.match(this.regex);\n\t    };\n\t}\n\n\t//Properties set once on setup\n\n\tApp.setup = {\n\t    renderer: 'html',\n\t    debounce: 100,\n\t    ratio: 1,\n\t    supportsCanvas: false,\n\t    supportsSVG: false,\n\t    lineWrapRatio: 0.9,\n\t    dataAttr: 'data-src',\n\t    renderers: ['html', 'canvas', 'svg']\n\t};\n\n\t//Properties modified during runtime\n\n\tApp.vars = {\n\t    preempted: false,\n\t    resizableImages: [],\n\t    invisibleImages: {},\n\t    invisibleId: 0,\n\t    visibilityCheckStarted: false,\n\t    debounceTimer: null,\n\t    cache: {}\n\t};\n\n\t//Pre-flight\n\n\t(function() {\n\t    var canvas = DOM.newEl('canvas');\n\n\t    if (canvas.getContext) {\n\t        if (canvas.toDataURL('image/png').indexOf('data:image/png') != -1) {\n\t            App.setup.renderer = 'canvas';\n\t            App.setup.supportsCanvas = true;\n\t        }\n\t    }\n\n\t    if (!!document.createElementNS && !!document.createElementNS(SVG_NS, 'svg').createSVGRect) {\n\t        App.setup.renderer = 'svg';\n\t        App.setup.supportsSVG = true;\n\t    }\n\t})();\n\n\t//Starts checking for invisible placeholders\n\tstartVisibilityCheck();\n\n\tif (onDomReady) {\n\t    onDomReady(function() {\n\t        if (!App.vars.preempted) {\n\t            Holder.run();\n\t        }\n\t        if (global.addEventListener) {\n\t            global.addEventListener('resize', resizeEvent, false);\n\t            global.addEventListener('orientationchange', resizeEvent, false);\n\t        } else {\n\t            global.attachEvent('onresize', resizeEvent);\n\t        }\n\n\t        if (typeof global.Turbolinks == 'object') {\n\t            global.document.addEventListener('page:change', function() {\n\t                Holder.run();\n\t            });\n\t        }\n\t    });\n\t}\n\n\tmodule.exports = Holder;\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * onDomReady.js 1.4.0 (c) 2013 Tubal Martin - MIT license\n\t *\n\t * Specially modified to work with Holder.js\n\t */\n\n\tfunction _onDomReady(win) {\n\t    //Lazy loading fix for Firefox < 3.6\n\t    //http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html\n\t    if (document.readyState == null && document.addEventListener) {\n\t        document.addEventListener(\"DOMContentLoaded\", function DOMContentLoaded() {\n\t            document.removeEventListener(\"DOMContentLoaded\", DOMContentLoaded, false);\n\t            document.readyState = \"complete\";\n\t        }, false);\n\t        document.readyState = \"loading\";\n\t    }\n\t    \n\t    var doc = win.document,\n\t        docElem = doc.documentElement,\n\t    \n\t        LOAD = \"load\",\n\t        FALSE = false,\n\t        ONLOAD = \"on\"+LOAD,\n\t        COMPLETE = \"complete\",\n\t        READYSTATE = \"readyState\",\n\t        ATTACHEVENT = \"attachEvent\",\n\t        DETACHEVENT = \"detachEvent\",\n\t        ADDEVENTLISTENER = \"addEventListener\",\n\t        DOMCONTENTLOADED = \"DOMContentLoaded\",\n\t        ONREADYSTATECHANGE = \"onreadystatechange\",\n\t        REMOVEEVENTLISTENER = \"removeEventListener\",\n\t    \n\t        // W3C Event model\n\t        w3c = ADDEVENTLISTENER in doc,\n\t        _top = FALSE,\n\t    \n\t        // isReady: Is the DOM ready to be used? Set to true once it occurs.\n\t        isReady = FALSE,\n\t    \n\t        // Callbacks pending execution until DOM is ready\n\t        callbacks = [];\n\t    \n\t    // Handle when the DOM is ready\n\t    function ready( fn ) {\n\t        if ( !isReady ) {\n\t    \n\t            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\t            if ( !doc.body ) {\n\t                return defer( ready );\n\t            }\n\t    \n\t            // Remember that the DOM is ready\n\t            isReady = true;\n\t    \n\t            // Execute all callbacks\n\t            while ( fn = callbacks.shift() ) {\n\t                defer( fn );\n\t            }\n\t        }\n\t    }\n\t    \n\t    // The ready event handler\n\t    function completed( event ) {\n\t        // readyState === \"complete\" is good enough for us to call the dom ready in oldIE\n\t        if ( w3c || event.type === LOAD || doc[READYSTATE] === COMPLETE ) {\n\t            detach();\n\t            ready();\n\t        }\n\t    }\n\t    \n\t    // Clean-up method for dom ready events\n\t    function detach() {\n\t        if ( w3c ) {\n\t            doc[REMOVEEVENTLISTENER]( DOMCONTENTLOADED, completed, FALSE );\n\t            win[REMOVEEVENTLISTENER]( LOAD, completed, FALSE );\n\t        } else {\n\t            doc[DETACHEVENT]( ONREADYSTATECHANGE, completed );\n\t            win[DETACHEVENT]( ONLOAD, completed );\n\t        }\n\t    }\n\t    \n\t    // Defers a function, scheduling it to run after the current call stack has cleared.\n\t    function defer( fn, wait ) {\n\t        // Allow 0 to be passed\n\t        setTimeout( fn, +wait >= 0 ? wait : 1 );\n\t    }\n\t    \n\t    // Attach the listeners:\n\t    \n\t    // Catch cases where onDomReady is called after the browser event has already occurred.\n\t    // we once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t    // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t    if ( doc[READYSTATE] === COMPLETE ) {\n\t        // Handle it asynchronously to allow scripts the opportunity to delay ready\n\t        defer( ready );\n\t    \n\t    // Standards-based browsers support DOMContentLoaded\n\t    } else if ( w3c ) {\n\t        // Use the handy event callback\n\t        doc[ADDEVENTLISTENER]( DOMCONTENTLOADED, completed, FALSE );\n\t    \n\t        // A fallback to window.onload, that will always work\n\t        win[ADDEVENTLISTENER]( LOAD, completed, FALSE );\n\t    \n\t    // If IE event model is used\n\t    } else {\n\t        // Ensure firing before onload, maybe late but safe also for iframes\n\t        doc[ATTACHEVENT]( ONREADYSTATECHANGE, completed );\n\t    \n\t        // A fallback to window.onload, that will always work\n\t        win[ATTACHEVENT]( ONLOAD, completed );\n\t    \n\t        // If IE and not a frame\n\t        // continually check to see if the document is ready\n\t        try {\n\t            _top = win.frameElement == null && docElem;\n\t        } catch(e) {}\n\t    \n\t        if ( _top && _top.doScroll ) {\n\t            (function doScrollCheck() {\n\t                if ( !isReady ) {\n\t                    try {\n\t                        // Use the trick by Diego Perini\n\t                        // http://javascript.nwbox.com/IEContentLoaded/\n\t                        _top.doScroll(\"left\");\n\t                    } catch(e) {\n\t                        return defer( doScrollCheck, 50 );\n\t                    }\n\t    \n\t                    // detach all dom ready events\n\t                    detach();\n\t    \n\t                    // and execute any waiting functions\n\t                    ready();\n\t                }\n\t            })();\n\t        }\n\t    }\n\t    \n\t    function onDomReady( fn ) {\n\t        // If DOM is ready, execute the function (async), otherwise wait\n\t        isReady ? defer( fn ) : callbacks.push( fn );\n\t    }\n\t    \n\t    // Add version\n\t    onDomReady.version = \"1.4.0\";\n\t    // Add method to check if DOM is ready\n\t    onDomReady.isReady = function(){\n\t        return isReady;\n\t    };\n\n\t    return onDomReady;\n\t}\n\n\tmodule.exports = typeof window !== \"undefined\" && _onDomReady(window);\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t//Modified version of component/querystring\n\t//Changes: updated dependencies, dot notation parsing, JSHint fixes\n\t//Fork at https://github.com/imsky/querystring\n\n\t/**\n\t * Module dependencies.\n\t */\n\n\tvar encode = encodeURIComponent;\n\tvar decode = decodeURIComponent;\n\tvar trim = __webpack_require__(4);\n\tvar type = __webpack_require__(5);\n\n\tvar arrayRegex = /(\\w+)\\[(\\d+)\\]/;\n\tvar objectRegex = /\\w+\\.\\w+/;\n\n\t/**\n\t * Parse the given query `str`.\n\t *\n\t * @param {String} str\n\t * @return {Object}\n\t * @api public\n\t */\n\n\texports.parse = function(str){\n\t  if ('string' !== typeof str) return {};\n\n\t  str = trim(str);\n\t  if ('' === str) return {};\n\t  if ('?' === str.charAt(0)) str = str.slice(1);\n\n\t  var obj = {};\n\t  var pairs = str.split('&');\n\t  for (var i = 0; i < pairs.length; i++) {\n\t    var parts = pairs[i].split('=');\n\t    var key = decode(parts[0]);\n\t    var m, ctx, prop;\n\n\t    if (m = arrayRegex.exec(key)) {\n\t      obj[m[1]] = obj[m[1]] || [];\n\t      obj[m[1]][m[2]] = decode(parts[1]);\n\t      continue;\n\t    }\n\n\t    if (m = objectRegex.test(key)) {\n\t      m = key.split('.');\n\t      ctx = obj;\n\t      \n\t      while (m.length) {\n\t        prop = m.shift();\n\n\t        if (!prop.length) continue;\n\n\t        if (!ctx[prop]) {\n\t          ctx[prop] = {};\n\t        } else if (ctx[prop] && typeof ctx[prop] !== 'object') {\n\t          break;\n\t        }\n\n\t        if (!m.length) {\n\t          ctx[prop] = decode(parts[1]);\n\t        }\n\n\t        ctx = ctx[prop];\n\t      }\n\n\t      continue;\n\t    }\n\n\t    obj[parts[0]] = null == parts[1] ? '' : decode(parts[1]);\n\t  }\n\n\t  return obj;\n\t};\n\n\t/**\n\t * Stringify the given `obj`.\n\t *\n\t * @param {Object} obj\n\t * @return {String}\n\t * @api public\n\t */\n\n\texports.stringify = function(obj){\n\t  if (!obj) return '';\n\t  var pairs = [];\n\n\t  for (var key in obj) {\n\t    var value = obj[key];\n\n\t    if ('array' == type(value)) {\n\t      for (var i = 0; i < value.length; ++i) {\n\t        pairs.push(encode(key + '[' + i + ']') + '=' + encode(value[i]));\n\t      }\n\t      continue;\n\t    }\n\n\t    pairs.push(encode(key) + '=' + encode(obj[key]));\n\t  }\n\n\t  return pairs.join('&');\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t\n\texports = module.exports = trim;\n\n\tfunction trim(str){\n\t  return str.replace(/^\\s*|\\s*$/g, '');\n\t}\n\n\texports.left = function(str){\n\t  return str.replace(/^\\s*/, '');\n\t};\n\n\texports.right = function(str){\n\t  return str.replace(/\\s*$/, '');\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/**\n\t * toString ref.\n\t */\n\n\tvar toString = Object.prototype.toString;\n\n\t/**\n\t * Return the type of `val`.\n\t *\n\t * @param {Mixed} val\n\t * @return {String}\n\t * @api public\n\t */\n\n\tmodule.exports = function(val){\n\t  switch (toString.call(val)) {\n\t    case '[object Date]': return 'date';\n\t    case '[object RegExp]': return 'regexp';\n\t    case '[object Arguments]': return 'arguments';\n\t    case '[object Array]': return 'array';\n\t    case '[object Error]': return 'error';\n\t  }\n\n\t  if (val === null) return 'null';\n\t  if (val === undefined) return 'undefined';\n\t  if (val !== val) return 'nan';\n\t  if (val && val.nodeType === 1) return 'element';\n\n\t  if (isBuffer(val)) return 'buffer';\n\n\t  val = val.valueOf\n\t    ? val.valueOf()\n\t    : Object.prototype.valueOf.apply(val);\n\n\t  return typeof val;\n\t};\n\n\t// code borrowed from https://github.com/feross/is-buffer/blob/master/index.js\n\tfunction isBuffer(obj) {\n\t  return !!(obj != null &&\n\t    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)\n\t      (obj.constructor &&\n\t      typeof obj.constructor.isBuffer === 'function' &&\n\t      obj.constructor.isBuffer(obj))\n\t    ))\n\t}\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tvar SceneGraph = function(sceneProperties) {\n\t    var nodeCount = 1;\n\n\t    //todo: move merge to helpers section\n\t    function merge(parent, child) {\n\t        for (var prop in child) {\n\t            parent[prop] = child[prop];\n\t        }\n\t        return parent;\n\t    }\n\n\t    var SceneNode = function(name) {\n\t        nodeCount++;\n\t        this.parent = null;\n\t        this.children = {};\n\t        this.id = nodeCount;\n\t        this.name = 'n' + nodeCount;\n\t        if (typeof name !== 'undefined') {\n\t            this.name = name;\n\t        }\n\t        this.x = this.y = this.z = 0;\n\t        this.width = this.height = 0;\n\t    };\n\n\t    SceneNode.prototype.resize = function(width, height) {\n\t        if (width != null) {\n\t            this.width = width;\n\t        }\n\t        if (height != null) {\n\t            this.height = height;\n\t        }\n\t    };\n\n\t    SceneNode.prototype.moveTo = function(x, y, z) {\n\t        this.x = x != null ? x : this.x;\n\t        this.y = y != null ? y : this.y;\n\t        this.z = z != null ? z : this.z;\n\t    };\n\n\t    SceneNode.prototype.add = function(child) {\n\t        var name = child.name;\n\t        if (typeof this.children[name] === 'undefined') {\n\t            this.children[name] = child;\n\t            child.parent = this;\n\t        } else {\n\t            throw 'SceneGraph: child already exists: ' + name;\n\t        }\n\t    };\n\n\t    var RootNode = function() {\n\t        SceneNode.call(this, 'root');\n\t        this.properties = sceneProperties;\n\t    };\n\n\t    RootNode.prototype = new SceneNode();\n\n\t    var Shape = function(name, props) {\n\t        SceneNode.call(this, name);\n\t        this.properties = {\n\t            'fill': '#000000'\n\t        };\n\t        if (typeof props !== 'undefined') {\n\t            merge(this.properties, props);\n\t        } else if (typeof name !== 'undefined' && typeof name !== 'string') {\n\t            throw 'SceneGraph: invalid node name';\n\t        }\n\t    };\n\n\t    Shape.prototype = new SceneNode();\n\n\t    var Group = function() {\n\t        Shape.apply(this, arguments);\n\t        this.type = 'group';\n\t    };\n\n\t    Group.prototype = new Shape();\n\n\t    var Rect = function() {\n\t        Shape.apply(this, arguments);\n\t        this.type = 'rect';\n\t    };\n\n\t    Rect.prototype = new Shape();\n\n\t    var Text = function(text) {\n\t        Shape.call(this);\n\t        this.type = 'text';\n\t        this.properties.text = text;\n\t    };\n\n\t    Text.prototype = new Shape();\n\n\t    var root = new RootNode();\n\n\t    this.Shape = {\n\t        'Rect': Rect,\n\t        'Text': Text,\n\t        'Group': Group\n\t    };\n\n\t    this.root = root;\n\t    return this;\n\t};\n\n\tmodule.exports = SceneGraph;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Shallow object clone and merge\n\t *\n\t * @param a Object A\n\t * @param b Object B\n\t * @returns {Object} New object with all of A's properties, and all of B's properties, overwriting A's properties\n\t */\n\texports.extend = function(a, b) {\n\t    var c = {};\n\t    for (var x in a) {\n\t        if (a.hasOwnProperty(x)) {\n\t            c[x] = a[x];\n\t        }\n\t    }\n\t    if (b != null) {\n\t        for (var y in b) {\n\t            if (b.hasOwnProperty(y)) {\n\t                c[y] = b[y];\n\t            }\n\t        }\n\t    }\n\t    return c;\n\t};\n\n\t/**\n\t * Takes a k/v list of CSS properties and returns a rule\n\t *\n\t * @param props CSS properties object\n\t */\n\texports.cssProps = function(props) {\n\t    var ret = [];\n\t    for (var p in props) {\n\t        if (props.hasOwnProperty(p)) {\n\t            ret.push(p + ':' + props[p]);\n\t        }\n\t    }\n\t    return ret.join(';');\n\t};\n\n\t/**\n\t * Encodes HTML entities in a string\n\t *\n\t * @param str Input string\n\t */\n\texports.encodeHtmlEntity = function(str) {\n\t    var buf = [];\n\t    var charCode = 0;\n\t    for (var i = str.length - 1; i >= 0; i--) {\n\t        charCode = str.charCodeAt(i);\n\t        if (charCode > 128) {\n\t            buf.unshift(['&#', charCode, ';'].join(''));\n\t        } else {\n\t            buf.unshift(str[i]);\n\t        }\n\t    }\n\t    return buf.join('');\n\t};\n\n\t/**\n\t * Checks if an image exists\n\t *\n\t * @param src URL of image\n\t * @param callback Callback to call once image status has been found\n\t */\n\texports.imageExists = function(src, callback) {\n\t    var image = new Image();\n\t    image.onerror = function() {\n\t        callback.call(this, false);\n\t    };\n\t    image.onload = function() {\n\t        callback.call(this, true);\n\t    };\n\t    image.src = src;\n\t};\n\n\t/**\n\t * Decodes HTML entities in a string\n\t *\n\t * @param str Input string\n\t */\n\texports.decodeHtmlEntity = function(str) {\n\t    return str.replace(/&#(\\d+);/g, function(match, dec) {\n\t        return String.fromCharCode(dec);\n\t    });\n\t};\n\n\n\t/**\n\t * Returns an element's dimensions if it's visible, `false` otherwise.\n\t *\n\t * @param el DOM element\n\t */\n\texports.dimensionCheck = function(el) {\n\t    var dimensions = {\n\t        height: el.clientHeight,\n\t        width: el.clientWidth\n\t    };\n\n\t    if (dimensions.height && dimensions.width) {\n\t        return dimensions;\n\t    } else {\n\t        return false;\n\t    }\n\t};\n\n\n\t/**\n\t * Returns true if value is truthy or if it is \"semantically truthy\"\n\t * @param val\n\t */\n\texports.truthy = function(val) {\n\t    if (typeof val === 'string') {\n\t        return val === 'true' || val === 'yes' || val === '1' || val === 'on' || val === 'â';\n\t    }\n\t    return !!val;\n\t};\n\n\t/**\n\t * Parses input into a well-formed CSS color\n\t * @param val\n\t */\n\texports.parseColor = function(val) {\n\t    var hexre = /(^(?:#?)[0-9a-f]{6}$)|(^(?:#?)[0-9a-f]{3}$)/i;\n\t    var rgbre = /^rgb\\((\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)$/;\n\t    var rgbare = /^rgba\\((\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(0\\.\\d{1,}|1)\\)$/;\n\n\t    var match = val.match(hexre);\n\t    var retval;\n\n\t    if (match !== null) {\n\t        retval = match[1] || match[2];\n\t        if (retval[0] !== '#') {\n\t            return '#' + retval;\n\t        } else {\n\t            return retval;\n\t        }\n\t    }\n\n\t    match = val.match(rgbre);\n\n\t    if (match !== null) {\n\t        retval = 'rgb(' + match.slice(1).join(',') + ')';\n\t        return retval;\n\t    }\n\n\t    match = val.match(rgbare);\n\n\t    if (match !== null) {\n\t        retval = 'rgba(' + match.slice(1).join(',') + ')';\n\t        return retval;\n\t    }\n\n\t    return null;\n\t};\n\n\t/**\n\t * Provides the correct scaling ratio for canvas drawing operations on HiDPI screens (e.g. Retina displays)\n\t */\n\texports.canvasRatio = function () {\n\t    var devicePixelRatio = 1;\n\t    var backingStoreRatio = 1;\n\n\t    if (global.document) {\n\t        var canvas = global.document.createElement('canvas');\n\t        if (canvas.getContext) {\n\t            var ctx = canvas.getContext('2d');\n\t            devicePixelRatio = global.devicePixelRatio || 1;\n\t            backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;\n\t        }\n\t    }\n\n\t    return devicePixelRatio / backingStoreRatio;\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var DOM = __webpack_require__(9);\n\n\tvar SVG_NS = 'http://www.w3.org/2000/svg';\n\tvar NODE_TYPE_COMMENT = 8;\n\n\t/**\n\t * Generic SVG element creation function\n\t *\n\t * @param svg SVG context, set to null if new\n\t * @param width Document width\n\t * @param height Document height\n\t */\n\texports.initSVG = function(svg, width, height) {\n\t    var defs, style, initialize = false;\n\n\t    if (svg && svg.querySelector) {\n\t        style = svg.querySelector('style');\n\t        if (style === null) {\n\t            initialize = true;\n\t        }\n\t    } else {\n\t        svg = DOM.newEl('svg', SVG_NS);\n\t        initialize = true;\n\t    }\n\n\t    if (initialize) {\n\t        defs = DOM.newEl('defs', SVG_NS);\n\t        style = DOM.newEl('style', SVG_NS);\n\t        DOM.setAttr(style, {\n\t            'type': 'text/css'\n\t        });\n\t        defs.appendChild(style);\n\t        svg.appendChild(defs);\n\t    }\n\n\t    //IE throws an exception if this is set and Chrome requires it to be set\n\t    if (svg.webkitMatchesSelector) {\n\t        svg.setAttribute('xmlns', SVG_NS);\n\t    }\n\n\t    //Remove comment nodes\n\t    for (var i = 0; i < svg.childNodes.length; i++) {\n\t        if (svg.childNodes[i].nodeType === NODE_TYPE_COMMENT) {\n\t            svg.removeChild(svg.childNodes[i]);\n\t        }\n\t    }\n\n\t    //Remove CSS\n\t    while (style.childNodes.length) {\n\t        style.removeChild(style.childNodes[0]);\n\t    }\n\n\t    DOM.setAttr(svg, {\n\t        'width': width,\n\t        'height': height,\n\t        'viewBox': '0 0 ' + width + ' ' + height,\n\t        'preserveAspectRatio': 'none'\n\t    });\n\n\t    return svg;\n\t};\n\n\t/**\n\t * Converts serialized SVG to a string suitable for data URI use\n\t * @param svgString Serialized SVG string\n\t * @param [base64] Use base64 encoding for data URI\n\t */\n\texports.svgStringToDataURI = function() {\n\t    var rawPrefix = 'data:image/svg+xml;charset=UTF-8,';\n\t    var base64Prefix = 'data:image/svg+xml;charset=UTF-8;base64,';\n\n\t    return function(svgString, base64) {\n\t        if (base64) {\n\t            return base64Prefix + btoa(global.unescape(encodeURIComponent(svgString)));\n\t        } else {\n\t            return rawPrefix + encodeURIComponent(svgString);\n\t        }\n\t    };\n\t}();\n\n\t/**\n\t * Returns serialized SVG with XML processing instructions\n\t *\n\t * @param svg SVG context\n\t * @param stylesheets CSS stylesheets to include\n\t */\n\texports.serializeSVG = function(svg, engineSettings) {\n\t    if (!global.XMLSerializer) return;\n\t    var serializer = new XMLSerializer();\n\t    var svgCSS = '';\n\t    var stylesheets = engineSettings.stylesheets;\n\n\t    //External stylesheets: Processing Instruction method\n\t    if (engineSettings.svgXMLStylesheet) {\n\t        var xml = DOM.createXML();\n\t        //Add <?xml-stylesheet ?> directives\n\t        for (var i = stylesheets.length - 1; i >= 0; i--) {\n\t            var csspi = xml.createProcessingInstruction('xml-stylesheet', 'href=\"' + stylesheets[i] + '\" rel=\"stylesheet\"');\n\t            xml.insertBefore(csspi, xml.firstChild);\n\t        }\n\n\t        xml.removeChild(xml.documentElement);\n\t        svgCSS = serializer.serializeToString(xml);\n\t    }\n\n\t    var svgText = serializer.serializeToString(svg);\n\t    svgText = svgText.replace(/\\&amp;(\\#[0-9]{2,}\\;)/g, '&$1');\n\t    return svgCSS + svgText;\n\t};\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/**\n\t * Generic new DOM element function\n\t *\n\t * @param tag Tag to create\n\t * @param namespace Optional namespace value\n\t */\n\texports.newEl = function(tag, namespace) {\n\t    if (!global.document) return;\n\n\t    if (namespace == null) {\n\t        return global.document.createElement(tag);\n\t    } else {\n\t        return global.document.createElementNS(namespace, tag);\n\t    }\n\t};\n\n\t/**\n\t * Generic setAttribute function\n\t *\n\t * @param el Reference to DOM element\n\t * @param attrs Object with attribute keys and values\n\t */\n\texports.setAttr = function (el, attrs) {\n\t    for (var a in attrs) {\n\t        el.setAttribute(a, attrs[a]);\n\t    }\n\t};\n\n\t/**\n\t * Creates a XML document\n\t * @private\n\t */\n\texports.createXML = function() {\n\t    if (!global.DOMParser) return;\n\t    return new DOMParser().parseFromString('<xml />', 'application/xml');\n\t};\n\n\t/**\n\t * Converts a value into an array of DOM nodes\n\t *\n\t * @param val A string, a NodeList, a Node, or an HTMLCollection\n\t */\n\texports.getNodeArray = function(val) {\n\t    var retval = null;\n\t    if (typeof(val) == 'string') {\n\t        retval = document.querySelectorAll(val);\n\t    } else if (global.NodeList && val instanceof global.NodeList) {\n\t        retval = val;\n\t    } else if (global.Node && val instanceof global.Node) {\n\t        retval = [val];\n\t    } else if (global.HTMLCollection && val instanceof global.HTMLCollection) {\n\t        retval = val;\n\t    } else if (val instanceof Array) {\n\t        retval = val;\n\t    } else if (val === null) {\n\t        retval = [];\n\t    }\n\n\t    retval = Array.prototype.slice.call(retval);\n\n\t    return retval;\n\t};\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tvar Color = function(color, options) {\n\t    //todo: support rgba, hsla, and rrggbbaa notation\n\t    //todo: use CIELAB internally\n\t    //todo: add clamp function (with sign)\n\t    if (typeof color !== 'string') return;\n\n\t    this.original = color;\n\n\t    if (color.charAt(0) === '#') {\n\t        color = color.slice(1);\n\t    }\n\n\t    if (/[^a-f0-9]+/i.test(color)) return;\n\n\t    if (color.length === 3) {\n\t        color = color.replace(/./g, '$&$&');\n\t    }\n\n\t    if (color.length !== 6) return;\n\n\t    this.alpha = 1;\n\n\t    if (options && options.alpha) {\n\t        this.alpha = options.alpha;\n\t    }\n\n\t    this.set(parseInt(color, 16));\n\t};\n\n\t//todo: jsdocs\n\tColor.rgb2hex = function(r, g, b) {\n\t    function format (decimal) {\n\t        var hex = (decimal | 0).toString(16);\n\t        if (decimal < 16) {\n\t            hex = '0' + hex;\n\t        }\n\t        return hex;\n\t    }\n\n\t    return [r, g, b].map(format).join('');\n\t};\n\n\t//todo: jsdocs\n\tColor.hsl2rgb = function (h, s, l) {\n\t    var H = h / 60;\n\t    var C = (1 - Math.abs(2 * l - 1)) * s;\n\t    var X = C * (1 - Math.abs(parseInt(H) % 2 - 1));\n\t    var m = l - (C / 2);\n\n\t    var r = 0, g = 0, b = 0;\n\n\t    if (H >= 0 && H < 1) {\n\t        r = C;\n\t        g = X;\n\t    } else if (H >= 1 && H < 2) {\n\t        r = X;\n\t        g = C;\n\t    } else if (H >= 2 && H < 3) {\n\t        g = C;\n\t        b = X;\n\t    } else if (H >= 3 && H < 4) {\n\t        g = X;\n\t        b = C;\n\t    } else if (H >= 4 && H < 5) {\n\t        r = X;\n\t        b = C;\n\t    } else if (H >= 5 && H < 6) {\n\t        r = C;\n\t        b = X;\n\t    }\n\n\t    r += m;\n\t    g += m;\n\t    b += m;\n\n\t    r = parseInt(r * 255);\n\t    g = parseInt(g * 255);\n\t    b = parseInt(b * 255);\n\n\t    return [r, g, b];\n\t};\n\n\t/**\n\t * Sets the color from a raw RGB888 integer\n\t * @param raw RGB888 representation of color\n\t */\n\t//todo: refactor into a static method\n\t//todo: factor out individual color spaces\n\t//todo: add HSL, CIELAB, and CIELUV\n\tColor.prototype.set = function (val) {\n\t    this.raw = val;\n\n\t    var r = (this.raw & 0xFF0000) >> 16;\n\t    var g = (this.raw & 0x00FF00) >> 8;\n\t    var b = (this.raw & 0x0000FF);\n\n\t    // BT.709\n\t    var y = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n\t    var u = -0.09991 * r - 0.33609 * g + 0.436 * b;\n\t    var v = 0.615 * r - 0.55861 * g - 0.05639 * b;\n\n\t    this.rgb = {\n\t        r: r,\n\t        g: g,\n\t        b: b\n\t    };\n\n\t    this.yuv = {\n\t        y: y,\n\t        u: u,\n\t        v: v\n\t    };\n\n\t    return this;\n\t};\n\n\t/**\n\t * Lighten or darken a color\n\t * @param multiplier Amount to lighten or darken (-1 to 1)\n\t */\n\tColor.prototype.lighten = function(multiplier) {\n\t    var cm = Math.min(1, Math.max(0, Math.abs(multiplier))) * (multiplier < 0 ? -1 : 1);\n\t    var bm = (255 * cm) | 0;\n\t    var cr = Math.min(255, Math.max(0, this.rgb.r + bm));\n\t    var cg = Math.min(255, Math.max(0, this.rgb.g + bm));\n\t    var cb = Math.min(255, Math.max(0, this.rgb.b + bm));\n\t    var hex = Color.rgb2hex(cr, cg, cb);\n\t    return new Color(hex);\n\t};\n\n\t/**\n\t * Output color in hex format\n\t * @param addHash Add a hash character to the beginning of the output\n\t */\n\tColor.prototype.toHex = function(addHash) {\n\t    return (addHash ? '#' : '') + this.raw.toString(16);\n\t};\n\n\t/**\n\t * Returns whether or not current color is lighter than another color\n\t * @param color Color to compare against\n\t */\n\tColor.prototype.lighterThan = function(color) {\n\t    if (!(color instanceof Color)) {\n\t        color = new Color(color);\n\t    }\n\n\t    return this.yuv.y > color.yuv.y;\n\t};\n\n\t/**\n\t * Returns the result of mixing current color with another color\n\t * @param color Color to mix with\n\t * @param multiplier How much to mix with the other color\n\t */\n\t/*\n\tColor.prototype.mix = function (color, multiplier) {\n\t    if (!(color instanceof Color)) {\n\t        color = new Color(color);\n\t    }\n\n\t    var r = this.rgb.r;\n\t    var g = this.rgb.g;\n\t    var b = this.rgb.b;\n\t    var a = this.alpha;\n\n\t    var m = typeof multiplier !== 'undefined' ? multiplier : 0.5;\n\n\t    //todo: write a lerp function\n\t    r = r + m * (color.rgb.r - r);\n\t    g = g + m * (color.rgb.g - g);\n\t    b = b + m * (color.rgb.b - b);\n\t    a = a + m * (color.alpha - a);\n\n\t    return new Color(Color.rgbToHex(r, g, b), {\n\t        'alpha': a\n\t    });\n\t};\n\t*/\n\n\t/**\n\t * Returns the result of blending another color on top of current color with alpha\n\t * @param color Color to blend on top of current color, i.e. \"Ca\"\n\t */\n\t//todo: see if .blendAlpha can be merged into .mix\n\tColor.prototype.blendAlpha = function(color) {\n\t    if (!(color instanceof Color)) {\n\t        color = new Color(color);\n\t    }\n\n\t    var Ca = color;\n\t    var Cb = this;\n\n\t    //todo: write alpha blending function\n\t    var r = Ca.alpha * Ca.rgb.r + (1 - Ca.alpha) * Cb.rgb.r;\n\t    var g = Ca.alpha * Ca.rgb.g + (1 - Ca.alpha) * Cb.rgb.g;\n\t    var b = Ca.alpha * Ca.rgb.b + (1 - Ca.alpha) * Cb.rgb.b;\n\n\t    return new Color(Color.rgb2hex(r, g, b));\n\t};\n\n\tmodule.exports = Color;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t  'version': '2.9.4',\n\t  'svg_ns': 'http://www.w3.org/2000/svg'\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar shaven = __webpack_require__(13);\n\n\tvar SVG = __webpack_require__(8);\n\tvar constants = __webpack_require__(11);\n\tvar utils = __webpack_require__(7);\n\n\tvar SVG_NS = constants.svg_ns;\n\n\tvar templates = {\n\t  'element': function (options) {\n\t    var tag = options.tag;\n\t    var content = options.content || '';\n\t    delete options.tag;\n\t    delete options.content;\n\t    return  [tag, content, options];\n\t  }\n\t};\n\n\t//todo: deprecate tag arg, infer tag from shape object\n\tfunction convertShape (shape, tag) {\n\t  return templates.element({\n\t    'tag': tag,\n\t    'width': shape.width,\n\t    'height': shape.height,\n\t    'fill': shape.properties.fill\n\t  });\n\t}\n\n\tfunction textCss (properties) {\n\t  return utils.cssProps({\n\t    'fill': properties.fill,\n\t    'font-weight': properties.font.weight,\n\t    'font-family': properties.font.family + ', monospace',\n\t    'font-size': properties.font.size + properties.font.units\n\t  });\n\t}\n\n\tfunction outlinePath (bgWidth, bgHeight, outlineWidth) {\n\t  var outlineOffsetWidth = outlineWidth / 2;\n\n\t  return [\n\t    'M', outlineOffsetWidth, outlineOffsetWidth,\n\t    'H', bgWidth - outlineOffsetWidth,\n\t    'V', bgHeight - outlineOffsetWidth,\n\t    'H', outlineOffsetWidth,\n\t    'V', 0,\n\t    'M', 0, outlineOffsetWidth,\n\t    'L', bgWidth, bgHeight - outlineOffsetWidth,\n\t    'M', 0, bgHeight - outlineOffsetWidth,\n\t    'L', bgWidth, outlineOffsetWidth\n\t  ].join(' ');\n\t}\n\n\tmodule.exports = function (sceneGraph, renderSettings) {\n\t  var engineSettings = renderSettings.engineSettings;\n\t  var stylesheets = engineSettings.stylesheets;\n\t  var stylesheetXml = stylesheets.map(function (stylesheet) {\n\t    return '<?xml-stylesheet rel=\"stylesheet\" href=\"' + stylesheet + '\"?>';\n\t  }).join('\\n');\n\n\t  var holderId = 'holder_' + Number(new Date()).toString(16);\n\n\t  var root = sceneGraph.root;\n\t  var textGroup = root.children.holderTextGroup;\n\n\t  var css = '#' + holderId + ' text { ' + textCss(textGroup.properties) + ' } ';\n\n\t  // push text down to be equally vertically aligned with canvas renderer\n\t  textGroup.y += textGroup.textPositionData.boundingBox.height * 0.8;\n\n\t  var wordTags = [];\n\n\t  Object.keys(textGroup.children).forEach(function (lineKey) {\n\t    var line = textGroup.children[lineKey];\n\n\t    Object.keys(line.children).forEach(function (wordKey) {\n\t      var word = line.children[wordKey];\n\t      var x = textGroup.x + line.x + word.x;\n\t      var y = textGroup.y + line.y + word.y;\n\n\t      var wordTag = templates.element({\n\t        'tag': 'text',\n\t        'content': word.properties.text,\n\t        'x': x,\n\t        'y': y\n\t      });\n\n\t      wordTags.push(wordTag);\n\t    });\n\t  });\n\n\t  var text = templates.element({\n\t    'tag': 'g',\n\t    'content': wordTags\n\t  });\n\n\t  var outline = null;\n\n\t  if (root.children.holderBg.properties.outline) {\n\t    var outlineProperties = root.children.holderBg.properties.outline;\n\t    outline = templates.element({\n\t      'tag': 'path',\n\t      'd': outlinePath(root.children.holderBg.width, root.children.holderBg.height, outlineProperties.width),\n\t      'stroke-width': outlineProperties.width,\n\t      'stroke': outlineProperties.fill,\n\t      'fill': 'none'\n\t    });\n\t  }\n\n\t  var bg = convertShape(root.children.holderBg, 'rect');\n\n\t  var sceneContent = [];\n\n\t  sceneContent.push(bg);\n\t  if (outlineProperties) {\n\t    sceneContent.push(outline);\n\t  }\n\t  sceneContent.push(text);\n\n\t  var scene = templates.element({\n\t    'tag': 'g',\n\t    'id': holderId,\n\t    'content': sceneContent\n\t  });\n\n\t  var style = templates.element({\n\t    'tag': 'style',\n\t    //todo: figure out how to add CDATA directive\n\t    'content': css,\n\t    'type': 'text/css'\n\t  });\n\n\t  var defs = templates.element({\n\t    'tag': 'defs',\n\t    'content': style\n\t  });\n\n\t  var svg = templates.element({\n\t    'tag': 'svg',\n\t    'content': [defs, scene],\n\t    'width': root.properties.width,\n\t    'height': root.properties.height,\n\t    'xmlns': SVG_NS,\n\t    'viewBox': [0, 0, root.properties.width, root.properties.height].join(' '),\n\t    'preserveAspectRatio': 'none'\n\t  });\n\n\t  var output = shaven(svg);\n\t  \n\t  output = stylesheetXml + output[0];\n\n\t  var svgString = SVG.svgStringToDataURI(output, renderSettings.mode === 'background');\n\t  return svgString;\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar escape = __webpack_require__(14)\n\n\t// TODO: remove namespace\n\n\tmodule.exports = function shaven (array, namespace, returnObject) {\n\n\t\t'use strict'\n\n\t\tvar i = 1\n\t\tvar doesEscape = true\n\t\tvar HTMLString\n\t\tvar attributeKey\n\t\tvar callback\n\t\tvar key\n\n\n\t\treturnObject = returnObject || {}\n\n\n\t\tfunction createElement (sugarString) {\n\n\t\t\tvar tags = sugarString.match(/^[\\w-]+/)\n\t\t\tvar element = {\n\t\t\t\ttag: tags ? tags[0] : 'div',\n\t\t\t\tattr: {},\n\t\t\t\tchildren: []\n\t\t\t}\n\t\t\tvar id = sugarString.match(/#([\\w-]+)/)\n\t\t\tvar reference = sugarString.match(/\\$([\\w-]+)/)\n\t\t\tvar classNames = sugarString.match(/\\.[\\w-]+/g)\n\n\n\t\t\t// Assign id if is set\n\t\t\tif (id) {\n\t\t\t\telement.attr.id = id[1]\n\n\t\t\t\t// Add element to the return object\n\t\t\t\treturnObject[id[1]] = element\n\t\t\t}\n\n\t\t\tif (reference)\n\t\t\t\treturnObject[reference[1]] = element\n\n\t\t\tif (classNames)\n\t\t\t\telement.attr.class = classNames.join(' ').replace(/\\./g, '')\n\n\t\t\tif (sugarString.match(/&$/g))\n\t\t\t\tdoesEscape = false\n\n\t\t\treturn element\n\t\t}\n\n\t\tfunction replacer (key, value) {\n\n\t\t\tif (value === null || value === false || value === undefined)\n\t\t\t\treturn\n\n\t\t\tif (typeof value !== 'string' && typeof value !== 'object')\n\t\t\t\treturn String(value)\n\n\t\t\treturn value\n\t\t}\n\n\t\tfunction escapeAttribute (string) {\n\t\t\treturn (string || string === 0) ?\n\t\t\t\tString(string)\n\t\t\t\t\t.replace(/&/g, '&amp;')\n\t\t\t\t\t.replace(/\"/g, '&quot;') :\n\t\t\t\t''\n\t\t}\n\n\t\tfunction escapeHTML (string) {\n\t\t\treturn String(string)\n\t\t\t\t.replace(/&/g, '&amp;')\n\t\t\t\t.replace(/\"/g, '&quot;')\n\t\t\t\t.replace(/'/g, '&apos;')\n\t\t\t\t.replace(/</g, '&lt;')\n\t\t\t\t.replace(/>/g, '&gt;')\n\t\t}\n\n\n\t\tif (typeof array[0] === 'string')\n\t\t\tarray[0] = createElement(array[0])\n\n\t\telse if (Array.isArray(array[0]))\n\t\t\ti = 0\n\n\t\telse\n\t\t\tthrow new Error(\n\t\t\t\t'First element of array must be a string, ' +\n\t\t\t\t'or an array and not ' + JSON.stringify(array[0])\n\t\t\t)\n\n\n\t\tfor (; i < array.length; i++) {\n\n\t\t\t// Don't render element if value is false or null\n\t\t\tif (array[i] === false || array[i] === null) {\n\t\t\t\tarray[0] = false\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Continue with next array value if current value is undefined or true\n\t\t\telse if (array[i] === undefined || array[i] === true) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\telse if (typeof array[i] === 'string') {\n\t\t\t\tif (doesEscape)\n\t\t\t\t\tarray[i] = escapeHTML(array[i])\n\n\t\t\t\tarray[0].children.push(array[i])\n\t\t\t}\n\n\t\t\telse if (typeof array[i] === 'number') {\n\n\t\t\t\tarray[0].children.push(array[i])\n\t\t\t}\n\n\t\t\telse if (Array.isArray(array[i])) {\n\n\t\t\t\tif (Array.isArray(array[i][0])) {\n\t\t\t\t\tarray[i].reverse().forEach(function (subArray) {\n\t\t\t\t\t\tarray.splice(i + 1, 0, subArray)\n\t\t\t\t\t})\n\n\t\t\t\t\tif (i !== 0)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\ti++\n\t\t\t\t}\n\n\t\t\t\tshaven(array[i], namespace, returnObject)\n\n\t\t\t\tif (array[i][0])\n\t\t\t\t\tarray[0].children.push(array[i][0])\n\t\t\t}\n\n\t\t\telse if (typeof array[i] === 'function')\n\t\t\t\tcallback = array[i]\n\n\n\t\t\telse if (typeof array[i] === 'object') {\n\t\t\t\tfor (attributeKey in array[i])\n\t\t\t\t\tif (array[i].hasOwnProperty(attributeKey))\n\t\t\t\t\t\tif (array[i][attributeKey] !== null &&\n\t\t\t\t\t\t\tarray[i][attributeKey] !== false)\n\t\t\t\t\t\t\tif (attributeKey === 'style' &&\n\t\t\t\t\t\t\t\ttypeof array[i][attributeKey] === 'object')\n\t\t\t\t\t\t\t\tarray[0].attr[attributeKey] = JSON\n\t\t\t\t\t\t\t\t\t.stringify(array[i][attributeKey], replacer)\n\t\t\t\t\t\t\t\t\t.slice(2, -2)\n\t\t\t\t\t\t\t\t\t.replace(/\",\"/g, ';')\n\t\t\t\t\t\t\t\t\t.replace(/\":\"/g, ':')\n\t\t\t\t\t\t\t\t\t.replace(/\\\\\"/g, '\\'')\n\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tarray[0].attr[attributeKey] = array[i][attributeKey]\n\t\t\t}\n\n\t\t\telse\n\t\t\t\tthrow new TypeError('\"' + array[i] + '\" is not allowed as a value.')\n\t\t}\n\n\n\t\tif (array[0] !== false) {\n\n\t\t\tHTMLString = '<' + array[0].tag\n\n\t\t\tfor (key in array[0].attr)\n\t\t\t\tif (array[0].attr.hasOwnProperty(key))\n\t\t\t\t\tHTMLString += ' ' + key + '=\"' +\n\t\t\t\t\t\tescapeAttribute(array[0].attr[key]) + '\"'\n\n\t\t\tHTMLString += '>'\n\n\t\t\tarray[0].children.forEach(function (child) {\n\t\t\t\tHTMLString += child\n\t\t\t})\n\n\t\t\tHTMLString += '</' + array[0].tag + '>'\n\n\t\t\tarray[0] = HTMLString\n\t\t}\n\n\t\t// Return root element on index 0\n\t\treturnObject[0] = array[0]\n\n\t\tif (callback)\n\t\t\tcallback(array[0])\n\n\t\t// returns object containing all elements with an id and the root element\n\t\treturn returnObject\n\t}\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * escape-html\n\t * Copyright(c) 2012-2013 TJ Holowaychuk\n\t * Copyright(c) 2015 Andreas Lubbe\n\t * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n\t * MIT Licensed\n\t */\n\n\t'use strict';\n\n\t/**\n\t * Module variables.\n\t * @private\n\t */\n\n\tvar matchHtmlRegExp = /[\"'&<>]/;\n\n\t/**\n\t * Module exports.\n\t * @public\n\t */\n\n\tmodule.exports = escapeHtml;\n\n\t/**\n\t * Escape special characters in the given string of html.\n\t *\n\t * @param  {string} string The string to escape for inserting into HTML\n\t * @return {string}\n\t * @public\n\t */\n\n\tfunction escapeHtml(string) {\n\t  var str = '' + string;\n\t  var match = matchHtmlRegExp.exec(str);\n\n\t  if (!match) {\n\t    return str;\n\t  }\n\n\t  var escape;\n\t  var html = '';\n\t  var index = 0;\n\t  var lastIndex = 0;\n\n\t  for (index = match.index; index < str.length; index++) {\n\t    switch (str.charCodeAt(index)) {\n\t      case 34: // \"\n\t        escape = '&quot;';\n\t        break;\n\t      case 38: // &\n\t        escape = '&amp;';\n\t        break;\n\t      case 39: // '\n\t        escape = '&#39;';\n\t        break;\n\t      case 60: // <\n\t        escape = '&lt;';\n\t        break;\n\t      case 62: // >\n\t        escape = '&gt;';\n\t        break;\n\t      default:\n\t        continue;\n\t    }\n\n\t    if (lastIndex !== index) {\n\t      html += str.substring(lastIndex, index);\n\t    }\n\n\t    lastIndex = index + 1;\n\t    html += escape;\n\t  }\n\n\t  return lastIndex !== index\n\t    ? html + str.substring(lastIndex, index)\n\t    : html;\n\t}\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar DOM = __webpack_require__(9);\n\tvar utils = __webpack_require__(7);\n\n\tmodule.exports = (function() {\n\t    var canvas = DOM.newEl('canvas');\n\t    var ctx = null;\n\n\t    return function(sceneGraph) {\n\t        if (ctx == null) {\n\t            ctx = canvas.getContext('2d');\n\t        }\n\n\t        var dpr = utils.canvasRatio();\n\t        var root = sceneGraph.root;\n\t        canvas.width = dpr * root.properties.width;\n\t        canvas.height = dpr * root.properties.height ;\n\t        ctx.textBaseline = 'middle';\n\n\t        var bg = root.children.holderBg;\n\t        var bgWidth = dpr * bg.width;\n\t        var bgHeight = dpr * bg.height;\n\t        //todo: parametrize outline width (e.g. in scene object)\n\t        var outlineWidth = 2;\n\t        var outlineOffsetWidth = outlineWidth / 2;\n\n\t        ctx.fillStyle = bg.properties.fill;\n\t        ctx.fillRect(0, 0, bgWidth, bgHeight);\n\n\t        if (bg.properties.outline) {\n\t            //todo: abstract this into a method\n\t            ctx.strokeStyle = bg.properties.outline.fill;\n\t            ctx.lineWidth = bg.properties.outline.width;\n\t            ctx.moveTo(outlineOffsetWidth, outlineOffsetWidth);\n\t            // TL, TR, BR, BL\n\t            ctx.lineTo(bgWidth - outlineOffsetWidth, outlineOffsetWidth);\n\t            ctx.lineTo(bgWidth - outlineOffsetWidth, bgHeight - outlineOffsetWidth);\n\t            ctx.lineTo(outlineOffsetWidth, bgHeight - outlineOffsetWidth);\n\t            ctx.lineTo(outlineOffsetWidth, outlineOffsetWidth);\n\t            // Diagonals\n\t            ctx.moveTo(0, outlineOffsetWidth);\n\t            ctx.lineTo(bgWidth, bgHeight - outlineOffsetWidth);\n\t            ctx.moveTo(0, bgHeight - outlineOffsetWidth);\n\t            ctx.lineTo(bgWidth, outlineOffsetWidth);\n\t            ctx.stroke();\n\t        }\n\n\t        var textGroup = root.children.holderTextGroup;\n\t        ctx.font = textGroup.properties.font.weight + ' ' + (dpr * textGroup.properties.font.size) + textGroup.properties.font.units + ' ' + textGroup.properties.font.family + ', monospace';\n\t        ctx.fillStyle = textGroup.properties.fill;\n\n\t        for (var lineKey in textGroup.children) {\n\t            var line = textGroup.children[lineKey];\n\t            for (var wordKey in line.children) {\n\t                var word = line.children[wordKey];\n\t                var x = dpr * (textGroup.x + line.x + word.x);\n\t                var y = dpr * (textGroup.y + line.y + word.y + (textGroup.properties.leading / 2));\n\n\t                ctx.fillText(word.properties.text, x, y);\n\t            }\n\t        }\n\n\t        return canvas.toDataURL('image/png');\n\t    };\n\t})();\n\n/***/ }\n/******/ ])\n});\n;\n(function(ctx, isMeteorPackage) {\n    if (isMeteorPackage) {\n        Holder = ctx.Holder;\n    }\n})(this, typeof Meteor !== 'undefined' && typeof Package !== 'undefined');\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaG9sZGVyanMvaG9sZGVyLmpzPzI3NTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELDREQUE0RDtBQUM3RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscURBQXFEO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxtQkFBbUI7O0FBRWhFO0FBQ0E7QUFDQSxzQ0FBc0MsbUJBQW1COztBQUV6RDtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLGtDQUFrQztBQUN2RSxxQ0FBcUMsc0NBQXNDO0FBQzNFLHlDQUF5QyxzQ0FBc0M7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLHNDQUFzQzs7QUFFN0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7QUFDTCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7QUFDTCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjOztBQUVkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQSw2QkFBNkIsNEJBQTRCLGFBQWEsRUFBRTs7QUFFeEUsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRSxvQkFBb0IsRUFBRTtBQUMzRCw0QkFBNEIsSUFBSSxZQUFZLElBQUksWUFBWSxJQUFJO0FBQ2hFLDhCQUE4QixJQUFJLFlBQVksSUFBSSxZQUFZLElBQUksZUFBZSxHQUFHOztBQUVwRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsNEJBQTRCLGFBQWEsRUFBRTs7QUFFeEUsT0FBTztBQUNQO0FBQ0E7O0FBRUEsK0NBQStDOztBQUUvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsNENBQTRDLGNBQWM7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLFNBQVMsR0FBRyxFQUFFO0FBQ3BEO0FBQ0E7O0FBRUEsNkJBQTZCLDRCQUE0QixhQUFhLEVBQUU7O0FBRXhFLE9BQU87QUFDUDtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkIsNEJBQTRCLGFBQWEsRUFBRTs7QUFFeEUsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUEsc0NBQXNDLHdDQUF3Qzs7QUFFOUU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0EsTUFBTTtBQUNOLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsUUFBUSxrQkFBa0I7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuXG5Ib2xkZXIgLSBjbGllbnQgc2lkZSBpbWFnZSBwbGFjZWhvbGRlcnNcblZlcnNpb24gMi45LjQrY2FiaWxcbsKpIDIwMTYgSXZhbiBNYWxvcGluc2t5IC0gaHR0cDovL2ltc2t5LmNvXG5cblNpdGU6ICAgICBodHRwOi8vaG9sZGVyanMuY29tXG5Jc3N1ZXM6ICAgaHR0cHM6Ly9naXRodWIuY29tL2ltc2t5L2hvbGRlci9pc3N1ZXNcbkxpY2Vuc2U6ICBNSVRcblxuKi9cbihmdW5jdGlvbiAod2luZG93KSB7XG4gIGlmICghd2luZG93LmRvY3VtZW50KSByZXR1cm47XG4gIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9pbmV4b3JhYmxldGFzaC9wb2x5ZmlsbC9ibG9iL21hc3Rlci93ZWIuanNcbiAgICBpZiAoIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwpIHtcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgPSBmdW5jdGlvbiAoc2VsZWN0b3JzKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyksIGVsZW1lbnRzID0gW10sIGVsZW1lbnQ7XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5maXJzdENoaWxkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgZG9jdW1lbnQuX3FzYSA9IFtdO1xuXG4gICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHNlbGVjdG9ycyArICd7eC1xc2E6ZXhwcmVzc2lvbihkb2N1bWVudC5fcXNhICYmIGRvY3VtZW50Ll9xc2EucHVzaCh0aGlzKSl9JztcbiAgICAgICAgd2luZG93LnNjcm9sbEJ5KDAsIDApO1xuICAgICAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuICAgICAgICB3aGlsZSAoZG9jdW1lbnQuX3FzYS5sZW5ndGgpIHtcbiAgICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuX3FzYS5zaGlmdCgpO1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlQXR0cmlidXRlKCd4LXFzYScpO1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuX3FzYSA9IG51bGw7XG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKSB7XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9ycykge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9ycyk7XG4gICAgICAgIHJldHVybiAoZWxlbWVudHMubGVuZ3RoKSA/IGVsZW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSB7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gZnVuY3Rpb24gKGNsYXNzTmFtZXMpIHtcbiAgICAgICAgY2xhc3NOYW1lcyA9IFN0cmluZyhjbGFzc05hbWVzKS5yZXBsYWNlKC9efFxccysvZywgJy4nKTtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoY2xhc3NOYW1lcyk7XG4gICAgICB9O1xuICAgIH1cblxuICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9pbmV4b3JhYmxldGFzaC9wb2x5ZmlsbFxuICAvLyBFUzUgMTUuMi4zLjE0IE9iamVjdC5rZXlzICggTyApXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9rZXlzXG4gIGlmICghT2JqZWN0LmtleXMpIHtcbiAgICBPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICBpZiAobyAhPT0gT2JqZWN0KG8pKSB7IHRocm93IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIG5vbi1vYmplY3QnKTsgfVxuICAgICAgdmFyIHJldCA9IFtdLCBwO1xuICAgICAgZm9yIChwIGluIG8pIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkge1xuICAgICAgICAgIHJldC5wdXNoKHApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gIH1cblxuICAvLyBFUzUgMTUuNC40LjE4IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoICggY2FsbGJhY2tmbiBbICwgdGhpc0FyZyBdIClcbiAgLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoXG4gIGlmICghQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmdW4gLyosIHRoaXNwICovKSB7XG4gICAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpIHsgdGhyb3cgVHlwZUVycm9yKCk7IH1cblxuICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG4gICAgICBpZiAodHlwZW9mIGZ1biAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IFR5cGVFcnJvcigpOyB9XG5cbiAgICAgIHZhciB0aGlzcCA9IGFyZ3VtZW50c1sxXSwgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaSBpbiB0KSB7XG4gICAgICAgICAgZnVuLmNhbGwodGhpc3AsIHRbaV0sIGksIHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vaHR0cHM6Ly9naXRodWIuY29tL2luZXhvcmFibGV0YXNoL3BvbHlmaWxsL2Jsb2IvbWFzdGVyL3dlYi5qc1xuICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgIHZhciBCNjRfQUxQSEFCRVQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuICAgIGdsb2JhbC5hdG9iID0gZ2xvYmFsLmF0b2IgfHwgZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICBpbnB1dCA9IFN0cmluZyhpbnB1dCk7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwLFxuICAgICAgICAgIG91dHB1dCA9IFtdLFxuICAgICAgICAgIGJ1ZmZlciA9IDAsIGJpdHMgPSAwLCBuO1xuXG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICBpZiAoKGlucHV0Lmxlbmd0aCAlIDQpID09PSAwKSB7IGlucHV0ID0gaW5wdXQucmVwbGFjZSgvPSskLywgJycpOyB9XG4gICAgICBpZiAoKGlucHV0Lmxlbmd0aCAlIDQpID09PSAxKSB7IHRocm93IEVycm9yKCdJbnZhbGlkQ2hhcmFjdGVyRXJyb3InKTsgfVxuICAgICAgaWYgKC9bXisvMC05QS1aYS16XS8udGVzdChpbnB1dCkpIHsgdGhyb3cgRXJyb3IoJ0ludmFsaWRDaGFyYWN0ZXJFcnJvcicpOyB9XG5cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBuID0gQjY0X0FMUEhBQkVULmluZGV4T2YoaW5wdXQuY2hhckF0KHBvc2l0aW9uKSk7XG4gICAgICAgIGJ1ZmZlciA9IChidWZmZXIgPDwgNikgfCBuO1xuICAgICAgICBiaXRzICs9IDY7XG5cbiAgICAgICAgaWYgKGJpdHMgPT09IDI0KSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgoYnVmZmVyID4+IDE2KSAmIDB4RkYpKTtcbiAgICAgICAgICBvdXRwdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKChidWZmZXIgPj4gIDgpICYgMHhGRikpO1xuICAgICAgICAgIG91dHB1dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZmVyICYgMHhGRikpO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIGJ1ZmZlciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb24gKz0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJpdHMgPT09IDEyKSB7XG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlciA+PiA0O1xuICAgICAgICBvdXRwdXQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlciAmIDB4RkYpKTtcbiAgICAgIH0gZWxzZSBpZiAoYml0cyA9PT0gMTgpIHtcbiAgICAgICAgYnVmZmVyID0gYnVmZmVyID4+IDI7XG4gICAgICAgIG91dHB1dC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoKGJ1ZmZlciA+PiA4KSAmIDB4RkYpKTtcbiAgICAgICAgb3V0cHV0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXIgJiAweEZGKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gICAgfTtcblxuICAgIGdsb2JhbC5idG9hID0gZ2xvYmFsLmJ0b2EgfHwgZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICBpbnB1dCA9IFN0cmluZyhpbnB1dCk7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwLFxuICAgICAgICAgIG91dCA9IFtdLFxuICAgICAgICAgIG8xLCBvMiwgbzMsXG4gICAgICAgICAgZTEsIGUyLCBlMywgZTQ7XG5cbiAgICAgIGlmICgvW15cXHgwMC1cXHhGRl0vLnRlc3QoaW5wdXQpKSB7IHRocm93IEVycm9yKCdJbnZhbGlkQ2hhcmFjdGVyRXJyb3InKTsgfVxuXG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgbzEgPSBpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uKyspO1xuICAgICAgICBvMiA9IGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24rKyk7XG4gICAgICAgIG8zID0gaW5wdXQuY2hhckNvZGVBdChwb3NpdGlvbisrKTtcblxuICAgICAgICAvLyAxMTExMTEgMTEyMjIyIDIyMjIzMyAzMzMzMzNcbiAgICAgICAgZTEgPSBvMSA+PiAyO1xuICAgICAgICBlMiA9ICgobzEgJiAweDMpIDw8IDQpIHwgKG8yID4+IDQpO1xuICAgICAgICBlMyA9ICgobzIgJiAweGYpIDw8IDIpIHwgKG8zID4+IDYpO1xuICAgICAgICBlNCA9IG8zICYgMHgzZjtcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IGlucHV0Lmxlbmd0aCArIDIpIHtcbiAgICAgICAgICBlMyA9IDY0OyBlNCA9IDY0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uID09PSBpbnB1dC5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgZTQgPSA2NDtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dC5wdXNoKEI2NF9BTFBIQUJFVC5jaGFyQXQoZTEpLFxuICAgICAgICAgICAgICAgICBCNjRfQUxQSEFCRVQuY2hhckF0KGUyKSxcbiAgICAgICAgICAgICAgICAgQjY0X0FMUEhBQkVULmNoYXJBdChlMyksXG4gICAgICAgICAgICAgICAgIEI2NF9BTFBIQUJFVC5jaGFyQXQoZTQpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dC5qb2luKCcnKTtcbiAgICB9O1xuICB9KHdpbmRvdykpO1xuXG4gIC8vaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamltZWgvMzMyMzU3XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSl7XG4gICAgICAvKmpzaGludCAtVzAwMSwgLVcxMDMgKi9cbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgICB2YXIgcHJvdG8gPSB0aGlzLl9fcHJvdG9fXyB8fCB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgIHJldHVybiAocHJvcCBpbiB0aGlzKSAmJiAoIShwcm9wIGluIHByb3RvKSB8fCBwcm90b1twcm9wXSAhPT0gdGhpc1twcm9wXSk7XG4gICAgfTtcbiAgICAgIC8qanNoaW50ICtXMDAxLCArVzEwMyAqL1xuICB9XG5cbiAgLy8gQGxpY2Vuc2UgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICAvLyBjb3B5cmlnaHQgUGF1bCBJcmlzaCAyMDE1XG5cblxuICAvLyBEYXRlLm5vdygpIGlzIHN1cHBvcnRlZCBldmVyeXdoZXJlIGV4Y2VwdCBJRTguIEZvciBJRTggd2UgdXNlIHRoZSBEYXRlLm5vdyBwb2x5ZmlsbFxuICAvLyAgIGdpdGh1Yi5jb20vRmluYW5jaWFsLVRpbWVzL3BvbHlmaWxsLXNlcnZpY2UvYmxvYi9tYXN0ZXIvcG9seWZpbGxzL0RhdGUubm93L3BvbHlmaWxsLmpzXG4gIC8vIGFzIFNhZmFyaSA2IGRvZXNuJ3QgaGF2ZSBzdXBwb3J0IGZvciBOYXZpZ2F0aW9uVGltaW5nLCB3ZSB1c2UgYSBEYXRlLm5vdygpIHRpbWVzdGFtcCBmb3IgcmVsYXRpdmUgdmFsdWVzXG5cbiAgLy8gaWYgeW91IHdhbnQgdmFsdWVzIHNpbWlsYXIgdG8gd2hhdCB5b3UnZCBnZXQgd2l0aCByZWFsIHBlcmYubm93LCBwbGFjZSB0aGlzIHRvd2FyZHMgdGhlIGhlYWQgb2YgdGhlIHBhZ2VcbiAgLy8gYnV0IGluIHJlYWxpdHksIHlvdSdyZSBqdXN0IGdldHRpbmcgdGhlIGRlbHRhIGJldHdlZW4gbm93KCkgY2FsbHMsIHNvIGl0J3Mgbm90IHRlcnJpYmx5IGltcG9ydGFudCB3aGVyZSBpdCdzIHBsYWNlZFxuXG5cbiAgKGZ1bmN0aW9uKCl7XG5cbiAgICBpZiAoJ3BlcmZvcm1hbmNlJyBpbiB3aW5kb3cgPT09IGZhbHNlKSB7XG4gICAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZSA9IHt9O1xuICAgIH1cbiAgICBcbiAgICBEYXRlLm5vdyA9IChEYXRlLm5vdyB8fCBmdW5jdGlvbiAoKSB7ICAvLyB0aGFua3MgSUU4XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfSk7XG5cbiAgICBpZiAoJ25vdycgaW4gd2luZG93LnBlcmZvcm1hbmNlID09PSBmYWxzZSl7XG4gICAgICBcbiAgICAgIHZhciBub3dPZmZzZXQgPSBEYXRlLm5vdygpO1xuICAgICAgXG4gICAgICBpZiAocGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpe1xuICAgICAgICBub3dPZmZzZXQgPSBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0O1xuICAgICAgfVxuXG4gICAgICB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gbm93KCl7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbm93T2Zmc2V0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgfSkoKTtcblxuICAvL3JlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBmb3Igb2xkZXIgRmlyZWZveC9DaHJvbWUgdmVyc2lvbnNcbiAgaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgaWYgKHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgd2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgLy9odHRwczovL2dpdGh1Yi5jb20vRmluYW5jaWFsLVRpbWVzL3BvbHlmaWxsLXNlcnZpY2UvYmxvYi9tYXN0ZXIvcG9seWZpbGxzL3JlcXVlc3RBbmltYXRpb25GcmFtZS9wb2x5ZmlsbC13ZWJraXQuanNcbiAgICAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgICAgZ2xvYmFsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gd2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjayhnbG9iYWwucGVyZm9ybWFuY2Uubm93KCkpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGdsb2JhbC53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZTtcbiAgICB9KHdpbmRvdykpO1xuICAgIH0gZWxzZSBpZiAod2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL0ZpbmFuY2lhbC1UaW1lcy9wb2x5ZmlsbC1zZXJ2aWNlL2Jsb2IvbWFzdGVyL3BvbHlmaWxscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUvcG9seWZpbGwtbW96LmpzXG4gICAgKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICAgIGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG1velJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2soZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBnbG9iYWwuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBnbG9iYWwubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWU7XG4gICAgfSh3aW5kb3cpKTtcbiAgICB9IGVsc2Uge1xuICAgIChmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWwuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgIH07XG5cbiAgICAgIGdsb2JhbC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XG4gICAgfSkod2luZG93KTtcbiAgICB9XG4gIH1cbn0pKHRoaXMpO1xuXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJIb2xkZXJcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiSG9sZGVyXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qXG5cdEhvbGRlci5qcyAtIGNsaWVudCBzaWRlIGltYWdlIHBsYWNlaG9sZGVyc1xuXHQoYykgMjAxMi0yMDE1IEl2YW4gTWFsb3BpbnNreSAtIGh0dHA6Ly9pbXNreS5jb1xuXHQqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qXG5cdEhvbGRlci5qcyAtIGNsaWVudCBzaWRlIGltYWdlIHBsYWNlaG9sZGVyc1xuXHQoYykgMjAxMi0yMDE2IEl2YW4gTWFsb3BpbnNreSAtIGh0dHA6Ly9pbXNreS5jb1xuXHQqL1xuXG5cdC8vTGlicmFyaWVzIGFuZCBmdW5jdGlvbnNcblx0dmFyIG9uRG9tUmVhZHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHR2YXIgcXVlcnlzdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5cdHZhciBTY2VuZUdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0dmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0dmFyIFNWRyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdHZhciBET00gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHR2YXIgQ29sb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblx0dmFyIGNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5cdHZhciBzdmdSZW5kZXJlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXHR2YXIgc2dDYW52YXNSZW5kZXJlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG5cdHZhciBleHRlbmQgPSB1dGlscy5leHRlbmQ7XG5cdHZhciBkaW1lbnNpb25DaGVjayA9IHV0aWxzLmRpbWVuc2lvbkNoZWNrO1xuXG5cdC8vQ29uc3RhbnRzIGFuZCBkZWZpbml0aW9uc1xuXHR2YXIgU1ZHX05TID0gY29uc3RhbnRzLnN2Z19ucztcblxuXHR2YXIgSG9sZGVyID0ge1xuXHQgICAgdmVyc2lvbjogY29uc3RhbnRzLnZlcnNpb24sXG5cblx0ICAgIC8qKlxuXHQgICAgICogQWRkcyBhIHRoZW1lIHRvIGRlZmF1bHQgc2V0dGluZ3Ncblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGVtZSBuYW1lXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gdGhlbWUgVGhlbWUgb2JqZWN0LCB3aXRoIGZvcmVncm91bmQsIGJhY2tncm91bmQsIHNpemUsIGZvbnQsIGFuZCBmb250d2VpZ2h0IHByb3BlcnRpZXMuXG5cdCAgICAgKi9cblx0ICAgIGFkZFRoZW1lOiBmdW5jdGlvbihuYW1lLCB0aGVtZSkge1xuXHQgICAgICAgIG5hbWUgIT0gbnVsbCAmJiB0aGVtZSAhPSBudWxsICYmIChBcHAuc2V0dGluZ3MudGhlbWVzW25hbWVdID0gdGhlbWUpO1xuXHQgICAgICAgIGRlbGV0ZSBBcHAudmFycy5jYWNoZS50aGVtZUtleXM7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9LFxuXG5cdCAgICAvKipcblx0ICAgICAqIEFwcGVuZHMgYSBwbGFjZWhvbGRlciB0byBhbiBlbGVtZW50XG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBQbGFjZWhvbGRlciBVUkwgc3RyaW5nXG5cdCAgICAgKiBAcGFyYW0gZWwgQSBzZWxlY3RvciBvciBhIHJlZmVyZW5jZSB0byBhIERPTSBub2RlXG5cdCAgICAgKi9cblx0ICAgIGFkZEltYWdlOiBmdW5jdGlvbihzcmMsIGVsKSB7XG5cdCAgICAgICAgLy90b2RvOiB1c2UganF1ZXJ5IGZhbGxiYWNrIGlmIGF2YWlsYWJsZSBmb3IgYWxsIFFTQSByZWZlcmVuY2VzXG5cdCAgICAgICAgdmFyIG5vZGVzID0gRE9NLmdldE5vZGVBcnJheShlbCk7XG5cdCAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgICAgICB2YXIgaW1nID0gRE9NLm5ld0VsKCdpbWcnKTtcblx0ICAgICAgICAgICAgdmFyIGRvbVByb3BzID0ge307XG5cdCAgICAgICAgICAgIGRvbVByb3BzW0FwcC5zZXR1cC5kYXRhQXR0cl0gPSBzcmM7XG5cdCAgICAgICAgICAgIERPTS5zZXRBdHRyKGltZywgZG9tUHJvcHMpO1xuXHQgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGltZyk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9LFxuXG5cdCAgICAvKipcblx0ICAgICAqIFNldHMgd2hldGhlciBvciBub3QgYW4gaW1hZ2UgaXMgdXBkYXRlZCBvbiByZXNpemUuXG5cdCAgICAgKiBJZiBhbiBpbWFnZSBpcyBzZXQgdG8gYmUgdXBkYXRlZCwgaXQgaXMgaW1tZWRpYXRlbHkgcmVuZGVyZWQuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IGVsIEltYWdlIERPTSBlbGVtZW50XG5cdCAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIFJlc2l6YWJsZSB1cGRhdGUgZmxhZyB2YWx1ZVxuXHQgICAgICovXG5cdCAgICBzZXRSZXNpemVVcGRhdGU6IGZ1bmN0aW9uKGVsLCB2YWx1ZSkge1xuXHQgICAgICAgIGlmIChlbC5ob2xkZXJEYXRhKSB7XG5cdCAgICAgICAgICAgIGVsLmhvbGRlckRhdGEucmVzaXplVXBkYXRlID0gISF2YWx1ZTtcblx0ICAgICAgICAgICAgaWYgKGVsLmhvbGRlckRhdGEucmVzaXplVXBkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB1cGRhdGVSZXNpemFibGVFbGVtZW50cyhlbCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9LFxuXG5cdCAgICAvKipcblx0ICAgICAqIFJ1bnMgSG9sZGVyIHdpdGggb3B0aW9ucy4gQnkgZGVmYXVsdCBydW5zIEhvbGRlciBvbiBhbGwgaW1hZ2VzIHdpdGggXCJob2xkZXIuanNcIiBpbiB0aGVpciBzb3VyY2UgYXR0cmlidXRlcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gdXNlck9wdGlvbnMgT3B0aW9ucyBvYmplY3QsIGNhbiBjb250YWluIGRvbWFpbiwgdGhlbWVzLCBpbWFnZXMsIGFuZCBiZ25vZGVzIHByb3BlcnRpZXNcblx0ICAgICAqL1xuXHQgICAgcnVuOiBmdW5jdGlvbih1c2VyT3B0aW9ucykge1xuXHQgICAgICAgIC8vdG9kbzogc3BsaXQgcHJvY2Vzc2luZyBpbnRvIHNlcGFyYXRlIHF1ZXVlc1xuXHQgICAgICAgIHVzZXJPcHRpb25zID0gdXNlck9wdGlvbnMgfHwge307XG5cdCAgICAgICAgdmFyIGVuZ2luZVNldHRpbmdzID0ge307XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQoQXBwLnNldHRpbmdzLCB1c2VyT3B0aW9ucyk7XG5cblx0ICAgICAgICBBcHAudmFycy5wcmVlbXB0ZWQgPSB0cnVlO1xuXHQgICAgICAgIEFwcC52YXJzLmRhdGFBdHRyID0gb3B0aW9ucy5kYXRhQXR0ciB8fCBBcHAuc2V0dXAuZGF0YUF0dHI7XG5cblx0ICAgICAgICBlbmdpbmVTZXR0aW5ncy5yZW5kZXJlciA9IG9wdGlvbnMucmVuZGVyZXIgPyBvcHRpb25zLnJlbmRlcmVyIDogQXBwLnNldHVwLnJlbmRlcmVyO1xuXHQgICAgICAgIGlmIChBcHAuc2V0dXAucmVuZGVyZXJzLmpvaW4oJywnKS5pbmRleE9mKGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyKSA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgZW5naW5lU2V0dGluZ3MucmVuZGVyZXIgPSBBcHAuc2V0dXAuc3VwcG9ydHNTVkcgPyAnc3ZnJyA6IChBcHAuc2V0dXAuc3VwcG9ydHNDYW52YXMgPyAnY2FudmFzJyA6ICdodG1sJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGltYWdlcyA9IERPTS5nZXROb2RlQXJyYXkob3B0aW9ucy5pbWFnZXMpO1xuXHQgICAgICAgIHZhciBiZ25vZGVzID0gRE9NLmdldE5vZGVBcnJheShvcHRpb25zLmJnbm9kZXMpO1xuXHQgICAgICAgIHZhciBzdHlsZW5vZGVzID0gRE9NLmdldE5vZGVBcnJheShvcHRpb25zLnN0eWxlbm9kZXMpO1xuXHQgICAgICAgIHZhciBvYmplY3RzID0gRE9NLmdldE5vZGVBcnJheShvcHRpb25zLm9iamVjdHMpO1xuXG5cdCAgICAgICAgZW5naW5lU2V0dGluZ3Muc3R5bGVzaGVldHMgPSBbXTtcblx0ICAgICAgICBlbmdpbmVTZXR0aW5ncy5zdmdYTUxTdHlsZXNoZWV0ID0gdHJ1ZTtcblx0ICAgICAgICBlbmdpbmVTZXR0aW5ncy5ub0ZvbnRGYWxsYmFjayA9ICEhb3B0aW9ucy5ub0ZvbnRGYWxsYmFjaztcblx0ICAgICAgICBlbmdpbmVTZXR0aW5ncy5ub0JhY2tncm91bmRTaXplID0gISFvcHRpb25zLm5vQmFja2dyb3VuZFNpemU7XG5cblx0ICAgICAgICBzdHlsZW5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlTm9kZSkge1xuXHQgICAgICAgICAgICBpZiAoc3R5bGVOb2RlLmF0dHJpYnV0ZXMucmVsICYmIHN0eWxlTm9kZS5hdHRyaWJ1dGVzLmhyZWYgJiYgc3R5bGVOb2RlLmF0dHJpYnV0ZXMucmVsLnZhbHVlID09ICdzdHlsZXNoZWV0Jykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGhyZWYgPSBzdHlsZU5vZGUuYXR0cmlidXRlcy5ocmVmLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgLy90b2RvOiB3cml0ZSBpc29tb3JwaGljIHJlbGF0aXZlLXRvLWFic29sdXRlIFVSTCBmdW5jdGlvblxuXHQgICAgICAgICAgICAgICAgdmFyIHByb3h5TGluayA9IERPTS5uZXdFbCgnYScpO1xuXHQgICAgICAgICAgICAgICAgcHJveHlMaW5rLmhyZWYgPSBocmVmO1xuXHQgICAgICAgICAgICAgICAgdmFyIHN0eWxlc2hlZXRVUkwgPSBwcm94eUxpbmsucHJvdG9jb2wgKyAnLy8nICsgcHJveHlMaW5rLmhvc3QgKyBwcm94eUxpbmsucGF0aG5hbWUgKyBwcm94eUxpbmsuc2VhcmNoO1xuXHQgICAgICAgICAgICAgICAgZW5naW5lU2V0dGluZ3Muc3R5bGVzaGVldHMucHVzaChzdHlsZXNoZWV0VVJMKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgYmdub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChiZ05vZGUpIHtcblx0ICAgICAgICAgICAgLy9Ta2lwIHByb2Nlc3NpbmcgYmFja2dyb3VuZCBub2RlcyBpZiBnZXRDb21wdXRlZFN0eWxlIGlzIHVuYXZhaWxhYmxlLCBzaW5jZSBvbmx5IG1vZGVybiBicm93c2VycyB3b3VsZCBiZSBhYmxlIHRvIHVzZSBjYW52YXMgb3IgU1ZHIHRvIHJlbmRlciB0byBiYWNrZ3JvdW5kXG5cdCAgICAgICAgICAgIGlmICghZ2xvYmFsLmdldENvbXB1dGVkU3R5bGUpIHJldHVybjtcblx0ICAgICAgICAgICAgdmFyIGJhY2tncm91bmRJbWFnZSA9IGdsb2JhbC5nZXRDb21wdXRlZFN0eWxlKGJnTm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZSgnYmFja2dyb3VuZC1pbWFnZScpO1xuXHQgICAgICAgICAgICB2YXIgZGF0YUJhY2tncm91bmRJbWFnZSA9IGJnTm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtYmFja2dyb3VuZC1zcmMnKTtcblx0ICAgICAgICAgICAgdmFyIHJhd1VSTCA9IGRhdGFCYWNrZ3JvdW5kSW1hZ2UgfHwgYmFja2dyb3VuZEltYWdlO1xuXG5cdCAgICAgICAgICAgIHZhciBob2xkZXJVUkwgPSBudWxsO1xuXHQgICAgICAgICAgICB2YXIgaG9sZGVyU3RyaW5nID0gb3B0aW9ucy5kb21haW4gKyAnLyc7XG5cdCAgICAgICAgICAgIHZhciBob2xkZXJTdHJpbmdJbmRleCA9IHJhd1VSTC5pbmRleE9mKGhvbGRlclN0cmluZyk7XG5cblx0ICAgICAgICAgICAgaWYgKGhvbGRlclN0cmluZ0luZGV4ID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICBob2xkZXJVUkwgPSByYXdVUkw7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoaG9sZGVyU3RyaW5nSW5kZXggPT09IDEgJiYgcmF3VVJMWzBdID09PSAnPycpIHtcblx0ICAgICAgICAgICAgICAgIGhvbGRlclVSTCA9IHJhd1VSTC5zbGljZSgxKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHJhd1VSTC5zdWJzdHIoaG9sZGVyU3RyaW5nSW5kZXgpLm1hdGNoKC8oW15cXFwiXSopXCI/XFwpLyk7XG5cdCAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBob2xkZXJVUkwgPSBmcmFnbWVudFsxXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmF3VVJMLmluZGV4T2YoJ3VybCgnKSA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93ICdIb2xkZXI6IHVuYWJsZSB0byBwYXJzZSBiYWNrZ3JvdW5kIFVSTDogJyArIHJhd1VSTDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmIChob2xkZXJVUkwpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBob2xkZXJGbGFncyA9IHBhcnNlVVJMKGhvbGRlclVSTCwgb3B0aW9ucyk7XG5cdCAgICAgICAgICAgICAgICBpZiAoaG9sZGVyRmxhZ3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwcmVwYXJlRE9NRWxlbWVudCh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6ICdiYWNrZ3JvdW5kJyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWw6IGJnTm9kZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IGhvbGRlckZsYWdzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbmdpbmVTZXR0aW5nczogZW5naW5lU2V0dGluZ3Ncblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChvYmplY3QpIHtcblx0ICAgICAgICAgICAgdmFyIG9iamVjdEF0dHIgPSB7fTtcblxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgb2JqZWN0QXR0ci5kYXRhID0gb2JqZWN0LmdldEF0dHJpYnV0ZSgnZGF0YScpO1xuXHQgICAgICAgICAgICAgICAgb2JqZWN0QXR0ci5kYXRhU3JjID0gb2JqZWN0LmdldEF0dHJpYnV0ZShBcHAudmFycy5kYXRhQXR0cik7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cblx0ICAgICAgICAgICAgdmFyIG9iamVjdEhhc1NyY1VSTCA9IG9iamVjdEF0dHIuZGF0YSAhPSBudWxsICYmIG9iamVjdEF0dHIuZGF0YS5pbmRleE9mKG9wdGlvbnMuZG9tYWluKSA9PT0gMDtcblx0ICAgICAgICAgICAgdmFyIG9iamVjdEhhc0RhdGFTcmNVUkwgPSBvYmplY3RBdHRyLmRhdGFTcmMgIT0gbnVsbCAmJiBvYmplY3RBdHRyLmRhdGFTcmMuaW5kZXhPZihvcHRpb25zLmRvbWFpbikgPT09IDA7XG5cblx0ICAgICAgICAgICAgaWYgKG9iamVjdEhhc1NyY1VSTCkge1xuXHQgICAgICAgICAgICAgICAgcHJlcGFyZUltYWdlRWxlbWVudChvcHRpb25zLCBlbmdpbmVTZXR0aW5ncywgb2JqZWN0QXR0ci5kYXRhLCBvYmplY3QpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKG9iamVjdEhhc0RhdGFTcmNVUkwpIHtcblx0ICAgICAgICAgICAgICAgIHByZXBhcmVJbWFnZUVsZW1lbnQob3B0aW9ucywgZW5naW5lU2V0dGluZ3MsIG9iamVjdEF0dHIuZGF0YVNyYywgb2JqZWN0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgaW1hZ2VzLmZvckVhY2goZnVuY3Rpb24gKGltYWdlKSB7XG5cdCAgICAgICAgICAgIHZhciBpbWFnZUF0dHIgPSB7fTtcblxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaW1hZ2VBdHRyLnNyYyA9IGltYWdlLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG5cdCAgICAgICAgICAgICAgICBpbWFnZUF0dHIuZGF0YVNyYyA9IGltYWdlLmdldEF0dHJpYnV0ZShBcHAudmFycy5kYXRhQXR0cik7XG5cdCAgICAgICAgICAgICAgICBpbWFnZUF0dHIucmVuZGVyZWQgPSBpbWFnZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaG9sZGVyLXJlbmRlcmVkJyk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cblx0ICAgICAgICAgICAgdmFyIGltYWdlSGFzU3JjID0gaW1hZ2VBdHRyLnNyYyAhPSBudWxsO1xuXHQgICAgICAgICAgICB2YXIgaW1hZ2VIYXNEYXRhU3JjVVJMID0gaW1hZ2VBdHRyLmRhdGFTcmMgIT0gbnVsbCAmJiBpbWFnZUF0dHIuZGF0YVNyYy5pbmRleE9mKG9wdGlvbnMuZG9tYWluKSA9PT0gMDtcblx0ICAgICAgICAgICAgdmFyIGltYWdlUmVuZGVyZWQgPSBpbWFnZUF0dHIucmVuZGVyZWQgIT0gbnVsbCAmJiBpbWFnZUF0dHIucmVuZGVyZWQgPT0gJ3RydWUnO1xuXG5cdCAgICAgICAgICAgIGlmIChpbWFnZUhhc1NyYykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGltYWdlQXR0ci5zcmMuaW5kZXhPZihvcHRpb25zLmRvbWFpbikgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICBwcmVwYXJlSW1hZ2VFbGVtZW50KG9wdGlvbnMsIGVuZ2luZVNldHRpbmdzLCBpbWFnZUF0dHIuc3JjLCBpbWFnZSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGltYWdlSGFzRGF0YVNyY1VSTCkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vSW1hZ2UgaGFzIGEgdmFsaWQgZGF0YS1zcmMgYW5kIGFuIGludmFsaWQgc3JjXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlUmVuZGVyZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiB0aGUgcGxhY2Vob2xkZXIgaGFzIGFscmVhZHkgYmVlbiByZW5kZXIsIHJlLXJlbmRlciBpdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlSW1hZ2VFbGVtZW50KG9wdGlvbnMsIGVuZ2luZVNldHRpbmdzLCBpbWFnZUF0dHIuZGF0YVNyYywgaW1hZ2UpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgdGhlIHBsYWNlaG9sZGVyIGhhcyBub3QgYmVlbiByZW5kZXJlZCwgY2hlY2sgaWYgdGhlIGltYWdlIGV4aXN0cyBhbmQgcmVuZGVyIGEgZmFsbGJhY2sgaWYgaXQgZG9lc24ndFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24oc3JjLCBvcHRpb25zLCBlbmdpbmVTZXR0aW5ncywgZGF0YVNyYywgaW1hZ2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLmltYWdlRXhpc3RzKHNyYywgZnVuY3Rpb24oZXhpc3RzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlcGFyZUltYWdlRWxlbWVudChvcHRpb25zLCBlbmdpbmVTZXR0aW5ncywgZGF0YVNyYywgaW1hZ2UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KShpbWFnZUF0dHIuc3JjLCBvcHRpb25zLCBlbmdpbmVTZXR0aW5ncywgaW1hZ2VBdHRyLmRhdGFTcmMsIGltYWdlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoaW1hZ2VIYXNEYXRhU3JjVVJMKSB7XG5cdCAgICAgICAgICAgICAgICBwcmVwYXJlSW1hZ2VFbGVtZW50KG9wdGlvbnMsIGVuZ2luZVNldHRpbmdzLCBpbWFnZUF0dHIuZGF0YVNyYywgaW1hZ2UpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0fTtcblxuXHR2YXIgQXBwID0ge1xuXHQgICAgc2V0dGluZ3M6IHtcblx0ICAgICAgICBkb21haW46ICdob2xkZXIuanMnLFxuXHQgICAgICAgIGltYWdlczogJ2ltZycsXG5cdCAgICAgICAgb2JqZWN0czogJ29iamVjdCcsXG5cdCAgICAgICAgYmdub2RlczogJ2JvZHkgLmhvbGRlcmpzJyxcblx0ICAgICAgICBzdHlsZW5vZGVzOiAnaGVhZCBsaW5rLmhvbGRlcmpzJyxcblx0ICAgICAgICB0aGVtZXM6IHtcblx0ICAgICAgICAgICAgJ2dyYXknOiB7XG5cdCAgICAgICAgICAgICAgICBiZzogJyNFRUVFRUUnLFxuXHQgICAgICAgICAgICAgICAgZmc6ICcjQUFBQUFBJ1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnc29jaWFsJzoge1xuXHQgICAgICAgICAgICAgICAgYmc6ICcjM2E1YTk3Jyxcblx0ICAgICAgICAgICAgICAgIGZnOiAnI0ZGRkZGRidcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJ2luZHVzdHJpYWwnOiB7XG5cdCAgICAgICAgICAgICAgICBiZzogJyM0MzRBNTInLFxuXHQgICAgICAgICAgICAgICAgZmc6ICcjQzJGMjAwJ1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnc2t5Jzoge1xuXHQgICAgICAgICAgICAgICAgYmc6ICcjMEQ4RkRCJyxcblx0ICAgICAgICAgICAgICAgIGZnOiAnI0ZGRkZGRidcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgJ3ZpbmUnOiB7XG5cdCAgICAgICAgICAgICAgICBiZzogJyMzOURCQUMnLFxuXHQgICAgICAgICAgICAgICAgZmc6ICcjMUUyOTJDJ1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAnbGF2YSc6IHtcblx0ICAgICAgICAgICAgICAgIGJnOiAnI0Y4NTkxQScsXG5cdCAgICAgICAgICAgICAgICBmZzogJyMxQzI4NDYnXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9LFxuXHQgICAgZGVmYXVsdHM6IHtcblx0ICAgICAgICBzaXplOiAxMCxcblx0ICAgICAgICB1bml0czogJ3B0Jyxcblx0ICAgICAgICBzY2FsZTogMSAvIDE2XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFByb2Nlc3NlcyBwcm92aWRlZCBzb3VyY2UgYXR0cmlidXRlIGFuZCBzZXRzIHVwIHRoZSBhcHByb3ByaWF0ZSByZW5kZXJpbmcgd29ya2Zsb3dcblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIG9wdGlvbnMgSW5zdGFuY2Ugb3B0aW9ucyBmcm9tIEhvbGRlci5ydW5cblx0ICogQHBhcmFtIHJlbmRlclNldHRpbmdzIEluc3RhbmNlIGNvbmZpZ3VyYXRpb25cblx0ICogQHBhcmFtIHNyYyBJbWFnZSBVUkxcblx0ICogQHBhcmFtIGVsIEltYWdlIERPTSBlbGVtZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBwcmVwYXJlSW1hZ2VFbGVtZW50KG9wdGlvbnMsIGVuZ2luZVNldHRpbmdzLCBzcmMsIGVsKSB7XG5cdCAgICB2YXIgaG9sZGVyRmxhZ3MgPSBwYXJzZVVSTChzcmMuc3Vic3RyKHNyYy5sYXN0SW5kZXhPZihvcHRpb25zLmRvbWFpbikpLCBvcHRpb25zKTtcblx0ICAgIGlmIChob2xkZXJGbGFncykge1xuXHQgICAgICAgIHByZXBhcmVET01FbGVtZW50KHtcblx0ICAgICAgICAgICAgbW9kZTogbnVsbCxcblx0ICAgICAgICAgICAgZWw6IGVsLFxuXHQgICAgICAgICAgICBmbGFnczogaG9sZGVyRmxhZ3MsXG5cdCAgICAgICAgICAgIGVuZ2luZVNldHRpbmdzOiBlbmdpbmVTZXR0aW5nc1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFByb2Nlc3NlcyBhIEhvbGRlciBVUkwgYW5kIGV4dHJhY3RzIGNvbmZpZ3VyYXRpb24gZnJvbSBxdWVyeSBzdHJpbmdcblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHVybCBVUkxcblx0ICogQHBhcmFtIGluc3RhbmNlT3B0aW9ucyBJbnN0YW5jZSBvcHRpb25zIGZyb20gSG9sZGVyLnJ1blxuXHQgKi9cblx0ZnVuY3Rpb24gcGFyc2VVUkwodXJsLCBpbnN0YW5jZU9wdGlvbnMpIHtcblx0ICAgIHZhciBob2xkZXIgPSB7XG5cdCAgICAgICAgdGhlbWU6IGV4dGVuZChBcHAuc2V0dGluZ3MudGhlbWVzLmdyYXksIG51bGwpLFxuXHQgICAgICAgIHN0eWxlc2hlZXRzOiBpbnN0YW5jZU9wdGlvbnMuc3R5bGVzaGVldHMsXG5cdCAgICAgICAgaW5zdGFuY2VPcHRpb25zOiBpbnN0YW5jZU9wdGlvbnNcblx0ICAgIH07XG5cblx0ICAgIHZhciBmaXJzdFF1ZXN0aW9uTWFyayA9IHVybC5pbmRleE9mKCc/Jyk7XG5cdCAgICB2YXIgcGFydHMgPSBbdXJsXTtcblxuXHQgICAgaWYgKGZpcnN0UXVlc3Rpb25NYXJrICE9PSAtMSkge1xuXHQgICAgICAgIHBhcnRzID0gW3VybC5zbGljZSgwLCBmaXJzdFF1ZXN0aW9uTWFyayksIHVybC5zbGljZShmaXJzdFF1ZXN0aW9uTWFyayArIDEpXTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGJhc2ljcyA9IHBhcnRzWzBdLnNwbGl0KCcvJyk7XG5cblx0ICAgIGhvbGRlci5ob2xkZXJVUkwgPSB1cmw7XG5cblx0ICAgIHZhciBkaW1lbnNpb25zID0gYmFzaWNzWzFdO1xuXHQgICAgdmFyIGRpbWVuc2lvbkRhdGEgPSBkaW1lbnNpb25zLm1hdGNoKC8oW1xcZF0rcD8peChbXFxkXStwPykvKTtcblxuXHQgICAgaWYgKCFkaW1lbnNpb25EYXRhKSByZXR1cm4gZmFsc2U7XG5cblx0ICAgIGhvbGRlci5mbHVpZCA9IGRpbWVuc2lvbnMuaW5kZXhPZigncCcpICE9PSAtMTtcblxuXHQgICAgaG9sZGVyLmRpbWVuc2lvbnMgPSB7XG5cdCAgICAgICAgd2lkdGg6IGRpbWVuc2lvbkRhdGFbMV0ucmVwbGFjZSgncCcsICclJyksXG5cdCAgICAgICAgaGVpZ2h0OiBkaW1lbnNpb25EYXRhWzJdLnJlcGxhY2UoJ3AnLCAnJScpXG5cdCAgICB9O1xuXG5cdCAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBxdWVyeXN0cmluZy5wYXJzZShwYXJ0c1sxXSk7XG5cblx0ICAgICAgICAvLyBEaW1lbnNpb25zXG5cblx0ICAgICAgICBpZiAodXRpbHMudHJ1dGh5KG9wdGlvbnMucmF0aW8pKSB7XG5cdCAgICAgICAgICAgIGhvbGRlci5mbHVpZCA9IHRydWU7XG5cdCAgICAgICAgICAgIHZhciByYXRpb1dpZHRoID0gcGFyc2VGbG9hdChob2xkZXIuZGltZW5zaW9ucy53aWR0aC5yZXBsYWNlKCclJywgJycpKTtcblx0ICAgICAgICAgICAgdmFyIHJhdGlvSGVpZ2h0ID0gcGFyc2VGbG9hdChob2xkZXIuZGltZW5zaW9ucy5oZWlnaHQucmVwbGFjZSgnJScsICcnKSk7XG5cblx0ICAgICAgICAgICAgcmF0aW9IZWlnaHQgPSBNYXRoLmZsb29yKDEwMCAqIChyYXRpb0hlaWdodCAvIHJhdGlvV2lkdGgpKTtcblx0ICAgICAgICAgICAgcmF0aW9XaWR0aCA9IDEwMDtcblxuXHQgICAgICAgICAgICBob2xkZXIuZGltZW5zaW9ucy53aWR0aCA9IHJhdGlvV2lkdGggKyAnJSc7XG5cdCAgICAgICAgICAgIGhvbGRlci5kaW1lbnNpb25zLmhlaWdodCA9IHJhdGlvSGVpZ2h0ICsgJyUnO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGhvbGRlci5hdXRvID0gdXRpbHMudHJ1dGh5KG9wdGlvbnMuYXV0byk7XG5cblx0ICAgICAgICAvLyBDb2xvcnNcblxuXHQgICAgICAgIGlmIChvcHRpb25zLmJnKSB7XG5cdCAgICAgICAgICAgIGhvbGRlci50aGVtZS5iZyA9IHV0aWxzLnBhcnNlQ29sb3Iob3B0aW9ucy5iZyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKG9wdGlvbnMuZmcpIHtcblx0ICAgICAgICAgICAgaG9sZGVyLnRoZW1lLmZnID0gdXRpbHMucGFyc2VDb2xvcihvcHRpb25zLmZnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvL3RvZG86IGFkZCBhdXRvbWF0aWMgZm9yZWdyb3VuZCB0byB0aGVtZXMgd2l0aG91dCBmb3JlZ3JvdW5kXG5cdCAgICAgICAgaWYgKG9wdGlvbnMuYmcgJiYgIW9wdGlvbnMuZmcpIHtcblx0ICAgICAgICAgICAgaG9sZGVyLmF1dG9GZyA9IHRydWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKG9wdGlvbnMudGhlbWUgJiYgaG9sZGVyLmluc3RhbmNlT3B0aW9ucy50aGVtZXMuaGFzT3duUHJvcGVydHkob3B0aW9ucy50aGVtZSkpIHtcblx0ICAgICAgICAgICAgaG9sZGVyLnRoZW1lID0gZXh0ZW5kKGhvbGRlci5pbnN0YW5jZU9wdGlvbnMudGhlbWVzW29wdGlvbnMudGhlbWVdLCBudWxsKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBUZXh0XG5cblx0ICAgICAgICBpZiAob3B0aW9ucy50ZXh0KSB7XG5cdCAgICAgICAgICAgIGhvbGRlci50ZXh0ID0gb3B0aW9ucy50ZXh0O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChvcHRpb25zLnRleHRtb2RlKSB7XG5cdCAgICAgICAgICAgIGhvbGRlci50ZXh0bW9kZSA9IG9wdGlvbnMudGV4dG1vZGU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKG9wdGlvbnMuc2l6ZSkge1xuXHQgICAgICAgICAgICBob2xkZXIuc2l6ZSA9IG9wdGlvbnMuc2l6ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAob3B0aW9ucy5mb250KSB7XG5cdCAgICAgICAgICAgIGhvbGRlci5mb250ID0gb3B0aW9ucy5mb250O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChvcHRpb25zLmFsaWduKSB7XG5cdCAgICAgICAgICAgIGhvbGRlci5hbGlnbiA9IG9wdGlvbnMuYWxpZ247XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKG9wdGlvbnMubGluZVdyYXApIHtcblx0ICAgICAgICAgICAgaG9sZGVyLmxpbmVXcmFwID0gb3B0aW9ucy5saW5lV3JhcDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBob2xkZXIubm93cmFwID0gdXRpbHMudHJ1dGh5KG9wdGlvbnMubm93cmFwKTtcblxuXHQgICAgICAgIC8vIE1pc2NlbGxhbmVvdXNcblxuXHQgICAgICAgIGhvbGRlci5vdXRsaW5lID0gdXRpbHMudHJ1dGh5KG9wdGlvbnMub3V0bGluZSk7XG5cblx0ICAgICAgICBpZiAodXRpbHMudHJ1dGh5KG9wdGlvbnMucmFuZG9tKSkge1xuXHQgICAgICAgICAgICBBcHAudmFycy5jYWNoZS50aGVtZUtleXMgPSBBcHAudmFycy5jYWNoZS50aGVtZUtleXMgfHwgT2JqZWN0LmtleXMoaG9sZGVyLmluc3RhbmNlT3B0aW9ucy50aGVtZXMpO1xuXHQgICAgICAgICAgICB2YXIgX3RoZW1lID0gQXBwLnZhcnMuY2FjaGUudGhlbWVLZXlzWzAgfCBNYXRoLnJhbmRvbSgpICogQXBwLnZhcnMuY2FjaGUudGhlbWVLZXlzLmxlbmd0aF07XG5cdCAgICAgICAgICAgIGhvbGRlci50aGVtZSA9IGV4dGVuZChob2xkZXIuaW5zdGFuY2VPcHRpb25zLnRoZW1lc1tfdGhlbWVdLCBudWxsKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBob2xkZXI7XG5cdH1cblxuXHQvKipcblx0ICogTW9kaWZpZXMgdGhlIERPTSB0byBmaXQgcGxhY2Vob2xkZXJzIGFuZCBzZXRzIHVwIHJlc2l6YWJsZSBpbWFnZSBjYWxsYmFja3MgKGZvciBmbHVpZCBhbmQgYXV0b21hdGljYWxseSBzaXplZCBwbGFjZWhvbGRlcnMpXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSBzZXR0aW5ncyBET00gcHJlcCBzZXR0aW5nc1xuXHQgKi9cblx0ZnVuY3Rpb24gcHJlcGFyZURPTUVsZW1lbnQocHJlcFNldHRpbmdzKSB7XG5cdCAgICB2YXIgbW9kZSA9IHByZXBTZXR0aW5ncy5tb2RlO1xuXHQgICAgdmFyIGVsID0gcHJlcFNldHRpbmdzLmVsO1xuXHQgICAgdmFyIGZsYWdzID0gcHJlcFNldHRpbmdzLmZsYWdzO1xuXHQgICAgdmFyIF9lbmdpbmVTZXR0aW5ncyA9IHByZXBTZXR0aW5ncy5lbmdpbmVTZXR0aW5ncztcblx0ICAgIHZhciBkaW1lbnNpb25zID0gZmxhZ3MuZGltZW5zaW9ucyxcblx0ICAgICAgICB0aGVtZSA9IGZsYWdzLnRoZW1lO1xuXHQgICAgdmFyIGRpbWVuc2lvbnNDYXB0aW9uID0gZGltZW5zaW9ucy53aWR0aCArICd4JyArIGRpbWVuc2lvbnMuaGVpZ2h0O1xuXHQgICAgbW9kZSA9IG1vZGUgPT0gbnVsbCA/IChmbGFncy5mbHVpZCA/ICdmbHVpZCcgOiAnaW1hZ2UnKSA6IG1vZGU7XG5cdCAgICB2YXIgaG9sZGVyVGVtcGxhdGVSZSA9IC9ob2xkZXJfKFthLXpdKykvZztcblx0ICAgIHZhciBkaW1lbnNpb25zSW5UZXh0ID0gZmFsc2U7XG5cblx0ICAgIGlmIChmbGFncy50ZXh0ICE9IG51bGwpIHtcblx0ICAgICAgICB0aGVtZS50ZXh0ID0gZmxhZ3MudGV4dDtcblxuXHQgICAgICAgIC8vPG9iamVjdD4gU1ZHIGVtYmVkZGluZyBkb2Vzbid0IHBhcnNlIFVuaWNvZGUgcHJvcGVybHlcblx0ICAgICAgICBpZiAoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgICAgICAgdmFyIHRleHRMaW5lcyA9IHRoZW1lLnRleHQuc3BsaXQoJ1xcXFxuJyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGV4dExpbmVzLmxlbmd0aDsgaysrKSB7XG5cdCAgICAgICAgICAgICAgICB0ZXh0TGluZXNba10gPSB1dGlscy5lbmNvZGVIdG1sRW50aXR5KHRleHRMaW5lc1trXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhlbWUudGV4dCA9IHRleHRMaW5lcy5qb2luKCdcXFxcbicpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHRoZW1lLnRleHQpIHtcblx0ICAgICAgICB2YXIgaG9sZGVyVGVtcGxhdGVNYXRjaGVzID0gdGhlbWUudGV4dC5tYXRjaChob2xkZXJUZW1wbGF0ZVJlKTtcblxuXHQgICAgICAgIGlmIChob2xkZXJUZW1wbGF0ZU1hdGNoZXMgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgLy90b2RvOiBvcHRpbWl6ZSB0ZW1wbGF0ZSByZXBsYWNlbWVudFxuXHQgICAgICAgICAgICBob2xkZXJUZW1wbGF0ZU1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAobWF0Y2gpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gJ2hvbGRlcl9kaW1lbnNpb25zJykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoZW1lLnRleHQgPSB0aGVtZS50ZXh0LnJlcGxhY2UobWF0Y2gsIGRpbWVuc2lvbnNDYXB0aW9uKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgaG9sZGVyVVJMID0gZmxhZ3MuaG9sZGVyVVJMO1xuXHQgICAgdmFyIGVuZ2luZVNldHRpbmdzID0gZXh0ZW5kKF9lbmdpbmVTZXR0aW5ncywgbnVsbCk7XG5cblx0ICAgIGlmIChmbGFncy5mb250KSB7XG5cdCAgICAgICAgLypcblx0ICAgICAgICBJZiBleHRlcm5hbCBmb250cyBhcmUgdXNlZCBpbiBhIDxpbWc+IHBsYWNlaG9sZGVyIHJlbmRlcmVkIHdpdGggU1ZHLCBIb2xkZXIgZmFsbHMgYmFjayB0byBjYW52YXMuXG5cblx0ICAgICAgICBUaGlzIGlzIGRvbmUgYmVjYXVzZSBGaXJlZm94IGFuZCBDaHJvbWUgZGlzYWxsb3cgZW1iZWRkZWQgU1ZHcyBmcm9tIHJlZmVyZW5jaW5nIGV4dGVybmFsIGFzc2V0cy5cblx0ICAgICAgICBUaGUgd29ya2Fyb3VuZCBpcyBlaXRoZXIgdG8gY2hhbmdlIHRoZSBwbGFjZWhvbGRlciB0YWcgZnJvbSA8aW1nPiB0byA8b2JqZWN0PiBvciB0byB1c2UgdGhlIGNhbnZhcyByZW5kZXJlci5cblx0ICAgICAgICAqL1xuXHQgICAgICAgIHRoZW1lLmZvbnQgPSBmbGFncy5mb250O1xuXHQgICAgICAgIGlmICghZW5naW5lU2V0dGluZ3Mubm9Gb250RmFsbGJhY2sgJiYgZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycgJiYgQXBwLnNldHVwLnN1cHBvcnRzQ2FudmFzICYmIGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyID09PSAnc3ZnJykge1xuXHQgICAgICAgICAgICBlbmdpbmVTZXR0aW5ncyA9IGV4dGVuZChlbmdpbmVTZXR0aW5ncywge1xuXHQgICAgICAgICAgICAgICAgcmVuZGVyZXI6ICdjYW52YXMnXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy9DaHJvbWUgYW5kIE9wZXJhIHJlcXVpcmUgYSBxdWljayAxMG1zIHJlLXJlbmRlciBpZiB3ZWIgZm9udHMgYXJlIHVzZWQgd2l0aCBjYW52YXNcblx0ICAgIGlmIChmbGFncy5mb250ICYmIGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyID09ICdjYW52YXMnKSB7XG5cdCAgICAgICAgZW5naW5lU2V0dGluZ3MucmVSZW5kZXIgPSB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobW9kZSA9PSAnYmFja2dyb3VuZCcpIHtcblx0ICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWJhY2tncm91bmQtc3JjJykgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBET00uc2V0QXR0cihlbCwge1xuXHQgICAgICAgICAgICAgICAgJ2RhdGEtYmFja2dyb3VuZC1zcmMnOiBob2xkZXJVUkxcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICB2YXIgZG9tUHJvcHMgPSB7fTtcblx0ICAgICAgICBkb21Qcm9wc1tBcHAudmFycy5kYXRhQXR0cl0gPSBob2xkZXJVUkw7XG5cdCAgICAgICAgRE9NLnNldEF0dHIoZWwsIGRvbVByb3BzKTtcblx0ICAgIH1cblxuXHQgICAgZmxhZ3MudGhlbWUgPSB0aGVtZTtcblxuXHQgICAgLy90b2RvIGNvbnNpZGVyIHVzaW5nIGFsbCByZW5kZXJTZXR0aW5ncyBpbiBob2xkZXJEYXRhXG5cdCAgICBlbC5ob2xkZXJEYXRhID0ge1xuXHQgICAgICAgIGZsYWdzOiBmbGFncyxcblx0ICAgICAgICBlbmdpbmVTZXR0aW5nczogZW5naW5lU2V0dGluZ3Ncblx0ICAgIH07XG5cblx0ICAgIGlmIChtb2RlID09ICdpbWFnZScgfHwgbW9kZSA9PSAnZmx1aWQnKSB7XG5cdCAgICAgICAgRE9NLnNldEF0dHIoZWwsIHtcblx0ICAgICAgICAgICAgJ2FsdCc6IHRoZW1lLnRleHQgPyAoZGltZW5zaW9uc0luVGV4dCA/IHRoZW1lLnRleHQgOiB0aGVtZS50ZXh0ICsgJyBbJyArIGRpbWVuc2lvbnNDYXB0aW9uICsgJ10nKSA6IGRpbWVuc2lvbnNDYXB0aW9uXG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciByZW5kZXJTZXR0aW5ncyA9IHtcblx0ICAgICAgICBtb2RlOiBtb2RlLFxuXHQgICAgICAgIGVsOiBlbCxcblx0ICAgICAgICBob2xkZXJTZXR0aW5nczoge1xuXHQgICAgICAgICAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zLFxuXHQgICAgICAgICAgICB0aGVtZTogdGhlbWUsXG5cdCAgICAgICAgICAgIGZsYWdzOiBmbGFnc1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZW5naW5lU2V0dGluZ3M6IGVuZ2luZVNldHRpbmdzXG5cdCAgICB9O1xuXG5cdCAgICBpZiAobW9kZSA9PSAnaW1hZ2UnKSB7XG5cdCAgICAgICAgaWYgKCFmbGFncy5hdXRvKSB7XG5cdCAgICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gZGltZW5zaW9ucy53aWR0aCArICdweCc7XG5cdCAgICAgICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0ICsgJ3B4Jztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoZW5naW5lU2V0dGluZ3MucmVuZGVyZXIgPT0gJ2h0bWwnKSB7XG5cdCAgICAgICAgICAgIGVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoZW1lLmJnO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJlbmRlcihyZW5kZXJTZXR0aW5ncyk7XG5cblx0ICAgICAgICAgICAgaWYgKGZsYWdzLnRleHRtb2RlID09ICdleGFjdCcpIHtcblx0ICAgICAgICAgICAgICAgIGVsLmhvbGRlckRhdGEucmVzaXplVXBkYXRlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIEFwcC52YXJzLnJlc2l6YWJsZUltYWdlcy5wdXNoKGVsKTtcblx0ICAgICAgICAgICAgICAgIHVwZGF0ZVJlc2l6YWJsZUVsZW1lbnRzKGVsKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAobW9kZSA9PSAnYmFja2dyb3VuZCcgJiYgZW5naW5lU2V0dGluZ3MucmVuZGVyZXIgIT0gJ2h0bWwnKSB7XG5cdCAgICAgICAgcmVuZGVyKHJlbmRlclNldHRpbmdzKTtcblx0ICAgIH0gZWxzZSBpZiAobW9kZSA9PSAnZmx1aWQnKSB7XG5cdCAgICAgICAgZWwuaG9sZGVyRGF0YS5yZXNpemVVcGRhdGUgPSB0cnVlO1xuXG5cdCAgICAgICAgaWYgKGRpbWVuc2lvbnMuaGVpZ2h0LnNsaWNlKC0xKSA9PSAnJScpIHtcblx0ICAgICAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQ7XG5cdCAgICAgICAgfSBlbHNlIGlmIChmbGFncy5hdXRvID09IG51bGwgfHwgIWZsYWdzLmF1dG8pIHtcblx0ICAgICAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQgKyAncHgnO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZGltZW5zaW9ucy53aWR0aC5zbGljZSgtMSkgPT0gJyUnKSB7XG5cdCAgICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcblx0ICAgICAgICB9IGVsc2UgaWYgKGZsYWdzLmF1dG8gPT0gbnVsbCB8fCAhZmxhZ3MuYXV0bykge1xuXHQgICAgICAgICAgICBlbC5zdHlsZS53aWR0aCA9IGRpbWVuc2lvbnMud2lkdGggKyAncHgnO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZWwuc3R5bGUuZGlzcGxheSA9PSAnaW5saW5lJyB8fCBlbC5zdHlsZS5kaXNwbGF5ID09PSAnJyB8fCBlbC5zdHlsZS5kaXNwbGF5ID09ICdub25lJykge1xuXHQgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBzZXRJbml0aWFsRGltZW5zaW9ucyhlbCk7XG5cblx0ICAgICAgICBpZiAoZW5naW5lU2V0dGluZ3MucmVuZGVyZXIgPT0gJ2h0bWwnKSB7XG5cdCAgICAgICAgICAgIGVsLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoZW1lLmJnO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIEFwcC52YXJzLnJlc2l6YWJsZUltYWdlcy5wdXNoKGVsKTtcblx0ICAgICAgICAgICAgdXBkYXRlUmVzaXphYmxlRWxlbWVudHMoZWwpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDb3JlIGZ1bmN0aW9uIHRoYXQgdGFrZXMgb3V0cHV0IGZyb20gcmVuZGVyZXJzIGFuZCBzZXRzIGl0IGFzIHRoZSBzb3VyY2Ugb3IgYmFja2dyb3VuZC1pbWFnZSBvZiB0aGUgdGFyZ2V0IGVsZW1lbnRcblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHJlbmRlclNldHRpbmdzIFJlbmRlcmVyIHNldHRpbmdzXG5cdCAqL1xuXHRmdW5jdGlvbiByZW5kZXIocmVuZGVyU2V0dGluZ3MpIHtcblx0ICAgIHZhciBpbWFnZSA9IG51bGw7XG5cdCAgICB2YXIgbW9kZSA9IHJlbmRlclNldHRpbmdzLm1vZGU7XG5cdCAgICB2YXIgZWwgPSByZW5kZXJTZXR0aW5ncy5lbDtcblx0ICAgIHZhciBob2xkZXJTZXR0aW5ncyA9IHJlbmRlclNldHRpbmdzLmhvbGRlclNldHRpbmdzO1xuXHQgICAgdmFyIGVuZ2luZVNldHRpbmdzID0gcmVuZGVyU2V0dGluZ3MuZW5naW5lU2V0dGluZ3M7XG5cblx0ICAgIHN3aXRjaCAoZW5naW5lU2V0dGluZ3MucmVuZGVyZXIpIHtcblx0ICAgICAgICBjYXNlICdzdmcnOlxuXHQgICAgICAgICAgICBpZiAoIUFwcC5zZXR1cC5zdXBwb3J0c1NWRykgcmV0dXJuO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlICdjYW52YXMnOlxuXHQgICAgICAgICAgICBpZiAoIUFwcC5zZXR1cC5zdXBwb3J0c0NhbnZhcykgcmV0dXJuO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIC8vdG9kbzogbW92ZSBnZW5lcmF0aW9uIG9mIHNjZW5lIHVwIHRvIGZsYWcgZ2VuZXJhdGlvbiB0byByZWR1Y2UgZXh0cmEgb2JqZWN0IGNyZWF0aW9uXG5cdCAgICB2YXIgc2NlbmUgPSB7XG5cdCAgICAgICAgd2lkdGg6IGhvbGRlclNldHRpbmdzLmRpbWVuc2lvbnMud2lkdGgsXG5cdCAgICAgICAgaGVpZ2h0OiBob2xkZXJTZXR0aW5ncy5kaW1lbnNpb25zLmhlaWdodCxcblx0ICAgICAgICB0aGVtZTogaG9sZGVyU2V0dGluZ3MudGhlbWUsXG5cdCAgICAgICAgZmxhZ3M6IGhvbGRlclNldHRpbmdzLmZsYWdzXG5cdCAgICB9O1xuXG5cdCAgICB2YXIgc2NlbmVHcmFwaCA9IGJ1aWxkU2NlbmVHcmFwaChzY2VuZSk7XG5cblx0ICAgIGZ1bmN0aW9uIGdldFJlbmRlcmVkSW1hZ2UoKSB7XG5cdCAgICAgICAgdmFyIGltYWdlID0gbnVsbDtcblx0ICAgICAgICBzd2l0Y2ggKGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyKSB7XG5cdCAgICAgICAgICAgIGNhc2UgJ2NhbnZhcyc6XG5cdCAgICAgICAgICAgICAgICBpbWFnZSA9IHNnQ2FudmFzUmVuZGVyZXIoc2NlbmVHcmFwaCwgcmVuZGVyU2V0dGluZ3MpO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgJ3N2Zyc6XG5cdCAgICAgICAgICAgICAgICBpbWFnZSA9IHN2Z1JlbmRlcmVyKHNjZW5lR3JhcGgsIHJlbmRlclNldHRpbmdzKTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgdGhyb3cgJ0hvbGRlcjogaW52YWxpZCByZW5kZXJlcjogJyArIGVuZ2luZVNldHRpbmdzLnJlbmRlcmVyO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBpbWFnZTtcblx0ICAgIH1cblxuXHQgICAgaW1hZ2UgPSBnZXRSZW5kZXJlZEltYWdlKCk7XG5cblx0ICAgIGlmIChpbWFnZSA9PSBudWxsKSB7XG5cdCAgICAgICAgdGhyb3cgJ0hvbGRlcjogY291bGRuXFwndCByZW5kZXIgcGxhY2Vob2xkZXInO1xuXHQgICAgfVxuXG5cdCAgICAvL3RvZG86IGFkZCA8b2JqZWN0PiBjYW52YXMgcmVuZGVyaW5nXG5cdCAgICBpZiAobW9kZSA9PSAnYmFja2dyb3VuZCcpIHtcblx0ICAgICAgICBlbC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKCcgKyBpbWFnZSArICcpJztcblxuXHQgICAgICAgIGlmICghZW5naW5lU2V0dGluZ3Mubm9CYWNrZ3JvdW5kU2l6ZSkge1xuXHQgICAgICAgICAgICBlbC5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IHNjZW5lLndpZHRoICsgJ3B4ICcgKyBzY2VuZS5oZWlnaHQgKyAncHgnO1xuXHQgICAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbWcnKSB7XG5cdCAgICAgICAgICAgIERPTS5zZXRBdHRyKGVsLCB7XG5cdCAgICAgICAgICAgICAgICAnc3JjJzogaW1hZ2Vcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSBlbHNlIGlmIChlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb2JqZWN0Jykge1xuXHQgICAgICAgICAgICBET00uc2V0QXR0cihlbCwge1xuXHQgICAgICAgICAgICAgICAgJ2RhdGEnOiBpbWFnZSxcblx0ICAgICAgICAgICAgICAgICd0eXBlJzogJ2ltYWdlL3N2Zyt4bWwnXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZW5naW5lU2V0dGluZ3MucmVSZW5kZXIpIHtcblx0ICAgICAgICAgICAgZ2xvYmFsLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGltYWdlID0gZ2V0UmVuZGVyZWRJbWFnZSgpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGltYWdlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyAnSG9sZGVyOiBjb3VsZG5cXCd0IHJlbmRlciBwbGFjZWhvbGRlcic7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvL3RvZG86IHJlZmFjdG9yIHRoaXMgY29kZSBpbnRvIGEgZnVuY3Rpb25cblx0ICAgICAgICAgICAgICAgIGlmIChlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW1nJykge1xuXHQgICAgICAgICAgICAgICAgICAgIERPTS5zZXRBdHRyKGVsLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICdzcmMnOiBpbWFnZVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb2JqZWN0Jykge1xuXHQgICAgICAgICAgICAgICAgICAgIERPTS5zZXRBdHRyKGVsLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhJzogaW1hZ2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2ltYWdlL3N2Zyt4bWwnXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sIDE1MCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgLy90b2RvOiBhY2NvdW50IGZvciByZS1yZW5kZXJpbmdcblx0ICAgIERPTS5zZXRBdHRyKGVsLCB7XG5cdCAgICAgICAgJ2RhdGEtaG9sZGVyLXJlbmRlcmVkJzogdHJ1ZVxuXHQgICAgfSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29yZSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgSG9sZGVyIHNjZW5lIGRlc2NyaXB0aW9uIGFuZCBidWlsZHMgYSBzY2VuZSBncmFwaFxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0gc2NlbmUgSG9sZGVyIHNjZW5lIG9iamVjdFxuXHQgKi9cblx0Ly90b2RvOiBtYWtlIHRoaXMgZnVuY3Rpb24gcmV1c2FibGVcblx0Ly90b2RvOiBtZXJnZSBhcHAgZGVmYXVsdHMgYW5kIHNldHVwIHByb3BlcnRpZXMgaW50byB0aGUgc2NlbmUgYXJndW1lbnRcblx0ZnVuY3Rpb24gYnVpbGRTY2VuZUdyYXBoKHNjZW5lKSB7XG5cdCAgICB2YXIgZm9udFNpemUgPSBBcHAuZGVmYXVsdHMuc2l6ZTtcblx0ICAgIGlmIChwYXJzZUZsb2F0KHNjZW5lLnRoZW1lLnNpemUpKSB7XG5cdCAgICAgICAgZm9udFNpemUgPSBzY2VuZS50aGVtZS5zaXplO1xuXHQgICAgfSBlbHNlIGlmIChwYXJzZUZsb2F0KHNjZW5lLmZsYWdzLnNpemUpKSB7XG5cdCAgICAgICAgZm9udFNpemUgPSBzY2VuZS5mbGFncy5zaXplO1xuXHQgICAgfVxuXG5cdCAgICBzY2VuZS5mb250ID0ge1xuXHQgICAgICAgIGZhbWlseTogc2NlbmUudGhlbWUuZm9udCA/IHNjZW5lLnRoZW1lLmZvbnQgOiAnQXJpYWwsIEhlbHZldGljYSwgT3BlbiBTYW5zLCBzYW5zLXNlcmlmJyxcblx0ICAgICAgICBzaXplOiB0ZXh0U2l6ZShzY2VuZS53aWR0aCwgc2NlbmUuaGVpZ2h0LCBmb250U2l6ZSwgQXBwLmRlZmF1bHRzLnNjYWxlKSxcblx0ICAgICAgICB1bml0czogc2NlbmUudGhlbWUudW5pdHMgPyBzY2VuZS50aGVtZS51bml0cyA6IEFwcC5kZWZhdWx0cy51bml0cyxcblx0ICAgICAgICB3ZWlnaHQ6IHNjZW5lLnRoZW1lLmZvbnR3ZWlnaHQgPyBzY2VuZS50aGVtZS5mb250d2VpZ2h0IDogJ2JvbGQnXG5cdCAgICB9O1xuXG5cdCAgICBzY2VuZS50ZXh0ID0gc2NlbmUudGhlbWUudGV4dCB8fCBNYXRoLmZsb29yKHNjZW5lLndpZHRoKSArICd4JyArIE1hdGguZmxvb3Ioc2NlbmUuaGVpZ2h0KTtcblxuXHQgICAgc2NlbmUubm9XcmFwID0gc2NlbmUudGhlbWUubm93cmFwIHx8IHNjZW5lLmZsYWdzLm5vd3JhcDtcblxuXHQgICAgc2NlbmUuYWxpZ24gPSBzY2VuZS50aGVtZS5hbGlnbiB8fCBzY2VuZS5mbGFncy5hbGlnbiB8fCAnY2VudGVyJztcblxuXHQgICAgc3dpdGNoIChzY2VuZS5mbGFncy50ZXh0bW9kZSkge1xuXHQgICAgICAgIGNhc2UgJ2xpdGVyYWwnOlxuXHQgICAgICAgICAgICBzY2VuZS50ZXh0ID0gc2NlbmUuZmxhZ3MuZGltZW5zaW9ucy53aWR0aCArICd4JyArIHNjZW5lLmZsYWdzLmRpbWVuc2lvbnMuaGVpZ2h0O1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICBjYXNlICdleGFjdCc6XG5cdCAgICAgICAgICAgIGlmICghc2NlbmUuZmxhZ3MuZXhhY3REaW1lbnNpb25zKSBicmVhaztcblx0ICAgICAgICAgICAgc2NlbmUudGV4dCA9IE1hdGguZmxvb3Ioc2NlbmUuZmxhZ3MuZXhhY3REaW1lbnNpb25zLndpZHRoKSArICd4JyArIE1hdGguZmxvb3Ioc2NlbmUuZmxhZ3MuZXhhY3REaW1lbnNpb25zLmhlaWdodCk7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgbGluZVdyYXAgPSBzY2VuZS5mbGFncy5saW5lV3JhcCB8fCBBcHAuc2V0dXAubGluZVdyYXBSYXRpbztcblx0ICAgIHZhciBzY2VuZU1hcmdpbiA9IHNjZW5lLndpZHRoICogbGluZVdyYXA7XG5cdCAgICB2YXIgbWF4TGluZVdpZHRoID0gc2NlbmVNYXJnaW47XG5cblx0ICAgIHZhciBzY2VuZUdyYXBoID0gbmV3IFNjZW5lR3JhcGgoe1xuXHQgICAgICAgIHdpZHRoOiBzY2VuZS53aWR0aCxcblx0ICAgICAgICBoZWlnaHQ6IHNjZW5lLmhlaWdodFxuXHQgICAgfSk7XG5cblx0ICAgIHZhciBTaGFwZSA9IHNjZW5lR3JhcGguU2hhcGU7XG5cblx0ICAgIHZhciBob2xkZXJCZyA9IG5ldyBTaGFwZS5SZWN0KCdob2xkZXJCZycsIHtcblx0ICAgICAgICBmaWxsOiBzY2VuZS50aGVtZS5iZ1xuXHQgICAgfSk7XG5cblx0ICAgIGhvbGRlckJnLnJlc2l6ZShzY2VuZS53aWR0aCwgc2NlbmUuaGVpZ2h0KTtcblx0ICAgIHNjZW5lR3JhcGgucm9vdC5hZGQoaG9sZGVyQmcpO1xuXG5cdCAgICBpZiAoc2NlbmUuZmxhZ3Mub3V0bGluZSkge1xuXHQgICAgICAgIHZhciBvdXRsaW5lQ29sb3IgPSBuZXcgQ29sb3IoaG9sZGVyQmcucHJvcGVydGllcy5maWxsKTtcblx0ICAgICAgICBvdXRsaW5lQ29sb3IgPSBvdXRsaW5lQ29sb3IubGlnaHRlbihvdXRsaW5lQ29sb3IubGlnaHRlclRoYW4oJzdmN2Y3ZicpID8gLTAuMSA6IDAuMSk7XG5cdCAgICAgICAgaG9sZGVyQmcucHJvcGVydGllcy5vdXRsaW5lID0ge1xuXHQgICAgICAgICAgICBmaWxsOiBvdXRsaW5lQ29sb3IudG9IZXgodHJ1ZSksXG5cdCAgICAgICAgICAgIHdpZHRoOiAyXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGhvbGRlclRleHRDb2xvciA9IHNjZW5lLnRoZW1lLmZnO1xuXG5cdCAgICBpZiAoc2NlbmUuZmxhZ3MuYXV0b0ZnKSB7XG5cdCAgICAgICAgdmFyIGhvbGRlckJnQ29sb3IgPSBuZXcgQ29sb3IoaG9sZGVyQmcucHJvcGVydGllcy5maWxsKTtcblx0ICAgICAgICB2YXIgbGlnaHRDb2xvciA9IG5ldyBDb2xvcignZmZmJyk7XG5cdCAgICAgICAgdmFyIGRhcmtDb2xvciA9IG5ldyBDb2xvcignMDAwJywge1xuXHQgICAgICAgICAgICAnYWxwaGEnOiAwLjI4NTcxNFxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgaG9sZGVyVGV4dENvbG9yID0gaG9sZGVyQmdDb2xvci5ibGVuZEFscGhhKGhvbGRlckJnQ29sb3IubGlnaHRlclRoYW4oJzdmN2Y3ZicpID8gZGFya0NvbG9yIDogbGlnaHRDb2xvcikudG9IZXgodHJ1ZSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBob2xkZXJUZXh0R3JvdXAgPSBuZXcgU2hhcGUuR3JvdXAoJ2hvbGRlclRleHRHcm91cCcsIHtcblx0ICAgICAgICB0ZXh0OiBzY2VuZS50ZXh0LFxuXHQgICAgICAgIGFsaWduOiBzY2VuZS5hbGlnbixcblx0ICAgICAgICBmb250OiBzY2VuZS5mb250LFxuXHQgICAgICAgIGZpbGw6IGhvbGRlclRleHRDb2xvclxuXHQgICAgfSk7XG5cblx0ICAgIGhvbGRlclRleHRHcm91cC5tb3ZlVG8obnVsbCwgbnVsbCwgMSk7XG5cdCAgICBzY2VuZUdyYXBoLnJvb3QuYWRkKGhvbGRlclRleHRHcm91cCk7XG5cblx0ICAgIHZhciB0cGRhdGEgPSBob2xkZXJUZXh0R3JvdXAudGV4dFBvc2l0aW9uRGF0YSA9IHN0YWdpbmdSZW5kZXJlcihzY2VuZUdyYXBoKTtcblx0ICAgIGlmICghdHBkYXRhKSB7XG5cdCAgICAgICAgdGhyb3cgJ0hvbGRlcjogc3RhZ2luZyBmYWxsYmFjayBub3Qgc3VwcG9ydGVkIHlldC4nO1xuXHQgICAgfVxuXHQgICAgaG9sZGVyVGV4dEdyb3VwLnByb3BlcnRpZXMubGVhZGluZyA9IHRwZGF0YS5ib3VuZGluZ0JveC5oZWlnaHQ7XG5cblx0ICAgIHZhciB0ZXh0Tm9kZSA9IG51bGw7XG5cdCAgICB2YXIgbGluZSA9IG51bGw7XG5cblx0ICAgIGZ1bmN0aW9uIGZpbmFsaXplTGluZShwYXJlbnQsIGxpbmUsIHdpZHRoLCBoZWlnaHQpIHtcblx0ICAgICAgICBsaW5lLndpZHRoID0gd2lkdGg7XG5cdCAgICAgICAgbGluZS5oZWlnaHQgPSBoZWlnaHQ7XG5cdCAgICAgICAgcGFyZW50LndpZHRoID0gTWF0aC5tYXgocGFyZW50LndpZHRoLCBsaW5lLndpZHRoKTtcblx0ICAgICAgICBwYXJlbnQuaGVpZ2h0ICs9IGxpbmUuaGVpZ2h0O1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHBkYXRhLmxpbmVDb3VudCA+IDEpIHtcblx0ICAgICAgICB2YXIgb2Zmc2V0WCA9IDA7XG5cdCAgICAgICAgdmFyIG9mZnNldFkgPSAwO1xuXHQgICAgICAgIHZhciBsaW5lSW5kZXggPSAwO1xuXHQgICAgICAgIHZhciBsaW5lS2V5O1xuXHQgICAgICAgIGxpbmUgPSBuZXcgU2hhcGUuR3JvdXAoJ2xpbmUnICsgbGluZUluZGV4KTtcblxuXHQgICAgICAgIC8vRG91YmxlIG1hcmdpbiBzbyB0aGF0IGxlZnQvcmlnaHQtYWxpZ25lZCBuZXh0IGlzIG5vdCBmbHVzaCB3aXRoIGVkZ2Ugb2YgaW1hZ2Vcblx0ICAgICAgICBpZiAoc2NlbmUuYWxpZ24gPT09ICdsZWZ0JyB8fCBzY2VuZS5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHQgICAgICAgICAgICBtYXhMaW5lV2lkdGggPSBzY2VuZS53aWR0aCAqICgxIC0gKDEgLSBsaW5lV3JhcCkgKiAyKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRwZGF0YS53b3Jkcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgd29yZCA9IHRwZGF0YS53b3Jkc1tpXTtcblx0ICAgICAgICAgICAgdGV4dE5vZGUgPSBuZXcgU2hhcGUuVGV4dCh3b3JkLnRleHQpO1xuXHQgICAgICAgICAgICB2YXIgbmV3bGluZSA9IHdvcmQudGV4dCA9PSAnXFxcXG4nO1xuXHQgICAgICAgICAgICBpZiAoIXNjZW5lLm5vV3JhcCAmJiAob2Zmc2V0WCArIHdvcmQud2lkdGggPj0gbWF4TGluZVdpZHRoIHx8IG5ld2xpbmUgPT09IHRydWUpKSB7XG5cdCAgICAgICAgICAgICAgICBmaW5hbGl6ZUxpbmUoaG9sZGVyVGV4dEdyb3VwLCBsaW5lLCBvZmZzZXRYLCBob2xkZXJUZXh0R3JvdXAucHJvcGVydGllcy5sZWFkaW5nKTtcblx0ICAgICAgICAgICAgICAgIGhvbGRlclRleHRHcm91cC5hZGQobGluZSk7XG5cdCAgICAgICAgICAgICAgICBvZmZzZXRYID0gMDtcblx0ICAgICAgICAgICAgICAgIG9mZnNldFkgKz0gaG9sZGVyVGV4dEdyb3VwLnByb3BlcnRpZXMubGVhZGluZztcblx0ICAgICAgICAgICAgICAgIGxpbmVJbmRleCArPSAxO1xuXHQgICAgICAgICAgICAgICAgbGluZSA9IG5ldyBTaGFwZS5Hcm91cCgnbGluZScgKyBsaW5lSW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgbGluZS55ID0gb2Zmc2V0WTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAobmV3bGluZSA9PT0gdHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGV4dE5vZGUubW92ZVRvKG9mZnNldFgsIDApO1xuXHQgICAgICAgICAgICBvZmZzZXRYICs9IHRwZGF0YS5zcGFjZVdpZHRoICsgd29yZC53aWR0aDtcblx0ICAgICAgICAgICAgbGluZS5hZGQodGV4dE5vZGUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZpbmFsaXplTGluZShob2xkZXJUZXh0R3JvdXAsIGxpbmUsIG9mZnNldFgsIGhvbGRlclRleHRHcm91cC5wcm9wZXJ0aWVzLmxlYWRpbmcpO1xuXHQgICAgICAgIGhvbGRlclRleHRHcm91cC5hZGQobGluZSk7XG5cblx0ICAgICAgICBpZiAoc2NlbmUuYWxpZ24gPT09ICdsZWZ0Jykge1xuXHQgICAgICAgICAgICBob2xkZXJUZXh0R3JvdXAubW92ZVRvKHNjZW5lLndpZHRoIC0gc2NlbmVNYXJnaW4sIG51bGwsIG51bGwpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoc2NlbmUuYWxpZ24gPT09ICdyaWdodCcpIHtcblx0ICAgICAgICAgICAgZm9yIChsaW5lS2V5IGluIGhvbGRlclRleHRHcm91cC5jaGlsZHJlbikge1xuXHQgICAgICAgICAgICAgICAgbGluZSA9IGhvbGRlclRleHRHcm91cC5jaGlsZHJlbltsaW5lS2V5XTtcblx0ICAgICAgICAgICAgICAgIGxpbmUubW92ZVRvKHNjZW5lLndpZHRoIC0gbGluZS53aWR0aCwgbnVsbCwgbnVsbCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBob2xkZXJUZXh0R3JvdXAubW92ZVRvKDAgLSAoc2NlbmUud2lkdGggLSBzY2VuZU1hcmdpbiksIG51bGwsIG51bGwpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGZvciAobGluZUtleSBpbiBob2xkZXJUZXh0R3JvdXAuY2hpbGRyZW4pIHtcblx0ICAgICAgICAgICAgICAgIGxpbmUgPSBob2xkZXJUZXh0R3JvdXAuY2hpbGRyZW5bbGluZUtleV07XG5cdCAgICAgICAgICAgICAgICBsaW5lLm1vdmVUbygoaG9sZGVyVGV4dEdyb3VwLndpZHRoIC0gbGluZS53aWR0aCkgLyAyLCBudWxsLCBudWxsKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGhvbGRlclRleHRHcm91cC5tb3ZlVG8oKHNjZW5lLndpZHRoIC0gaG9sZGVyVGV4dEdyb3VwLndpZHRoKSAvIDIsIG51bGwsIG51bGwpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGhvbGRlclRleHRHcm91cC5tb3ZlVG8obnVsbCwgKHNjZW5lLmhlaWdodCAtIGhvbGRlclRleHRHcm91cC5oZWlnaHQpIC8gMiwgbnVsbCk7XG5cblx0ICAgICAgICAvL0lmIHRoZSB0ZXh0IGV4Y2VlZHMgdmVydGljYWwgc3BhY2UsIG1vdmUgaXQgZG93biBzbyB0aGUgZmlyc3QgbGluZSBpcyB2aXNpYmxlXG5cdCAgICAgICAgaWYgKChzY2VuZS5oZWlnaHQgLSBob2xkZXJUZXh0R3JvdXAuaGVpZ2h0KSAvIDIgPCAwKSB7XG5cdCAgICAgICAgICAgIGhvbGRlclRleHRHcm91cC5tb3ZlVG8obnVsbCwgMCwgbnVsbCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICB0ZXh0Tm9kZSA9IG5ldyBTaGFwZS5UZXh0KHNjZW5lLnRleHQpO1xuXHQgICAgICAgIGxpbmUgPSBuZXcgU2hhcGUuR3JvdXAoJ2xpbmUwJyk7XG5cdCAgICAgICAgbGluZS5hZGQodGV4dE5vZGUpO1xuXHQgICAgICAgIGhvbGRlclRleHRHcm91cC5hZGQobGluZSk7XG5cblx0ICAgICAgICBpZiAoc2NlbmUuYWxpZ24gPT09ICdsZWZ0Jykge1xuXHQgICAgICAgICAgICBob2xkZXJUZXh0R3JvdXAubW92ZVRvKHNjZW5lLndpZHRoIC0gc2NlbmVNYXJnaW4sIG51bGwsIG51bGwpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoc2NlbmUuYWxpZ24gPT09ICdyaWdodCcpIHtcblx0ICAgICAgICAgICAgaG9sZGVyVGV4dEdyb3VwLm1vdmVUbygwIC0gKHNjZW5lLndpZHRoIC0gc2NlbmVNYXJnaW4pLCBudWxsLCBudWxsKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBob2xkZXJUZXh0R3JvdXAubW92ZVRvKChzY2VuZS53aWR0aCAtIHRwZGF0YS5ib3VuZGluZ0JveC53aWR0aCkgLyAyLCBudWxsLCBudWxsKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBob2xkZXJUZXh0R3JvdXAubW92ZVRvKG51bGwsIChzY2VuZS5oZWlnaHQgLSB0cGRhdGEuYm91bmRpbmdCb3guaGVpZ2h0KSAvIDIsIG51bGwpO1xuXHQgICAgfVxuXG5cdCAgICAvL3RvZG86IHJlbmRlcmxpc3Rcblx0ICAgIHJldHVybiBzY2VuZUdyYXBoO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkYXB0aXZlIHRleHQgc2l6aW5nIGZ1bmN0aW9uXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB3aWR0aCBQYXJlbnQgd2lkdGhcblx0ICogQHBhcmFtIGhlaWdodCBQYXJlbnQgaGVpZ2h0XG5cdCAqIEBwYXJhbSBmb250U2l6ZSBSZXF1ZXN0ZWQgdGV4dCBzaXplXG5cdCAqIEBwYXJhbSBzY2FsZSBQcm9wb3J0aW9uYWwgc2NhbGUgb2YgdGV4dFxuXHQgKi9cblx0ZnVuY3Rpb24gdGV4dFNpemUod2lkdGgsIGhlaWdodCwgZm9udFNpemUsIHNjYWxlKSB7XG5cdCAgICB2YXIgc3RhZ2VXaWR0aCA9IHBhcnNlSW50KHdpZHRoLCAxMCk7XG5cdCAgICB2YXIgc3RhZ2VIZWlnaHQgPSBwYXJzZUludChoZWlnaHQsIDEwKTtcblxuXHQgICAgdmFyIGJpZ1NpZGUgPSBNYXRoLm1heChzdGFnZVdpZHRoLCBzdGFnZUhlaWdodCk7XG5cdCAgICB2YXIgc21hbGxTaWRlID0gTWF0aC5taW4oc3RhZ2VXaWR0aCwgc3RhZ2VIZWlnaHQpO1xuXG5cdCAgICB2YXIgbmV3SGVpZ2h0ID0gMC44ICogTWF0aC5taW4oc21hbGxTaWRlLCBiaWdTaWRlICogc2NhbGUpO1xuXHQgICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5tYXgoZm9udFNpemUsIG5ld0hlaWdodCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEl0ZXJhdGVzIG92ZXIgcmVzaXphYmxlIChmbHVpZCBvciBhdXRvKSBwbGFjZWhvbGRlcnMgYW5kIHJlbmRlcnMgdGhlbVxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0gZWxlbWVudCBPcHRpb25hbCBlbGVtZW50IHNlbGVjdG9yLCBzcGVjaWZpZWQgb25seSBpZiBhIHNwZWNpZmljIGVsZW1lbnQgbmVlZHMgdG8gYmUgcmUtcmVuZGVyZWRcblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZVJlc2l6YWJsZUVsZW1lbnRzKGVsZW1lbnQpIHtcblx0ICAgIHZhciBpbWFnZXM7XG5cdCAgICBpZiAoZWxlbWVudCA9PSBudWxsIHx8IGVsZW1lbnQubm9kZVR5cGUgPT0gbnVsbCkge1xuXHQgICAgICAgIGltYWdlcyA9IEFwcC52YXJzLnJlc2l6YWJsZUltYWdlcztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaW1hZ2VzID0gW2VsZW1lbnRdO1xuXHQgICAgfVxuXHQgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbWFnZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGVsID0gaW1hZ2VzW2ldO1xuXHQgICAgICAgIGlmIChlbC5ob2xkZXJEYXRhKSB7XG5cdCAgICAgICAgICAgIHZhciBmbGFncyA9IGVsLmhvbGRlckRhdGEuZmxhZ3M7XG5cdCAgICAgICAgICAgIHZhciBkaW1lbnNpb25zID0gZGltZW5zaW9uQ2hlY2soZWwpO1xuXHQgICAgICAgICAgICBpZiAoZGltZW5zaW9ucykge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFlbC5ob2xkZXJEYXRhLnJlc2l6ZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAoZmxhZ3MuZmx1aWQgJiYgZmxhZ3MuYXV0bykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmbHVpZENvbmZpZyA9IGVsLmhvbGRlckRhdGEuZmx1aWRDb25maWc7XG5cdCAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmbHVpZENvbmZpZy5tb2RlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpZHRoJzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ID0gZGltZW5zaW9ucy53aWR0aCAvIGZsdWlkQ29uZmlnLnJhdGlvO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hlaWdodCc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoID0gZGltZW5zaW9ucy5oZWlnaHQgKiBmbHVpZENvbmZpZy5yYXRpbztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIG1vZGU6ICdpbWFnZScsXG5cdCAgICAgICAgICAgICAgICAgICAgaG9sZGVyU2V0dGluZ3M6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczogZGltZW5zaW9ucyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWU6IGZsYWdzLnRoZW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmbGFnczogZmxhZ3Ncblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGVsOiBlbCxcblx0ICAgICAgICAgICAgICAgICAgICBlbmdpbmVTZXR0aW5nczogZWwuaG9sZGVyRGF0YS5lbmdpbmVTZXR0aW5nc1xuXHQgICAgICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKGZsYWdzLnRleHRtb2RlID09ICdleGFjdCcpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmbGFncy5leGFjdERpbWVuc2lvbnMgPSBkaW1lbnNpb25zO1xuXHQgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmhvbGRlclNldHRpbmdzLmRpbWVuc2lvbnMgPSBmbGFncy5kaW1lbnNpb25zO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZW5kZXIoc2V0dGluZ3MpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgc2V0SW52aXNpYmxlKGVsKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHVwIGFzcGVjdCByYXRpbyBtZXRhZGF0YSBmb3IgZmx1aWQgcGxhY2Vob2xkZXJzLCBpbiBvcmRlciB0byBwcmVzZXJ2ZSBwcm9wb3J0aW9ucyB3aGVuIHJlc2l6aW5nXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSBlbCBJbWFnZSBET00gZWxlbWVudFxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0SW5pdGlhbERpbWVuc2lvbnMoZWwpIHtcblx0ICAgIGlmIChlbC5ob2xkZXJEYXRhKSB7XG5cdCAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSBkaW1lbnNpb25DaGVjayhlbCk7XG5cdCAgICAgICAgaWYgKGRpbWVuc2lvbnMpIHtcblx0ICAgICAgICAgICAgdmFyIGZsYWdzID0gZWwuaG9sZGVyRGF0YS5mbGFncztcblxuXHQgICAgICAgICAgICB2YXIgZmx1aWRDb25maWcgPSB7XG5cdCAgICAgICAgICAgICAgICBmbHVpZEhlaWdodDogZmxhZ3MuZGltZW5zaW9ucy5oZWlnaHQuc2xpY2UoLTEpID09ICclJyxcblx0ICAgICAgICAgICAgICAgIGZsdWlkV2lkdGg6IGZsYWdzLmRpbWVuc2lvbnMud2lkdGguc2xpY2UoLTEpID09ICclJyxcblx0ICAgICAgICAgICAgICAgIG1vZGU6IG51bGwsXG5cdCAgICAgICAgICAgICAgICBpbml0aWFsRGltZW5zaW9uczogZGltZW5zaW9uc1xuXHQgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgIGlmIChmbHVpZENvbmZpZy5mbHVpZFdpZHRoICYmICFmbHVpZENvbmZpZy5mbHVpZEhlaWdodCkge1xuXHQgICAgICAgICAgICAgICAgZmx1aWRDb25maWcubW9kZSA9ICd3aWR0aCc7XG5cdCAgICAgICAgICAgICAgICBmbHVpZENvbmZpZy5yYXRpbyA9IGZsdWlkQ29uZmlnLmluaXRpYWxEaW1lbnNpb25zLndpZHRoIC8gcGFyc2VGbG9hdChmbGFncy5kaW1lbnNpb25zLmhlaWdodCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoIWZsdWlkQ29uZmlnLmZsdWlkV2lkdGggJiYgZmx1aWRDb25maWcuZmx1aWRIZWlnaHQpIHtcblx0ICAgICAgICAgICAgICAgIGZsdWlkQ29uZmlnLm1vZGUgPSAnaGVpZ2h0Jztcblx0ICAgICAgICAgICAgICAgIGZsdWlkQ29uZmlnLnJhdGlvID0gcGFyc2VGbG9hdChmbGFncy5kaW1lbnNpb25zLndpZHRoKSAvIGZsdWlkQ29uZmlnLmluaXRpYWxEaW1lbnNpb25zLmhlaWdodDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGVsLmhvbGRlckRhdGEuZmx1aWRDb25maWcgPSBmbHVpZENvbmZpZztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBzZXRJbnZpc2libGUoZWwpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBJdGVyYXRlcyB0aHJvdWdoIGFsbCBjdXJyZW50IGludmlzaWJsZSBpbWFnZXMsIGFuZCBpZiB0aGV5J3JlIHZpc2libGUsIHJlbmRlcnMgdGhlbSBhbmQgcmVtb3ZlcyB0aGVtIGZyb20gZnVydGhlciBjaGVja3MuIFJ1bnMgZXZlcnkgYW5pbWF0aW9uIGZyYW1lLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gdmlzaWJpbGl0eUNoZWNrKCkge1xuXHQgICAgdmFyIHJlbmRlcmFibGVJbWFnZXMgPSBbXTtcblx0ICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoQXBwLnZhcnMuaW52aXNpYmxlSW1hZ2VzKTtcblx0ICAgIHZhciBlbDtcblxuXHQgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICBlbCA9IEFwcC52YXJzLmludmlzaWJsZUltYWdlc1trZXldO1xuXHQgICAgICAgIGlmIChkaW1lbnNpb25DaGVjayhlbCkgJiYgZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSAnaW1nJykge1xuXHQgICAgICAgICAgICByZW5kZXJhYmxlSW1hZ2VzLnB1c2goZWwpO1xuXHQgICAgICAgICAgICBkZWxldGUgQXBwLnZhcnMuaW52aXNpYmxlSW1hZ2VzW2tleV07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIGlmIChyZW5kZXJhYmxlSW1hZ2VzLmxlbmd0aCkge1xuXHQgICAgICAgIEhvbGRlci5ydW4oe1xuXHQgICAgICAgICAgICBpbWFnZXM6IHJlbmRlcmFibGVJbWFnZXNcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgLy8gRG9uZSB0byBwcmV2ZW50IDEwMCUgQ1BVIHVzYWdlIHZpYSBhZ2dyZXNzaXZlIGNhbGxpbmcgb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cdCAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHZpc2liaWxpdHlDaGVjayk7XG5cdCAgICB9LCAxMCk7XG5cdH1cblxuXHQvKipcblx0ICogU3RhcnRzIGNoZWNraW5nIGZvciBpbnZpc2libGUgcGxhY2Vob2xkZXJzIGlmIG5vdCBkb2luZyBzbyB5ZXQuIERvZXMgbm90aGluZyBvdGhlcndpc2UuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBzdGFydFZpc2liaWxpdHlDaGVjaygpIHtcblx0ICAgIGlmICghQXBwLnZhcnMudmlzaWJpbGl0eUNoZWNrU3RhcnRlZCkge1xuXHQgICAgICAgIGdsb2JhbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodmlzaWJpbGl0eUNoZWNrKTtcblx0ICAgICAgICBBcHAudmFycy52aXNpYmlsaXR5Q2hlY2tTdGFydGVkID0gdHJ1ZTtcblx0ICAgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIGEgdW5pcXVlIElEIGZvciBhbiBpbWFnZSBkZXRlY3RlZCB0byBiZSBpbnZpc2libGUgYW5kIGFkZHMgaXQgdG8gdGhlIG1hcCBvZiBpbnZpc2libGUgaW1hZ2VzIGNoZWNrZWQgYnkgdmlzaWJpbGl0eUNoZWNrXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSBlbCBJbnZpc2libGUgRE9NIGVsZW1lbnRcblx0ICovXG5cdGZ1bmN0aW9uIHNldEludmlzaWJsZShlbCkge1xuXHQgICAgaWYgKCFlbC5ob2xkZXJEYXRhLmludmlzaWJsZUlkKSB7XG5cdCAgICAgICAgQXBwLnZhcnMuaW52aXNpYmxlSWQgKz0gMTtcblx0ICAgICAgICBBcHAudmFycy5pbnZpc2libGVJbWFnZXNbJ2knICsgQXBwLnZhcnMuaW52aXNpYmxlSWRdID0gZWw7XG5cdCAgICAgICAgZWwuaG9sZGVyRGF0YS5pbnZpc2libGVJZCA9IEFwcC52YXJzLmludmlzaWJsZUlkO1xuXHQgICAgfVxuXHR9XG5cblx0Ly90b2RvOiBzZWUgaWYgcG9zc2libGUgdG8gY29udmVydCBzdGFnaW5nUmVuZGVyZXIgdG8gdXNlIEhUTUwgb25seVxuXHR2YXIgc3RhZ2luZ1JlbmRlcmVyID0gKGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIHN2ZyA9IG51bGwsXG5cdCAgICAgICAgc3RhZ2luZ1RleHQgPSBudWxsLFxuXHQgICAgICAgIHN0YWdpbmdUZXh0Tm9kZSA9IG51bGw7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24oZ3JhcGgpIHtcblx0ICAgICAgICB2YXIgcm9vdE5vZGUgPSBncmFwaC5yb290O1xuXHQgICAgICAgIGlmIChBcHAuc2V0dXAuc3VwcG9ydHNTVkcpIHtcblx0ICAgICAgICAgICAgdmFyIGZpcnN0VGltZVNldHVwID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHZhciB0bm9kZSA9IGZ1bmN0aW9uKHRleHQpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgaWYgKHN2ZyA9PSBudWxsIHx8IHN2Zy5wYXJlbnROb2RlICE9PSBkb2N1bWVudC5ib2R5KSB7XG5cdCAgICAgICAgICAgICAgICBmaXJzdFRpbWVTZXR1cCA9IHRydWU7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBzdmcgPSBTVkcuaW5pdFNWRyhzdmcsIHJvb3ROb2RlLnByb3BlcnRpZXMud2lkdGgsIHJvb3ROb2RlLnByb3BlcnRpZXMuaGVpZ2h0KTtcblx0ICAgICAgICAgICAgLy9TaG93IHN0YWdpbmcgZWxlbWVudCBiZWZvcmUgc3RhZ2luZ1xuXHQgICAgICAgICAgICBzdmcuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cblx0ICAgICAgICAgICAgaWYgKGZpcnN0VGltZVNldHVwKSB7XG5cdCAgICAgICAgICAgICAgICBzdGFnaW5nVGV4dCA9IERPTS5uZXdFbCgndGV4dCcsIFNWR19OUyk7XG5cdCAgICAgICAgICAgICAgICBzdGFnaW5nVGV4dE5vZGUgPSB0bm9kZShudWxsKTtcblx0ICAgICAgICAgICAgICAgIERPTS5zZXRBdHRyKHN0YWdpbmdUZXh0LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgeDogMFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBzdGFnaW5nVGV4dC5hcHBlbmRDaGlsZChzdGFnaW5nVGV4dE5vZGUpO1xuXHQgICAgICAgICAgICAgICAgc3ZnLmFwcGVuZENoaWxkKHN0YWdpbmdUZXh0KTtcblx0ICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3ZnKTtcblx0ICAgICAgICAgICAgICAgIHN2Zy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cdCAgICAgICAgICAgICAgICBzdmcuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHQgICAgICAgICAgICAgICAgc3ZnLnN0eWxlLnRvcCA9ICctMTAwJSc7XG5cdCAgICAgICAgICAgICAgICBzdmcuc3R5bGUubGVmdCA9ICctMTAwJSc7XG5cdCAgICAgICAgICAgICAgICAvL3RvZG86IHdvcmthcm91bmQgZm9yIHplcm8tZGltZW5zaW9uIDxzdmc+IHRhZyBpbiBPcGVyYSAxMlxuXHQgICAgICAgICAgICAgICAgLy9zdmcuc2V0QXR0cmlidXRlKCd3aWR0aCcsIDApO1xuXHQgICAgICAgICAgICAgICAgLy9zdmcuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHZhciBob2xkZXJUZXh0R3JvdXAgPSByb290Tm9kZS5jaGlsZHJlbi5ob2xkZXJUZXh0R3JvdXA7XG5cdCAgICAgICAgICAgIHZhciBodGdQcm9wcyA9IGhvbGRlclRleHRHcm91cC5wcm9wZXJ0aWVzO1xuXHQgICAgICAgICAgICBET00uc2V0QXR0cihzdGFnaW5nVGV4dCwge1xuXHQgICAgICAgICAgICAgICAgJ3knOiBodGdQcm9wcy5mb250LnNpemUsXG5cdCAgICAgICAgICAgICAgICAnc3R5bGUnOiB1dGlscy5jc3NQcm9wcyh7XG5cdCAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtd2VpZ2h0JzogaHRnUHJvcHMuZm9udC53ZWlnaHQsXG5cdCAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtc2l6ZSc6IGh0Z1Byb3BzLmZvbnQuc2l6ZSArIGh0Z1Byb3BzLmZvbnQudW5pdHMsXG5cdCAgICAgICAgICAgICAgICAgICAgJ2ZvbnQtZmFtaWx5JzogaHRnUHJvcHMuZm9udC5mYW1pbHlcblx0ICAgICAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIC8vR2V0IGJvdW5kaW5nIGJveCBmb3IgdGhlIHdob2xlIHN0cmluZyAodG90YWwgd2lkdGggYW5kIGhlaWdodClcblx0ICAgICAgICAgICAgc3RhZ2luZ1RleHROb2RlLm5vZGVWYWx1ZSA9IGh0Z1Byb3BzLnRleHQ7XG5cdCAgICAgICAgICAgIHZhciBzdGFnaW5nVGV4dEJCb3ggPSBzdGFnaW5nVGV4dC5nZXRCQm94KCk7XG5cblx0ICAgICAgICAgICAgLy9HZXQgbGluZSBjb3VudCBhbmQgc3BsaXQgdGhlIHN0cmluZyBpbnRvIHdvcmRzXG5cdCAgICAgICAgICAgIHZhciBsaW5lQ291bnQgPSBNYXRoLmNlaWwoc3RhZ2luZ1RleHRCQm94LndpZHRoIC8gcm9vdE5vZGUucHJvcGVydGllcy53aWR0aCk7XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IGh0Z1Byb3BzLnRleHQuc3BsaXQoJyAnKTtcblx0ICAgICAgICAgICAgdmFyIG5ld2xpbmVzID0gaHRnUHJvcHMudGV4dC5tYXRjaCgvXFxcXG4vZyk7XG5cdCAgICAgICAgICAgIGxpbmVDb3VudCArPSBuZXdsaW5lcyA9PSBudWxsID8gMCA6IG5ld2xpbmVzLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvL0dldCBib3VuZGluZyBib3ggZm9yIHRoZSBzdHJpbmcgd2l0aCBzcGFjZXMgcmVtb3ZlZFxuXHQgICAgICAgICAgICBzdGFnaW5nVGV4dE5vZGUubm9kZVZhbHVlID0gaHRnUHJvcHMudGV4dC5yZXBsYWNlKC9bIF0rL2csICcnKTtcblx0ICAgICAgICAgICAgdmFyIGNvbXB1dGVkTm9TcGFjZUxlbmd0aCA9IHN0YWdpbmdUZXh0LmdldENvbXB1dGVkVGV4dExlbmd0aCgpO1xuXG5cdCAgICAgICAgICAgIC8vQ29tcHV0ZSBhdmVyYWdlIHNwYWNlIHdpZHRoXG5cdCAgICAgICAgICAgIHZhciBkaWZmTGVuZ3RoID0gc3RhZ2luZ1RleHRCQm94LndpZHRoIC0gY29tcHV0ZWROb1NwYWNlTGVuZ3RoO1xuXHQgICAgICAgICAgICB2YXIgc3BhY2VXaWR0aCA9IE1hdGgucm91bmQoZGlmZkxlbmd0aCAvIE1hdGgubWF4KDEsIHdvcmRzLmxlbmd0aCAtIDEpKTtcblxuXHQgICAgICAgICAgICAvL0dldCB3aWR0aHMgZm9yIGV2ZXJ5IHdvcmQgd2l0aCBzcGFjZSBvbmx5IGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgbGluZVxuXHQgICAgICAgICAgICB2YXIgd29yZFdpZHRocyA9IFtdO1xuXHQgICAgICAgICAgICBpZiAobGluZUNvdW50ID4gMSkge1xuXHQgICAgICAgICAgICAgICAgc3RhZ2luZ1RleHROb2RlLm5vZGVWYWx1ZSA9ICcnO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh3b3Jkc1tpXS5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YWdpbmdUZXh0Tm9kZS5ub2RlVmFsdWUgPSB1dGlscy5kZWNvZGVIdG1sRW50aXR5KHdvcmRzW2ldKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYmJveCA9IHN0YWdpbmdUZXh0LmdldEJCb3goKTtcblx0ICAgICAgICAgICAgICAgICAgICB3b3JkV2lkdGhzLnB1c2goe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB3b3Jkc1tpXSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGJib3gud2lkdGhcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vSGlkZSBzdGFnaW5nIGVsZW1lbnQgYWZ0ZXIgc3RhZ2luZ1xuXHQgICAgICAgICAgICBzdmcuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgc3BhY2VXaWR0aDogc3BhY2VXaWR0aCxcblx0ICAgICAgICAgICAgICAgIGxpbmVDb3VudDogbGluZUNvdW50LFxuXHQgICAgICAgICAgICAgICAgYm91bmRpbmdCb3g6IHN0YWdpbmdUZXh0QkJveCxcblx0ICAgICAgICAgICAgICAgIHdvcmRzOiB3b3JkV2lkdGhzXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy90b2RvOiBjYW52YXMgZmFsbGJhY2sgZm9yIG1lYXN1cmluZyB0ZXh0IG9uIGFuZHJvaWQgMi4zXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHR9KSgpO1xuXG5cdC8vSGVscGVyc1xuXG5cdC8qKlxuXHQgKiBQcmV2ZW50cyBhIGZ1bmN0aW9uIGZyb20gYmVpbmcgY2FsbGVkIHRvbyBvZnRlbiwgd2FpdHMgdW50aWwgYSB0aW1lciBlbGFwc2VzIHRvIGNhbGwgaXQgYWdhaW5cblx0ICpcblx0ICogQHBhcmFtIGZuIEZ1bmN0aW9uIHRvIGNhbGxcblx0ICovXG5cdGZ1bmN0aW9uIGRlYm91bmNlKGZuKSB7XG5cdCAgICBpZiAoIUFwcC52YXJzLmRlYm91bmNlVGltZXIpIGZuLmNhbGwodGhpcyk7XG5cdCAgICBpZiAoQXBwLnZhcnMuZGVib3VuY2VUaW1lcikgZ2xvYmFsLmNsZWFyVGltZW91dChBcHAudmFycy5kZWJvdW5jZVRpbWVyKTtcblx0ICAgIEFwcC52YXJzLmRlYm91bmNlVGltZXIgPSBnbG9iYWwuc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0ICAgICAgICBBcHAudmFycy5kZWJvdW5jZVRpbWVyID0gbnVsbDtcblx0ICAgICAgICBmbi5jYWxsKHRoaXMpO1xuXHQgICAgfSwgQXBwLnNldHVwLmRlYm91bmNlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIb2xkZXItc3BlY2lmaWMgcmVzaXplL29yaWVudGF0aW9uIGNoYW5nZSBjYWxsYmFjaywgZGVib3VuY2VkIHRvIHByZXZlbnQgZXhjZXNzaXZlIGV4ZWN1dGlvblxuXHQgKi9cblx0ZnVuY3Rpb24gcmVzaXplRXZlbnQoKSB7XG5cdCAgICBkZWJvdW5jZShmdW5jdGlvbigpIHtcblx0ICAgICAgICB1cGRhdGVSZXNpemFibGVFbGVtZW50cyhudWxsKTtcblx0ICAgIH0pO1xuXHR9XG5cblx0Ly9TZXQgdXAgZmxhZ3NcblxuXHRmb3IgKHZhciBmbGFnIGluIEFwcC5mbGFncykge1xuXHQgICAgaWYgKCFBcHAuZmxhZ3MuaGFzT3duUHJvcGVydHkoZmxhZykpIGNvbnRpbnVlO1xuXHQgICAgQXBwLmZsYWdzW2ZsYWddLm1hdGNoID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbC5tYXRjaCh0aGlzLnJlZ2V4KTtcblx0ICAgIH07XG5cdH1cblxuXHQvL1Byb3BlcnRpZXMgc2V0IG9uY2Ugb24gc2V0dXBcblxuXHRBcHAuc2V0dXAgPSB7XG5cdCAgICByZW5kZXJlcjogJ2h0bWwnLFxuXHQgICAgZGVib3VuY2U6IDEwMCxcblx0ICAgIHJhdGlvOiAxLFxuXHQgICAgc3VwcG9ydHNDYW52YXM6IGZhbHNlLFxuXHQgICAgc3VwcG9ydHNTVkc6IGZhbHNlLFxuXHQgICAgbGluZVdyYXBSYXRpbzogMC45LFxuXHQgICAgZGF0YUF0dHI6ICdkYXRhLXNyYycsXG5cdCAgICByZW5kZXJlcnM6IFsnaHRtbCcsICdjYW52YXMnLCAnc3ZnJ11cblx0fTtcblxuXHQvL1Byb3BlcnRpZXMgbW9kaWZpZWQgZHVyaW5nIHJ1bnRpbWVcblxuXHRBcHAudmFycyA9IHtcblx0ICAgIHByZWVtcHRlZDogZmFsc2UsXG5cdCAgICByZXNpemFibGVJbWFnZXM6IFtdLFxuXHQgICAgaW52aXNpYmxlSW1hZ2VzOiB7fSxcblx0ICAgIGludmlzaWJsZUlkOiAwLFxuXHQgICAgdmlzaWJpbGl0eUNoZWNrU3RhcnRlZDogZmFsc2UsXG5cdCAgICBkZWJvdW5jZVRpbWVyOiBudWxsLFxuXHQgICAgY2FjaGU6IHt9XG5cdH07XG5cblx0Ly9QcmUtZmxpZ2h0XG5cblx0KGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGNhbnZhcyA9IERPTS5uZXdFbCgnY2FudmFzJyk7XG5cblx0ICAgIGlmIChjYW52YXMuZ2V0Q29udGV4dCkge1xuXHQgICAgICAgIGlmIChjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKS5pbmRleE9mKCdkYXRhOmltYWdlL3BuZycpICE9IC0xKSB7XG5cdCAgICAgICAgICAgIEFwcC5zZXR1cC5yZW5kZXJlciA9ICdjYW52YXMnO1xuXHQgICAgICAgICAgICBBcHAuc2V0dXAuc3VwcG9ydHNDYW52YXMgPSB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKCEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgJ3N2ZycpLmNyZWF0ZVNWR1JlY3QpIHtcblx0ICAgICAgICBBcHAuc2V0dXAucmVuZGVyZXIgPSAnc3ZnJztcblx0ICAgICAgICBBcHAuc2V0dXAuc3VwcG9ydHNTVkcgPSB0cnVlO1xuXHQgICAgfVxuXHR9KSgpO1xuXG5cdC8vU3RhcnRzIGNoZWNraW5nIGZvciBpbnZpc2libGUgcGxhY2Vob2xkZXJzXG5cdHN0YXJ0VmlzaWJpbGl0eUNoZWNrKCk7XG5cblx0aWYgKG9uRG9tUmVhZHkpIHtcblx0ICAgIG9uRG9tUmVhZHkoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgaWYgKCFBcHAudmFycy5wcmVlbXB0ZWQpIHtcblx0ICAgICAgICAgICAgSG9sZGVyLnJ1bigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZUV2ZW50LCBmYWxzZSk7XG5cdCAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHJlc2l6ZUV2ZW50LCBmYWxzZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbnJlc2l6ZScsIHJlc2l6ZUV2ZW50KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodHlwZW9mIGdsb2JhbC5UdXJib2xpbmtzID09ICdvYmplY3QnKSB7XG5cdCAgICAgICAgICAgIGdsb2JhbC5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwYWdlOmNoYW5nZScsIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgSG9sZGVyLnJ1bigpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0gSG9sZGVyO1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSxcbi8qIDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIVxuXHQgKiBvbkRvbVJlYWR5LmpzIDEuNC4wIChjKSAyMDEzIFR1YmFsIE1hcnRpbiAtIE1JVCBsaWNlbnNlXG5cdCAqXG5cdCAqIFNwZWNpYWxseSBtb2RpZmllZCB0byB3b3JrIHdpdGggSG9sZGVyLmpzXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIF9vbkRvbVJlYWR5KHdpbikge1xuXHQgICAgLy9MYXp5IGxvYWRpbmcgZml4IGZvciBGaXJlZm94IDwgMy42XG5cdCAgICAvL2h0dHA6Ly93ZWJyZWZsZWN0aW9uLmJsb2dzcG90LmNvbS8yMDA5LzExLzE5NS1jaGFycy10by1oZWxwLWxhenktbG9hZGluZy5odG1sXG5cdCAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSBudWxsICYmIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0ICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBmdW5jdGlvbiBET01Db250ZW50TG9hZGVkKCkge1xuXHQgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBET01Db250ZW50TG9hZGVkLCBmYWxzZSk7XG5cdCAgICAgICAgICAgIGRvY3VtZW50LnJlYWR5U3RhdGUgPSBcImNvbXBsZXRlXCI7XG5cdCAgICAgICAgfSwgZmFsc2UpO1xuXHQgICAgICAgIGRvY3VtZW50LnJlYWR5U3RhdGUgPSBcImxvYWRpbmdcIjtcblx0ICAgIH1cblx0ICAgIFxuXHQgICAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudCxcblx0ICAgICAgICBkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudCxcblx0ICAgIFxuXHQgICAgICAgIExPQUQgPSBcImxvYWRcIixcblx0ICAgICAgICBGQUxTRSA9IGZhbHNlLFxuXHQgICAgICAgIE9OTE9BRCA9IFwib25cIitMT0FELFxuXHQgICAgICAgIENPTVBMRVRFID0gXCJjb21wbGV0ZVwiLFxuXHQgICAgICAgIFJFQURZU1RBVEUgPSBcInJlYWR5U3RhdGVcIixcblx0ICAgICAgICBBVFRBQ0hFVkVOVCA9IFwiYXR0YWNoRXZlbnRcIixcblx0ICAgICAgICBERVRBQ0hFVkVOVCA9IFwiZGV0YWNoRXZlbnRcIixcblx0ICAgICAgICBBRERFVkVOVExJU1RFTkVSID0gXCJhZGRFdmVudExpc3RlbmVyXCIsXG5cdCAgICAgICAgRE9NQ09OVEVOVExPQURFRCA9IFwiRE9NQ29udGVudExvYWRlZFwiLFxuXHQgICAgICAgIE9OUkVBRFlTVEFURUNIQU5HRSA9IFwib25yZWFkeXN0YXRlY2hhbmdlXCIsXG5cdCAgICAgICAgUkVNT1ZFRVZFTlRMSVNURU5FUiA9IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiLFxuXHQgICAgXG5cdCAgICAgICAgLy8gVzNDIEV2ZW50IG1vZGVsXG5cdCAgICAgICAgdzNjID0gQURERVZFTlRMSVNURU5FUiBpbiBkb2MsXG5cdCAgICAgICAgX3RvcCA9IEZBTFNFLFxuXHQgICAgXG5cdCAgICAgICAgLy8gaXNSZWFkeTogSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0ICAgICAgICBpc1JlYWR5ID0gRkFMU0UsXG5cdCAgICBcblx0ICAgICAgICAvLyBDYWxsYmFja3MgcGVuZGluZyBleGVjdXRpb24gdW50aWwgRE9NIGlzIHJlYWR5XG5cdCAgICAgICAgY2FsbGJhY2tzID0gW107XG5cdCAgICBcblx0ICAgIC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0ICAgIGZ1bmN0aW9uIHJlYWR5KCBmbiApIHtcblx0ICAgICAgICBpZiAoICFpc1JlYWR5ICkge1xuXHQgICAgXG5cdCAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBib2R5IGV4aXN0cywgYXQgbGVhc3QsIGluIGNhc2UgSUUgZ2V0cyBhIGxpdHRsZSBvdmVyemVhbG91cyAodGlja2V0ICM1NDQzKS5cblx0ICAgICAgICAgICAgaWYgKCAhZG9jLmJvZHkgKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXIoIHJlYWR5ICk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgIFxuXHQgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0ICAgICAgICAgICAgaXNSZWFkeSA9IHRydWU7XG5cdCAgICBcblx0ICAgICAgICAgICAgLy8gRXhlY3V0ZSBhbGwgY2FsbGJhY2tzXG5cdCAgICAgICAgICAgIHdoaWxlICggZm4gPSBjYWxsYmFja3Muc2hpZnQoKSApIHtcblx0ICAgICAgICAgICAgICAgIGRlZmVyKCBmbiApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgXG5cdCAgICAvLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlclxuXHQgICAgZnVuY3Rpb24gY29tcGxldGVkKCBldmVudCApIHtcblx0ICAgICAgICAvLyByZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgaXMgZ29vZCBlbm91Z2ggZm9yIHVzIHRvIGNhbGwgdGhlIGRvbSByZWFkeSBpbiBvbGRJRVxuXHQgICAgICAgIGlmICggdzNjIHx8IGV2ZW50LnR5cGUgPT09IExPQUQgfHwgZG9jW1JFQURZU1RBVEVdID09PSBDT01QTEVURSApIHtcblx0ICAgICAgICAgICAgZGV0YWNoKCk7XG5cdCAgICAgICAgICAgIHJlYWR5KCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgXG5cdCAgICAvLyBDbGVhbi11cCBtZXRob2QgZm9yIGRvbSByZWFkeSBldmVudHNcblx0ICAgIGZ1bmN0aW9uIGRldGFjaCgpIHtcblx0ICAgICAgICBpZiAoIHczYyApIHtcblx0ICAgICAgICAgICAgZG9jW1JFTU9WRUVWRU5UTElTVEVORVJdKCBET01DT05URU5UTE9BREVELCBjb21wbGV0ZWQsIEZBTFNFICk7XG5cdCAgICAgICAgICAgIHdpbltSRU1PVkVFVkVOVExJU1RFTkVSXSggTE9BRCwgY29tcGxldGVkLCBGQUxTRSApO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGRvY1tERVRBQ0hFVkVOVF0oIE9OUkVBRFlTVEFURUNIQU5HRSwgY29tcGxldGVkICk7XG5cdCAgICAgICAgICAgIHdpbltERVRBQ0hFVkVOVF0oIE9OTE9BRCwgY29tcGxldGVkICk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgXG5cdCAgICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMgY2xlYXJlZC5cblx0ICAgIGZ1bmN0aW9uIGRlZmVyKCBmbiwgd2FpdCApIHtcblx0ICAgICAgICAvLyBBbGxvdyAwIHRvIGJlIHBhc3NlZFxuXHQgICAgICAgIHNldFRpbWVvdXQoIGZuLCArd2FpdCA+PSAwID8gd2FpdCA6IDEgKTtcblx0ICAgIH1cblx0ICAgIFxuXHQgICAgLy8gQXR0YWNoIHRoZSBsaXN0ZW5lcnM6XG5cdCAgICBcblx0ICAgIC8vIENhdGNoIGNhc2VzIHdoZXJlIG9uRG9tUmVhZHkgaXMgY2FsbGVkIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuXHQgICAgLy8gd2Ugb25jZSB0cmllZCB0byB1c2UgcmVhZHlTdGF0ZSBcImludGVyYWN0aXZlXCIgaGVyZSwgYnV0IGl0IGNhdXNlZCBpc3N1ZXMgbGlrZSB0aGUgb25lXG5cdCAgICAvLyBkaXNjb3ZlcmVkIGJ5IENocmlzUyBoZXJlOiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjI4MiNjb21tZW50OjE1XG5cdCAgICBpZiAoIGRvY1tSRUFEWVNUQVRFXSA9PT0gQ09NUExFVEUgKSB7XG5cdCAgICAgICAgLy8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdCAgICAgICAgZGVmZXIoIHJlYWR5ICk7XG5cdCAgICBcblx0ICAgIC8vIFN0YW5kYXJkcy1iYXNlZCBicm93c2VycyBzdXBwb3J0IERPTUNvbnRlbnRMb2FkZWRcblx0ICAgIH0gZWxzZSBpZiAoIHczYyApIHtcblx0ICAgICAgICAvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdCAgICAgICAgZG9jW0FEREVWRU5UTElTVEVORVJdKCBET01DT05URU5UTE9BREVELCBjb21wbGV0ZWQsIEZBTFNFICk7XG5cdCAgICBcblx0ICAgICAgICAvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHQgICAgICAgIHdpbltBRERFVkVOVExJU1RFTkVSXSggTE9BRCwgY29tcGxldGVkLCBGQUxTRSApO1xuXHQgICAgXG5cdCAgICAvLyBJZiBJRSBldmVudCBtb2RlbCBpcyB1c2VkXG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIC8vIEVuc3VyZSBmaXJpbmcgYmVmb3JlIG9ubG9hZCwgbWF5YmUgbGF0ZSBidXQgc2FmZSBhbHNvIGZvciBpZnJhbWVzXG5cdCAgICAgICAgZG9jW0FUVEFDSEVWRU5UXSggT05SRUFEWVNUQVRFQ0hBTkdFLCBjb21wbGV0ZWQgKTtcblx0ICAgIFxuXHQgICAgICAgIC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdCAgICAgICAgd2luW0FUVEFDSEVWRU5UXSggT05MT0FELCBjb21wbGV0ZWQgKTtcblx0ICAgIFxuXHQgICAgICAgIC8vIElmIElFIGFuZCBub3QgYSBmcmFtZVxuXHQgICAgICAgIC8vIGNvbnRpbnVhbGx5IGNoZWNrIHRvIHNlZSBpZiB0aGUgZG9jdW1lbnQgaXMgcmVhZHlcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBfdG9wID0gd2luLmZyYW1lRWxlbWVudCA9PSBudWxsICYmIGRvY0VsZW07XG5cdCAgICAgICAgfSBjYXRjaChlKSB7fVxuXHQgICAgXG5cdCAgICAgICAgaWYgKCBfdG9wICYmIF90b3AuZG9TY3JvbGwgKSB7XG5cdCAgICAgICAgICAgIChmdW5jdGlvbiBkb1Njcm9sbENoZWNrKCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCAhaXNSZWFkeSApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHRyaWNrIGJ5IERpZWdvIFBlcmluaVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vamF2YXNjcmlwdC5ud2JveC5jb20vSUVDb250ZW50TG9hZGVkL1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfdG9wLmRvU2Nyb2xsKFwibGVmdFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVyKCBkb1Njcm9sbENoZWNrLCA1MCApO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgIFxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGRldGFjaCBhbGwgZG9tIHJlYWR5IGV2ZW50c1xuXHQgICAgICAgICAgICAgICAgICAgIGRldGFjaCgpO1xuXHQgICAgXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGV4ZWN1dGUgYW55IHdhaXRpbmcgZnVuY3Rpb25zXG5cdCAgICAgICAgICAgICAgICAgICAgcmVhZHkoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSkoKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBcblx0ICAgIGZ1bmN0aW9uIG9uRG9tUmVhZHkoIGZuICkge1xuXHQgICAgICAgIC8vIElmIERPTSBpcyByZWFkeSwgZXhlY3V0ZSB0aGUgZnVuY3Rpb24gKGFzeW5jKSwgb3RoZXJ3aXNlIHdhaXRcblx0ICAgICAgICBpc1JlYWR5ID8gZGVmZXIoIGZuICkgOiBjYWxsYmFja3MucHVzaCggZm4gKTtcblx0ICAgIH1cblx0ICAgIFxuXHQgICAgLy8gQWRkIHZlcnNpb25cblx0ICAgIG9uRG9tUmVhZHkudmVyc2lvbiA9IFwiMS40LjBcIjtcblx0ICAgIC8vIEFkZCBtZXRob2QgdG8gY2hlY2sgaWYgRE9NIGlzIHJlYWR5XG5cdCAgICBvbkRvbVJlYWR5LmlzUmVhZHkgPSBmdW5jdGlvbigpe1xuXHQgICAgICAgIHJldHVybiBpc1JlYWR5O1xuXHQgICAgfTtcblxuXHQgICAgcmV0dXJuIG9uRG9tUmVhZHk7XG5cdH1cblxuXHRtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgX29uRG9tUmVhZHkod2luZG93KTtcblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vTW9kaWZpZWQgdmVyc2lvbiBvZiBjb21wb25lbnQvcXVlcnlzdHJpbmdcblx0Ly9DaGFuZ2VzOiB1cGRhdGVkIGRlcGVuZGVuY2llcywgZG90IG5vdGF0aW9uIHBhcnNpbmcsIEpTSGludCBmaXhlc1xuXHQvL0ZvcmsgYXQgaHR0cHM6Ly9naXRodWIuY29tL2ltc2t5L3F1ZXJ5c3RyaW5nXG5cblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciBlbmNvZGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XG5cdHZhciBkZWNvZGUgPSBkZWNvZGVVUklDb21wb25lbnQ7XG5cdHZhciB0cmltID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0dmFyIHR5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5cdHZhciBhcnJheVJlZ2V4ID0gLyhcXHcrKVxcWyhcXGQrKVxcXS87XG5cdHZhciBvYmplY3RSZWdleCA9IC9cXHcrXFwuXFx3Ky87XG5cblx0LyoqXG5cdCAqIFBhcnNlIHRoZSBnaXZlbiBxdWVyeSBgc3RyYC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihzdHIpe1xuXHQgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHN0cikgcmV0dXJuIHt9O1xuXG5cdCAgc3RyID0gdHJpbShzdHIpO1xuXHQgIGlmICgnJyA9PT0gc3RyKSByZXR1cm4ge307XG5cdCAgaWYgKCc/JyA9PT0gc3RyLmNoYXJBdCgwKSkgc3RyID0gc3RyLnNsaWNlKDEpO1xuXG5cdCAgdmFyIG9iaiA9IHt9O1xuXHQgIHZhciBwYWlycyA9IHN0ci5zcGxpdCgnJicpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBwYXJ0cyA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG5cdCAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRzWzBdKTtcblx0ICAgIHZhciBtLCBjdHgsIHByb3A7XG5cblx0ICAgIGlmIChtID0gYXJyYXlSZWdleC5leGVjKGtleSkpIHtcblx0ICAgICAgb2JqW21bMV1dID0gb2JqW21bMV1dIHx8IFtdO1xuXHQgICAgICBvYmpbbVsxXV1bbVsyXV0gPSBkZWNvZGUocGFydHNbMV0pO1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKG0gPSBvYmplY3RSZWdleC50ZXN0KGtleSkpIHtcblx0ICAgICAgbSA9IGtleS5zcGxpdCgnLicpO1xuXHQgICAgICBjdHggPSBvYmo7XG5cdCAgICAgIFxuXHQgICAgICB3aGlsZSAobS5sZW5ndGgpIHtcblx0ICAgICAgICBwcm9wID0gbS5zaGlmdCgpO1xuXG5cdCAgICAgICAgaWYgKCFwcm9wLmxlbmd0aCkgY29udGludWU7XG5cblx0ICAgICAgICBpZiAoIWN0eFtwcm9wXSkge1xuXHQgICAgICAgICAgY3R4W3Byb3BdID0ge307XG5cdCAgICAgICAgfSBlbHNlIGlmIChjdHhbcHJvcF0gJiYgdHlwZW9mIGN0eFtwcm9wXSAhPT0gJ29iamVjdCcpIHtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICghbS5sZW5ndGgpIHtcblx0ICAgICAgICAgIGN0eFtwcm9wXSA9IGRlY29kZShwYXJ0c1sxXSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY3R4ID0gY3R4W3Byb3BdO1xuXHQgICAgICB9XG5cblx0ICAgICAgY29udGludWU7XG5cdCAgICB9XG5cblx0ICAgIG9ialtwYXJ0c1swXV0gPSBudWxsID09IHBhcnRzWzFdID8gJycgOiBkZWNvZGUocGFydHNbMV0pO1xuXHQgIH1cblxuXHQgIHJldHVybiBvYmo7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0cmluZ2lmeSB0aGUgZ2l2ZW4gYG9iamAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uKG9iail7XG5cdCAgaWYgKCFvYmopIHJldHVybiAnJztcblx0ICB2YXIgcGFpcnMgPSBbXTtcblxuXHQgIGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0ICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuXG5cdCAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKHZhbHVlKSkge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgcGFpcnMucHVzaChlbmNvZGUoa2V5ICsgJ1snICsgaSArICddJykgKyAnPScgKyBlbmNvZGUodmFsdWVbaV0pKTtcblx0ICAgICAgfVxuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgcGFpcnMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZShvYmpba2V5XSkpO1xuXHQgIH1cblxuXHQgIHJldHVybiBwYWlycy5qb2luKCcmJyk7XG5cdH07XG5cblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxuXHRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0cmltO1xuXG5cdGZ1bmN0aW9uIHRyaW0oc3RyKXtcblx0ICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTtcblx0fVxuXG5cdGV4cG9ydHMubGVmdCA9IGZ1bmN0aW9uKHN0cil7XG5cdCAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKTtcblx0fTtcblxuXHRleHBvcnRzLnJpZ2h0ID0gZnVuY3Rpb24oc3RyKXtcblx0ICByZXR1cm4gc3RyLnJlcGxhY2UoL1xccyokLywgJycpO1xuXHR9O1xuXG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQvKipcblx0ICogdG9TdHJpbmcgcmVmLlxuXHQgKi9cblxuXHR2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIHR5cGUgb2YgYHZhbGAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsKXtcblx0ICBzd2l0Y2ggKHRvU3RyaW5nLmNhbGwodmFsKSkge1xuXHQgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6IHJldHVybiAnZGF0ZSc7XG5cdCAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOiByZXR1cm4gJ3JlZ2V4cCc7XG5cdCAgICBjYXNlICdbb2JqZWN0IEFyZ3VtZW50c10nOiByZXR1cm4gJ2FyZ3VtZW50cyc7XG5cdCAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6IHJldHVybiAnYXJyYXknO1xuXHQgICAgY2FzZSAnW29iamVjdCBFcnJvcl0nOiByZXR1cm4gJ2Vycm9yJztcblx0ICB9XG5cblx0ICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuXHQgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuICd1bmRlZmluZWQnO1xuXHQgIGlmICh2YWwgIT09IHZhbCkgcmV0dXJuICduYW4nO1xuXHQgIGlmICh2YWwgJiYgdmFsLm5vZGVUeXBlID09PSAxKSByZXR1cm4gJ2VsZW1lbnQnO1xuXG5cdCAgaWYgKGlzQnVmZmVyKHZhbCkpIHJldHVybiAnYnVmZmVyJztcblxuXHQgIHZhbCA9IHZhbC52YWx1ZU9mXG5cdCAgICA/IHZhbC52YWx1ZU9mKClcblx0ICAgIDogT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mLmFwcGx5KHZhbCk7XG5cblx0ICByZXR1cm4gdHlwZW9mIHZhbDtcblx0fTtcblxuXHQvLyBjb2RlIGJvcnJvd2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pcy1idWZmZXIvYmxvYi9tYXN0ZXIvaW5kZXguanNcblx0ZnVuY3Rpb24gaXNCdWZmZXIob2JqKSB7XG5cdCAgcmV0dXJuICEhKG9iaiAhPSBudWxsICYmXG5cdCAgICAob2JqLl9pc0J1ZmZlciB8fCAvLyBGb3IgU2FmYXJpIDUtNyAobWlzc2luZyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yKVxuXHQgICAgICAob2JqLmNvbnN0cnVjdG9yICYmXG5cdCAgICAgIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcblx0ICAgICAgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaikpXG5cdCAgICApKVxuXHR9XG5cblxuLyoqKi8gfSxcbi8qIDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdHZhciBTY2VuZUdyYXBoID0gZnVuY3Rpb24oc2NlbmVQcm9wZXJ0aWVzKSB7XG5cdCAgICB2YXIgbm9kZUNvdW50ID0gMTtcblxuXHQgICAgLy90b2RvOiBtb3ZlIG1lcmdlIHRvIGhlbHBlcnMgc2VjdGlvblxuXHQgICAgZnVuY3Rpb24gbWVyZ2UocGFyZW50LCBjaGlsZCkge1xuXHQgICAgICAgIGZvciAodmFyIHByb3AgaW4gY2hpbGQpIHtcblx0ICAgICAgICAgICAgcGFyZW50W3Byb3BdID0gY2hpbGRbcHJvcF07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBwYXJlbnQ7XG5cdCAgICB9XG5cblx0ICAgIHZhciBTY2VuZU5vZGUgPSBmdW5jdGlvbihuYW1lKSB7XG5cdCAgICAgICAgbm9kZUNvdW50Kys7XG5cdCAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuXHQgICAgICAgIHRoaXMuY2hpbGRyZW4gPSB7fTtcblx0ICAgICAgICB0aGlzLmlkID0gbm9kZUNvdW50O1xuXHQgICAgICAgIHRoaXMubmFtZSA9ICduJyArIG5vZGVDb3VudDtcblx0ICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMueCA9IHRoaXMueSA9IHRoaXMueiA9IDA7XG5cdCAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcblx0ICAgIH07XG5cblx0ICAgIFNjZW5lTm9kZS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHQgICAgICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGhlaWdodCAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIFNjZW5lTm9kZS5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24oeCwgeSwgeikge1xuXHQgICAgICAgIHRoaXMueCA9IHggIT0gbnVsbCA/IHggOiB0aGlzLng7XG5cdCAgICAgICAgdGhpcy55ID0geSAhPSBudWxsID8geSA6IHRoaXMueTtcblx0ICAgICAgICB0aGlzLnogPSB6ICE9IG51bGwgPyB6IDogdGhpcy56O1xuXHQgICAgfTtcblxuXHQgICAgU2NlbmVOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihjaGlsZCkge1xuXHQgICAgICAgIHZhciBuYW1lID0gY2hpbGQubmFtZTtcblx0ICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2hpbGRyZW5bbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bbmFtZV0gPSBjaGlsZDtcblx0ICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0aHJvdyAnU2NlbmVHcmFwaDogY2hpbGQgYWxyZWFkeSBleGlzdHM6ICcgKyBuYW1lO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIHZhciBSb290Tm9kZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIFNjZW5lTm9kZS5jYWxsKHRoaXMsICdyb290Jyk7XG5cdCAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gc2NlbmVQcm9wZXJ0aWVzO1xuXHQgICAgfTtcblxuXHQgICAgUm9vdE5vZGUucHJvdG90eXBlID0gbmV3IFNjZW5lTm9kZSgpO1xuXG5cdCAgICB2YXIgU2hhcGUgPSBmdW5jdGlvbihuYW1lLCBwcm9wcykge1xuXHQgICAgICAgIFNjZW5lTm9kZS5jYWxsKHRoaXMsIG5hbWUpO1xuXHQgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHtcblx0ICAgICAgICAgICAgJ2ZpbGwnOiAnIzAwMDAwMCdcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGlmICh0eXBlb2YgcHJvcHMgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgICAgIG1lcmdlKHRoaXMucHJvcGVydGllcywgcHJvcHMpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICB0aHJvdyAnU2NlbmVHcmFwaDogaW52YWxpZCBub2RlIG5hbWUnO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIFNoYXBlLnByb3RvdHlwZSA9IG5ldyBTY2VuZU5vZGUoKTtcblxuXHQgICAgdmFyIEdyb3VwID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICB0aGlzLnR5cGUgPSAnZ3JvdXAnO1xuXHQgICAgfTtcblxuXHQgICAgR3JvdXAucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5cblx0ICAgIHZhciBSZWN0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICB0aGlzLnR5cGUgPSAncmVjdCc7XG5cdCAgICB9O1xuXG5cdCAgICBSZWN0LnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuXG5cdCAgICB2YXIgVGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcblx0ICAgICAgICBTaGFwZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgIHRoaXMudHlwZSA9ICd0ZXh0Jztcblx0ICAgICAgICB0aGlzLnByb3BlcnRpZXMudGV4dCA9IHRleHQ7XG5cdCAgICB9O1xuXG5cdCAgICBUZXh0LnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuXG5cdCAgICB2YXIgcm9vdCA9IG5ldyBSb290Tm9kZSgpO1xuXG5cdCAgICB0aGlzLlNoYXBlID0ge1xuXHQgICAgICAgICdSZWN0JzogUmVjdCxcblx0ICAgICAgICAnVGV4dCc6IFRleHQsXG5cdCAgICAgICAgJ0dyb3VwJzogR3JvdXBcblx0ICAgIH07XG5cblx0ICAgIHRoaXMucm9vdCA9IHJvb3Q7XG5cdCAgICByZXR1cm4gdGhpcztcblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IFNjZW5lR3JhcGg7XG5cblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcblx0ICogU2hhbGxvdyBvYmplY3QgY2xvbmUgYW5kIG1lcmdlXG5cdCAqXG5cdCAqIEBwYXJhbSBhIE9iamVjdCBBXG5cdCAqIEBwYXJhbSBiIE9iamVjdCBCXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3Qgd2l0aCBhbGwgb2YgQSdzIHByb3BlcnRpZXMsIGFuZCBhbGwgb2YgQidzIHByb3BlcnRpZXMsIG92ZXJ3cml0aW5nIEEncyBwcm9wZXJ0aWVzXG5cdCAqL1xuXHRleHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgIHZhciBjID0ge307XG5cdCAgICBmb3IgKHZhciB4IGluIGEpIHtcblx0ICAgICAgICBpZiAoYS5oYXNPd25Qcm9wZXJ0eSh4KSkge1xuXHQgICAgICAgICAgICBjW3hdID0gYVt4XTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAoYiAhPSBudWxsKSB7XG5cdCAgICAgICAgZm9yICh2YXIgeSBpbiBiKSB7XG5cdCAgICAgICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KHkpKSB7XG5cdCAgICAgICAgICAgICAgICBjW3ldID0gYlt5XTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBjO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUYWtlcyBhIGsvdiBsaXN0IG9mIENTUyBwcm9wZXJ0aWVzIGFuZCByZXR1cm5zIGEgcnVsZVxuXHQgKlxuXHQgKiBAcGFyYW0gcHJvcHMgQ1NTIHByb3BlcnRpZXMgb2JqZWN0XG5cdCAqL1xuXHRleHBvcnRzLmNzc1Byb3BzID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0ICAgIHZhciByZXQgPSBbXTtcblx0ICAgIGZvciAodmFyIHAgaW4gcHJvcHMpIHtcblx0ICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkocCkpIHtcblx0ICAgICAgICAgICAgcmV0LnB1c2gocCArICc6JyArIHByb3BzW3BdKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmV0LmpvaW4oJzsnKTtcblx0fTtcblxuXHQvKipcblx0ICogRW5jb2RlcyBIVE1MIGVudGl0aWVzIGluIGEgc3RyaW5nXG5cdCAqXG5cdCAqIEBwYXJhbSBzdHIgSW5wdXQgc3RyaW5nXG5cdCAqL1xuXHRleHBvcnRzLmVuY29kZUh0bWxFbnRpdHkgPSBmdW5jdGlvbihzdHIpIHtcblx0ICAgIHZhciBidWYgPSBbXTtcblx0ICAgIHZhciBjaGFyQ29kZSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gc3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdCAgICAgICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcblx0ICAgICAgICBpZiAoY2hhckNvZGUgPiAxMjgpIHtcblx0ICAgICAgICAgICAgYnVmLnVuc2hpZnQoWycmIycsIGNoYXJDb2RlLCAnOyddLmpvaW4oJycpKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBidWYudW5zaGlmdChzdHJbaV0pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBidWYuam9pbignJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiBhbiBpbWFnZSBleGlzdHNcblx0ICpcblx0ICogQHBhcmFtIHNyYyBVUkwgb2YgaW1hZ2Vcblx0ICogQHBhcmFtIGNhbGxiYWNrIENhbGxiYWNrIHRvIGNhbGwgb25jZSBpbWFnZSBzdGF0dXMgaGFzIGJlZW4gZm91bmRcblx0ICovXG5cdGV4cG9ydHMuaW1hZ2VFeGlzdHMgPSBmdW5jdGlvbihzcmMsIGNhbGxiYWNrKSB7XG5cdCAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcblx0ICAgIGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcblx0ICAgIH07XG5cdCAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHRydWUpO1xuXHQgICAgfTtcblx0ICAgIGltYWdlLnNyYyA9IHNyYztcblx0fTtcblxuXHQvKipcblx0ICogRGVjb2RlcyBIVE1MIGVudGl0aWVzIGluIGEgc3RyaW5nXG5cdCAqXG5cdCAqIEBwYXJhbSBzdHIgSW5wdXQgc3RyaW5nXG5cdCAqL1xuXHRleHBvcnRzLmRlY29kZUh0bWxFbnRpdHkgPSBmdW5jdGlvbihzdHIpIHtcblx0ICAgIHJldHVybiBzdHIucmVwbGFjZSgvJiMoXFxkKyk7L2csIGZ1bmN0aW9uKG1hdGNoLCBkZWMpIHtcblx0ICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShkZWMpO1xuXHQgICAgfSk7XG5cdH07XG5cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBlbGVtZW50J3MgZGltZW5zaW9ucyBpZiBpdCdzIHZpc2libGUsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuXHQgKlxuXHQgKiBAcGFyYW0gZWwgRE9NIGVsZW1lbnRcblx0ICovXG5cdGV4cG9ydHMuZGltZW5zaW9uQ2hlY2sgPSBmdW5jdGlvbihlbCkge1xuXHQgICAgdmFyIGRpbWVuc2lvbnMgPSB7XG5cdCAgICAgICAgaGVpZ2h0OiBlbC5jbGllbnRIZWlnaHQsXG5cdCAgICAgICAgd2lkdGg6IGVsLmNsaWVudFdpZHRoXG5cdCAgICB9O1xuXG5cdCAgICBpZiAoZGltZW5zaW9ucy5oZWlnaHQgJiYgZGltZW5zaW9ucy53aWR0aCkge1xuXHQgICAgICAgIHJldHVybiBkaW1lbnNpb25zO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdH07XG5cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIHRydXRoeSBvciBpZiBpdCBpcyBcInNlbWFudGljYWxseSB0cnV0aHlcIlxuXHQgKiBAcGFyYW0gdmFsXG5cdCAqL1xuXHRleHBvcnRzLnRydXRoeSA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbCA9PT0gJ3RydWUnIHx8IHZhbCA9PT0gJ3llcycgfHwgdmFsID09PSAnMScgfHwgdmFsID09PSAnb24nIHx8IHZhbCA9PT0gJ+Kckyc7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gISF2YWw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhcnNlcyBpbnB1dCBpbnRvIGEgd2VsbC1mb3JtZWQgQ1NTIGNvbG9yXG5cdCAqIEBwYXJhbSB2YWxcblx0ICovXG5cdGV4cG9ydHMucGFyc2VDb2xvciA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgdmFyIGhleHJlID0gLyheKD86Iz8pWzAtOWEtZl17Nn0kKXwoXig/OiM/KVswLTlhLWZdezN9JCkvaTtcblx0ICAgIHZhciByZ2JyZSA9IC9ecmdiXFwoKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKlxcKSQvO1xuXHQgICAgdmFyIHJnYmFyZSA9IC9ecmdiYVxcKChcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccyosXFxzKigwXFwuXFxkezEsfXwxKVxcKSQvO1xuXG5cdCAgICB2YXIgbWF0Y2ggPSB2YWwubWF0Y2goaGV4cmUpO1xuXHQgICAgdmFyIHJldHZhbDtcblxuXHQgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dmFsID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl07XG5cdCAgICAgICAgaWYgKHJldHZhbFswXSAhPT0gJyMnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAnIycgKyByZXR2YWw7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIG1hdGNoID0gdmFsLm1hdGNoKHJnYnJlKTtcblxuXHQgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dmFsID0gJ3JnYignICsgbWF0Y2guc2xpY2UoMSkuam9pbignLCcpICsgJyknO1xuXHQgICAgICAgIHJldHVybiByZXR2YWw7XG5cdCAgICB9XG5cblx0ICAgIG1hdGNoID0gdmFsLm1hdGNoKHJnYmFyZSk7XG5cblx0ICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuXHQgICAgICAgIHJldHZhbCA9ICdyZ2JhKCcgKyBtYXRjaC5zbGljZSgxKS5qb2luKCcsJykgKyAnKSc7XG5cdCAgICAgICAgcmV0dXJuIHJldHZhbDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFByb3ZpZGVzIHRoZSBjb3JyZWN0IHNjYWxpbmcgcmF0aW8gZm9yIGNhbnZhcyBkcmF3aW5nIG9wZXJhdGlvbnMgb24gSGlEUEkgc2NyZWVucyAoZS5nLiBSZXRpbmEgZGlzcGxheXMpXG5cdCAqL1xuXHRleHBvcnRzLmNhbnZhc1JhdGlvID0gZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSAxO1xuXHQgICAgdmFyIGJhY2tpbmdTdG9yZVJhdGlvID0gMTtcblxuXHQgICAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuXHQgICAgICAgIHZhciBjYW52YXMgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdCAgICAgICAgaWYgKGNhbnZhcy5nZXRDb250ZXh0KSB7XG5cdCAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0ICAgICAgICAgICAgZGV2aWNlUGl4ZWxSYXRpbyA9IGdsb2JhbC5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cdCAgICAgICAgICAgIGJhY2tpbmdTdG9yZVJhdGlvID0gY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG5cdH07XG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSxcbi8qIDggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHt2YXIgRE9NID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxuXHR2YXIgU1ZHX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblx0dmFyIE5PREVfVFlQRV9DT01NRU5UID0gODtcblxuXHQvKipcblx0ICogR2VuZXJpYyBTVkcgZWxlbWVudCBjcmVhdGlvbiBmdW5jdGlvblxuXHQgKlxuXHQgKiBAcGFyYW0gc3ZnIFNWRyBjb250ZXh0LCBzZXQgdG8gbnVsbCBpZiBuZXdcblx0ICogQHBhcmFtIHdpZHRoIERvY3VtZW50IHdpZHRoXG5cdCAqIEBwYXJhbSBoZWlnaHQgRG9jdW1lbnQgaGVpZ2h0XG5cdCAqL1xuXHRleHBvcnRzLmluaXRTVkcgPSBmdW5jdGlvbihzdmcsIHdpZHRoLCBoZWlnaHQpIHtcblx0ICAgIHZhciBkZWZzLCBzdHlsZSwgaW5pdGlhbGl6ZSA9IGZhbHNlO1xuXG5cdCAgICBpZiAoc3ZnICYmIHN2Zy5xdWVyeVNlbGVjdG9yKSB7XG5cdCAgICAgICAgc3R5bGUgPSBzdmcucXVlcnlTZWxlY3Rvcignc3R5bGUnKTtcblx0ICAgICAgICBpZiAoc3R5bGUgPT09IG51bGwpIHtcblx0ICAgICAgICAgICAgaW5pdGlhbGl6ZSA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBzdmcgPSBET00ubmV3RWwoJ3N2ZycsIFNWR19OUyk7XG5cdCAgICAgICAgaW5pdGlhbGl6ZSA9IHRydWU7XG5cdCAgICB9XG5cblx0ICAgIGlmIChpbml0aWFsaXplKSB7XG5cdCAgICAgICAgZGVmcyA9IERPTS5uZXdFbCgnZGVmcycsIFNWR19OUyk7XG5cdCAgICAgICAgc3R5bGUgPSBET00ubmV3RWwoJ3N0eWxlJywgU1ZHX05TKTtcblx0ICAgICAgICBET00uc2V0QXR0cihzdHlsZSwge1xuXHQgICAgICAgICAgICAndHlwZSc6ICd0ZXh0L2Nzcydcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBkZWZzLmFwcGVuZENoaWxkKHN0eWxlKTtcblx0ICAgICAgICBzdmcuYXBwZW5kQ2hpbGQoZGVmcyk7XG5cdCAgICB9XG5cblx0ICAgIC8vSUUgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGlzIGlzIHNldCBhbmQgQ2hyb21lIHJlcXVpcmVzIGl0IHRvIGJlIHNldFxuXHQgICAgaWYgKHN2Zy53ZWJraXRNYXRjaGVzU2VsZWN0b3IpIHtcblx0ICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCd4bWxucycsIFNWR19OUyk7XG5cdCAgICB9XG5cblx0ICAgIC8vUmVtb3ZlIGNvbW1lbnQgbm9kZXNcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ZnLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBpZiAoc3ZnLmNoaWxkTm9kZXNbaV0ubm9kZVR5cGUgPT09IE5PREVfVFlQRV9DT01NRU5UKSB7XG5cdCAgICAgICAgICAgIHN2Zy5yZW1vdmVDaGlsZChzdmcuY2hpbGROb2Rlc1tpXSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICAvL1JlbW92ZSBDU1Ncblx0ICAgIHdoaWxlIChzdHlsZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuXHQgICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmNoaWxkTm9kZXNbMF0pO1xuXHQgICAgfVxuXG5cdCAgICBET00uc2V0QXR0cihzdmcsIHtcblx0ICAgICAgICAnd2lkdGgnOiB3aWR0aCxcblx0ICAgICAgICAnaGVpZ2h0JzogaGVpZ2h0LFxuXHQgICAgICAgICd2aWV3Qm94JzogJzAgMCAnICsgd2lkdGggKyAnICcgKyBoZWlnaHQsXG5cdCAgICAgICAgJ3ByZXNlcnZlQXNwZWN0UmF0aW8nOiAnbm9uZSdcblx0ICAgIH0pO1xuXG5cdCAgICByZXR1cm4gc3ZnO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBzZXJpYWxpemVkIFNWRyB0byBhIHN0cmluZyBzdWl0YWJsZSBmb3IgZGF0YSBVUkkgdXNlXG5cdCAqIEBwYXJhbSBzdmdTdHJpbmcgU2VyaWFsaXplZCBTVkcgc3RyaW5nXG5cdCAqIEBwYXJhbSBbYmFzZTY0XSBVc2UgYmFzZTY0IGVuY29kaW5nIGZvciBkYXRhIFVSSVxuXHQgKi9cblx0ZXhwb3J0cy5zdmdTdHJpbmdUb0RhdGFVUkkgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciByYXdQcmVmaXggPSAnZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9VVRGLTgsJztcblx0ICAgIHZhciBiYXNlNjRQcmVmaXggPSAnZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9VVRGLTg7YmFzZTY0LCc7XG5cblx0ICAgIHJldHVybiBmdW5jdGlvbihzdmdTdHJpbmcsIGJhc2U2NCkge1xuXHQgICAgICAgIGlmIChiYXNlNjQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGJhc2U2NFByZWZpeCArIGJ0b2EoZ2xvYmFsLnVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdmdTdHJpbmcpKSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHJhd1ByZWZpeCArIGVuY29kZVVSSUNvbXBvbmVudChzdmdTdHJpbmcpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdH0oKTtcblxuXHQvKipcblx0ICogUmV0dXJucyBzZXJpYWxpemVkIFNWRyB3aXRoIFhNTCBwcm9jZXNzaW5nIGluc3RydWN0aW9uc1xuXHQgKlxuXHQgKiBAcGFyYW0gc3ZnIFNWRyBjb250ZXh0XG5cdCAqIEBwYXJhbSBzdHlsZXNoZWV0cyBDU1Mgc3R5bGVzaGVldHMgdG8gaW5jbHVkZVxuXHQgKi9cblx0ZXhwb3J0cy5zZXJpYWxpemVTVkcgPSBmdW5jdGlvbihzdmcsIGVuZ2luZVNldHRpbmdzKSB7XG5cdCAgICBpZiAoIWdsb2JhbC5YTUxTZXJpYWxpemVyKSByZXR1cm47XG5cdCAgICB2YXIgc2VyaWFsaXplciA9IG5ldyBYTUxTZXJpYWxpemVyKCk7XG5cdCAgICB2YXIgc3ZnQ1NTID0gJyc7XG5cdCAgICB2YXIgc3R5bGVzaGVldHMgPSBlbmdpbmVTZXR0aW5ncy5zdHlsZXNoZWV0cztcblxuXHQgICAgLy9FeHRlcm5hbCBzdHlsZXNoZWV0czogUHJvY2Vzc2luZyBJbnN0cnVjdGlvbiBtZXRob2Rcblx0ICAgIGlmIChlbmdpbmVTZXR0aW5ncy5zdmdYTUxTdHlsZXNoZWV0KSB7XG5cdCAgICAgICAgdmFyIHhtbCA9IERPTS5jcmVhdGVYTUwoKTtcblx0ICAgICAgICAvL0FkZCA8P3htbC1zdHlsZXNoZWV0ID8+IGRpcmVjdGl2ZXNcblx0ICAgICAgICBmb3IgKHZhciBpID0gc3R5bGVzaGVldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICAgICAgdmFyIGNzc3BpID0geG1sLmNyZWF0ZVByb2Nlc3NpbmdJbnN0cnVjdGlvbigneG1sLXN0eWxlc2hlZXQnLCAnaHJlZj1cIicgKyBzdHlsZXNoZWV0c1tpXSArICdcIiByZWw9XCJzdHlsZXNoZWV0XCInKTtcblx0ICAgICAgICAgICAgeG1sLmluc2VydEJlZm9yZShjc3NwaSwgeG1sLmZpcnN0Q2hpbGQpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHhtbC5yZW1vdmVDaGlsZCh4bWwuZG9jdW1lbnRFbGVtZW50KTtcblx0ICAgICAgICBzdmdDU1MgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKHhtbCk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBzdmdUZXh0ID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhzdmcpO1xuXHQgICAgc3ZnVGV4dCA9IHN2Z1RleHQucmVwbGFjZSgvXFwmYW1wOyhcXCNbMC05XXsyLH1cXDspL2csICcmJDEnKTtcblx0ICAgIHJldHVybiBzdmdDU1MgKyBzdmdUZXh0O1xuXHR9O1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSxcbi8qIDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcblx0ICogR2VuZXJpYyBuZXcgRE9NIGVsZW1lbnQgZnVuY3Rpb25cblx0ICpcblx0ICogQHBhcmFtIHRhZyBUYWcgdG8gY3JlYXRlXG5cdCAqIEBwYXJhbSBuYW1lc3BhY2UgT3B0aW9uYWwgbmFtZXNwYWNlIHZhbHVlXG5cdCAqL1xuXHRleHBvcnRzLm5ld0VsID0gZnVuY3Rpb24odGFnLCBuYW1lc3BhY2UpIHtcblx0ICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSByZXR1cm47XG5cblx0ICAgIGlmIChuYW1lc3BhY2UgPT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZyk7XG5cdCAgICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEdlbmVyaWMgc2V0QXR0cmlidXRlIGZ1bmN0aW9uXG5cdCAqXG5cdCAqIEBwYXJhbSBlbCBSZWZlcmVuY2UgdG8gRE9NIGVsZW1lbnRcblx0ICogQHBhcmFtIGF0dHJzIE9iamVjdCB3aXRoIGF0dHJpYnV0ZSBrZXlzIGFuZCB2YWx1ZXNcblx0ICovXG5cdGV4cG9ydHMuc2V0QXR0ciA9IGZ1bmN0aW9uIChlbCwgYXR0cnMpIHtcblx0ICAgIGZvciAodmFyIGEgaW4gYXR0cnMpIHtcblx0ICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYSwgYXR0cnNbYV0pO1xuXHQgICAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgWE1MIGRvY3VtZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRleHBvcnRzLmNyZWF0ZVhNTCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgaWYgKCFnbG9iYWwuRE9NUGFyc2VyKSByZXR1cm47XG5cdCAgICByZXR1cm4gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZygnPHhtbCAvPicsICdhcHBsaWNhdGlvbi94bWwnKTtcblx0fTtcblxuXHQvKipcblx0ICogQ29udmVydHMgYSB2YWx1ZSBpbnRvIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuXHQgKlxuXHQgKiBAcGFyYW0gdmFsIEEgc3RyaW5nLCBhIE5vZGVMaXN0LCBhIE5vZGUsIG9yIGFuIEhUTUxDb2xsZWN0aW9uXG5cdCAqL1xuXHRleHBvcnRzLmdldE5vZGVBcnJheSA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgdmFyIHJldHZhbCA9IG51bGw7XG5cdCAgICBpZiAodHlwZW9mKHZhbCkgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICByZXR2YWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHZhbCk7XG5cdCAgICB9IGVsc2UgaWYgKGdsb2JhbC5Ob2RlTGlzdCAmJiB2YWwgaW5zdGFuY2VvZiBnbG9iYWwuTm9kZUxpc3QpIHtcblx0ICAgICAgICByZXR2YWwgPSB2YWw7XG5cdCAgICB9IGVsc2UgaWYgKGdsb2JhbC5Ob2RlICYmIHZhbCBpbnN0YW5jZW9mIGdsb2JhbC5Ob2RlKSB7XG5cdCAgICAgICAgcmV0dmFsID0gW3ZhbF07XG5cdCAgICB9IGVsc2UgaWYgKGdsb2JhbC5IVE1MQ29sbGVjdGlvbiAmJiB2YWwgaW5zdGFuY2VvZiBnbG9iYWwuSFRNTENvbGxlY3Rpb24pIHtcblx0ICAgICAgICByZXR2YWwgPSB2YWw7XG5cdCAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdCAgICAgICAgcmV0dmFsID0gdmFsO1xuXHQgICAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwpIHtcblx0ICAgICAgICByZXR2YWwgPSBbXTtcblx0ICAgIH1cblxuXHQgICAgcmV0dmFsID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwocmV0dmFsKTtcblxuXHQgICAgcmV0dXJuIHJldHZhbDtcblx0fTtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXG5cbi8qKiovIH0sXG4vKiAxMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0dmFyIENvbG9yID0gZnVuY3Rpb24oY29sb3IsIG9wdGlvbnMpIHtcblx0ICAgIC8vdG9kbzogc3VwcG9ydCByZ2JhLCBoc2xhLCBhbmQgcnJnZ2JiYWEgbm90YXRpb25cblx0ICAgIC8vdG9kbzogdXNlIENJRUxBQiBpbnRlcm5hbGx5XG5cdCAgICAvL3RvZG86IGFkZCBjbGFtcCBmdW5jdGlvbiAod2l0aCBzaWduKVxuXHQgICAgaWYgKHR5cGVvZiBjb2xvciAhPT0gJ3N0cmluZycpIHJldHVybjtcblxuXHQgICAgdGhpcy5vcmlnaW5hbCA9IGNvbG9yO1xuXG5cdCAgICBpZiAoY29sb3IuY2hhckF0KDApID09PSAnIycpIHtcblx0ICAgICAgICBjb2xvciA9IGNvbG9yLnNsaWNlKDEpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoL1teYS1mMC05XSsvaS50ZXN0KGNvbG9yKSkgcmV0dXJuO1xuXG5cdCAgICBpZiAoY29sb3IubGVuZ3RoID09PSAzKSB7XG5cdCAgICAgICAgY29sb3IgPSBjb2xvci5yZXBsYWNlKC8uL2csICckJiQmJyk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChjb2xvci5sZW5ndGggIT09IDYpIHJldHVybjtcblxuXHQgICAgdGhpcy5hbHBoYSA9IDE7XG5cblx0ICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxwaGEpIHtcblx0ICAgICAgICB0aGlzLmFscGhhID0gb3B0aW9ucy5hbHBoYTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5zZXQocGFyc2VJbnQoY29sb3IsIDE2KSk7XG5cdH07XG5cblx0Ly90b2RvOiBqc2RvY3Ncblx0Q29sb3IucmdiMmhleCA9IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblx0ICAgIGZ1bmN0aW9uIGZvcm1hdCAoZGVjaW1hbCkge1xuXHQgICAgICAgIHZhciBoZXggPSAoZGVjaW1hbCB8IDApLnRvU3RyaW5nKDE2KTtcblx0ICAgICAgICBpZiAoZGVjaW1hbCA8IDE2KSB7XG5cdCAgICAgICAgICAgIGhleCA9ICcwJyArIGhleDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGhleDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIFtyLCBnLCBiXS5tYXAoZm9ybWF0KS5qb2luKCcnKTtcblx0fTtcblxuXHQvL3RvZG86IGpzZG9jc1xuXHRDb2xvci5oc2wycmdiID0gZnVuY3Rpb24gKGgsIHMsIGwpIHtcblx0ICAgIHZhciBIID0gaCAvIDYwO1xuXHQgICAgdmFyIEMgPSAoMSAtIE1hdGguYWJzKDIgKiBsIC0gMSkpICogcztcblx0ICAgIHZhciBYID0gQyAqICgxIC0gTWF0aC5hYnMocGFyc2VJbnQoSCkgJSAyIC0gMSkpO1xuXHQgICAgdmFyIG0gPSBsIC0gKEMgLyAyKTtcblxuXHQgICAgdmFyIHIgPSAwLCBnID0gMCwgYiA9IDA7XG5cblx0ICAgIGlmIChIID49IDAgJiYgSCA8IDEpIHtcblx0ICAgICAgICByID0gQztcblx0ICAgICAgICBnID0gWDtcblx0ICAgIH0gZWxzZSBpZiAoSCA+PSAxICYmIEggPCAyKSB7XG5cdCAgICAgICAgciA9IFg7XG5cdCAgICAgICAgZyA9IEM7XG5cdCAgICB9IGVsc2UgaWYgKEggPj0gMiAmJiBIIDwgMykge1xuXHQgICAgICAgIGcgPSBDO1xuXHQgICAgICAgIGIgPSBYO1xuXHQgICAgfSBlbHNlIGlmIChIID49IDMgJiYgSCA8IDQpIHtcblx0ICAgICAgICBnID0gWDtcblx0ICAgICAgICBiID0gQztcblx0ICAgIH0gZWxzZSBpZiAoSCA+PSA0ICYmIEggPCA1KSB7XG5cdCAgICAgICAgciA9IFg7XG5cdCAgICAgICAgYiA9IEM7XG5cdCAgICB9IGVsc2UgaWYgKEggPj0gNSAmJiBIIDwgNikge1xuXHQgICAgICAgIHIgPSBDO1xuXHQgICAgICAgIGIgPSBYO1xuXHQgICAgfVxuXG5cdCAgICByICs9IG07XG5cdCAgICBnICs9IG07XG5cdCAgICBiICs9IG07XG5cblx0ICAgIHIgPSBwYXJzZUludChyICogMjU1KTtcblx0ICAgIGcgPSBwYXJzZUludChnICogMjU1KTtcblx0ICAgIGIgPSBwYXJzZUludChiICogMjU1KTtcblxuXHQgICAgcmV0dXJuIFtyLCBnLCBiXTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgY29sb3IgZnJvbSBhIHJhdyBSR0I4ODggaW50ZWdlclxuXHQgKiBAcGFyYW0gcmF3IFJHQjg4OCByZXByZXNlbnRhdGlvbiBvZiBjb2xvclxuXHQgKi9cblx0Ly90b2RvOiByZWZhY3RvciBpbnRvIGEgc3RhdGljIG1ldGhvZFxuXHQvL3RvZG86IGZhY3RvciBvdXQgaW5kaXZpZHVhbCBjb2xvciBzcGFjZXNcblx0Ly90b2RvOiBhZGQgSFNMLCBDSUVMQUIsIGFuZCBDSUVMVVZcblx0Q29sb3IucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWwpIHtcblx0ICAgIHRoaXMucmF3ID0gdmFsO1xuXG5cdCAgICB2YXIgciA9ICh0aGlzLnJhdyAmIDB4RkYwMDAwKSA+PiAxNjtcblx0ICAgIHZhciBnID0gKHRoaXMucmF3ICYgMHgwMEZGMDApID4+IDg7XG5cdCAgICB2YXIgYiA9ICh0aGlzLnJhdyAmIDB4MDAwMEZGKTtcblxuXHQgICAgLy8gQlQuNzA5XG5cdCAgICB2YXIgeSA9IDAuMjEyNiAqIHIgKyAwLjcxNTIgKiBnICsgMC4wNzIyICogYjtcblx0ICAgIHZhciB1ID0gLTAuMDk5OTEgKiByIC0gMC4zMzYwOSAqIGcgKyAwLjQzNiAqIGI7XG5cdCAgICB2YXIgdiA9IDAuNjE1ICogciAtIDAuNTU4NjEgKiBnIC0gMC4wNTYzOSAqIGI7XG5cblx0ICAgIHRoaXMucmdiID0ge1xuXHQgICAgICAgIHI6IHIsXG5cdCAgICAgICAgZzogZyxcblx0ICAgICAgICBiOiBiXG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLnl1diA9IHtcblx0ICAgICAgICB5OiB5LFxuXHQgICAgICAgIHU6IHUsXG5cdCAgICAgICAgdjogdlxuXHQgICAgfTtcblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIExpZ2h0ZW4gb3IgZGFya2VuIGEgY29sb3Jcblx0ICogQHBhcmFtIG11bHRpcGxpZXIgQW1vdW50IHRvIGxpZ2h0ZW4gb3IgZGFya2VuICgtMSB0byAxKVxuXHQgKi9cblx0Q29sb3IucHJvdG90eXBlLmxpZ2h0ZW4gPSBmdW5jdGlvbihtdWx0aXBsaWVyKSB7XG5cdCAgICB2YXIgY20gPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBNYXRoLmFicyhtdWx0aXBsaWVyKSkpICogKG11bHRpcGxpZXIgPCAwID8gLTEgOiAxKTtcblx0ICAgIHZhciBibSA9ICgyNTUgKiBjbSkgfCAwO1xuXHQgICAgdmFyIGNyID0gTWF0aC5taW4oMjU1LCBNYXRoLm1heCgwLCB0aGlzLnJnYi5yICsgYm0pKTtcblx0ICAgIHZhciBjZyA9IE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMCwgdGhpcy5yZ2IuZyArIGJtKSk7XG5cdCAgICB2YXIgY2IgPSBNYXRoLm1pbigyNTUsIE1hdGgubWF4KDAsIHRoaXMucmdiLmIgKyBibSkpO1xuXHQgICAgdmFyIGhleCA9IENvbG9yLnJnYjJoZXgoY3IsIGNnLCBjYik7XG5cdCAgICByZXR1cm4gbmV3IENvbG9yKGhleCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIE91dHB1dCBjb2xvciBpbiBoZXggZm9ybWF0XG5cdCAqIEBwYXJhbSBhZGRIYXNoIEFkZCBhIGhhc2ggY2hhcmFjdGVyIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG91dHB1dFxuXHQgKi9cblx0Q29sb3IucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24oYWRkSGFzaCkge1xuXHQgICAgcmV0dXJuIChhZGRIYXNoID8gJyMnIDogJycpICsgdGhpcy5yYXcudG9TdHJpbmcoMTYpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGN1cnJlbnQgY29sb3IgaXMgbGlnaHRlciB0aGFuIGFub3RoZXIgY29sb3Jcblx0ICogQHBhcmFtIGNvbG9yIENvbG9yIHRvIGNvbXBhcmUgYWdhaW5zdFxuXHQgKi9cblx0Q29sb3IucHJvdG90eXBlLmxpZ2h0ZXJUaGFuID0gZnVuY3Rpb24oY29sb3IpIHtcblx0ICAgIGlmICghKGNvbG9yIGluc3RhbmNlb2YgQ29sb3IpKSB7XG5cdCAgICAgICAgY29sb3IgPSBuZXcgQ29sb3IoY29sb3IpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy55dXYueSA+IGNvbG9yLnl1di55O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgbWl4aW5nIGN1cnJlbnQgY29sb3Igd2l0aCBhbm90aGVyIGNvbG9yXG5cdCAqIEBwYXJhbSBjb2xvciBDb2xvciB0byBtaXggd2l0aFxuXHQgKiBAcGFyYW0gbXVsdGlwbGllciBIb3cgbXVjaCB0byBtaXggd2l0aCB0aGUgb3RoZXIgY29sb3Jcblx0ICovXG5cdC8qXG5cdENvbG9yLnByb3RvdHlwZS5taXggPSBmdW5jdGlvbiAoY29sb3IsIG11bHRpcGxpZXIpIHtcblx0ICAgIGlmICghKGNvbG9yIGluc3RhbmNlb2YgQ29sb3IpKSB7XG5cdCAgICAgICAgY29sb3IgPSBuZXcgQ29sb3IoY29sb3IpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgciA9IHRoaXMucmdiLnI7XG5cdCAgICB2YXIgZyA9IHRoaXMucmdiLmc7XG5cdCAgICB2YXIgYiA9IHRoaXMucmdiLmI7XG5cdCAgICB2YXIgYSA9IHRoaXMuYWxwaGE7XG5cblx0ICAgIHZhciBtID0gdHlwZW9mIG11bHRpcGxpZXIgIT09ICd1bmRlZmluZWQnID8gbXVsdGlwbGllciA6IDAuNTtcblxuXHQgICAgLy90b2RvOiB3cml0ZSBhIGxlcnAgZnVuY3Rpb25cblx0ICAgIHIgPSByICsgbSAqIChjb2xvci5yZ2IuciAtIHIpO1xuXHQgICAgZyA9IGcgKyBtICogKGNvbG9yLnJnYi5nIC0gZyk7XG5cdCAgICBiID0gYiArIG0gKiAoY29sb3IucmdiLmIgLSBiKTtcblx0ICAgIGEgPSBhICsgbSAqIChjb2xvci5hbHBoYSAtIGEpO1xuXG5cdCAgICByZXR1cm4gbmV3IENvbG9yKENvbG9yLnJnYlRvSGV4KHIsIGcsIGIpLCB7XG5cdCAgICAgICAgJ2FscGhhJzogYVxuXHQgICAgfSk7XG5cdH07XG5cdCovXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBibGVuZGluZyBhbm90aGVyIGNvbG9yIG9uIHRvcCBvZiBjdXJyZW50IGNvbG9yIHdpdGggYWxwaGFcblx0ICogQHBhcmFtIGNvbG9yIENvbG9yIHRvIGJsZW5kIG9uIHRvcCBvZiBjdXJyZW50IGNvbG9yLCBpLmUuIFwiQ2FcIlxuXHQgKi9cblx0Ly90b2RvOiBzZWUgaWYgLmJsZW5kQWxwaGEgY2FuIGJlIG1lcmdlZCBpbnRvIC5taXhcblx0Q29sb3IucHJvdG90eXBlLmJsZW5kQWxwaGEgPSBmdW5jdGlvbihjb2xvcikge1xuXHQgICAgaWYgKCEoY29sb3IgaW5zdGFuY2VvZiBDb2xvcikpIHtcblx0ICAgICAgICBjb2xvciA9IG5ldyBDb2xvcihjb2xvcik7XG5cdCAgICB9XG5cblx0ICAgIHZhciBDYSA9IGNvbG9yO1xuXHQgICAgdmFyIENiID0gdGhpcztcblxuXHQgICAgLy90b2RvOiB3cml0ZSBhbHBoYSBibGVuZGluZyBmdW5jdGlvblxuXHQgICAgdmFyIHIgPSBDYS5hbHBoYSAqIENhLnJnYi5yICsgKDEgLSBDYS5hbHBoYSkgKiBDYi5yZ2Iucjtcblx0ICAgIHZhciBnID0gQ2EuYWxwaGEgKiBDYS5yZ2IuZyArICgxIC0gQ2EuYWxwaGEpICogQ2IucmdiLmc7XG5cdCAgICB2YXIgYiA9IENhLmFscGhhICogQ2EucmdiLmIgKyAoMSAtIENhLmFscGhhKSAqIENiLnJnYi5iO1xuXG5cdCAgICByZXR1cm4gbmV3IENvbG9yKENvbG9yLnJnYjJoZXgociwgZywgYikpO1xuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQ29sb3I7XG5cblxuLyoqKi8gfSxcbi8qIDExICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICAndmVyc2lvbic6ICcyLjkuNCcsXG5cdCAgJ3N2Z19ucyc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zydcblx0fTtcblxuLyoqKi8gfSxcbi8qIDEyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgc2hhdmVuID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cblx0dmFyIFNWRyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdHZhciBjb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblx0dmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxuXHR2YXIgU1ZHX05TID0gY29uc3RhbnRzLnN2Z19ucztcblxuXHR2YXIgdGVtcGxhdGVzID0ge1xuXHQgICdlbGVtZW50JzogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgIHZhciB0YWcgPSBvcHRpb25zLnRhZztcblx0ICAgIHZhciBjb250ZW50ID0gb3B0aW9ucy5jb250ZW50IHx8ICcnO1xuXHQgICAgZGVsZXRlIG9wdGlvbnMudGFnO1xuXHQgICAgZGVsZXRlIG9wdGlvbnMuY29udGVudDtcblx0ICAgIHJldHVybiAgW3RhZywgY29udGVudCwgb3B0aW9uc107XG5cdCAgfVxuXHR9O1xuXG5cdC8vdG9kbzogZGVwcmVjYXRlIHRhZyBhcmcsIGluZmVyIHRhZyBmcm9tIHNoYXBlIG9iamVjdFxuXHRmdW5jdGlvbiBjb252ZXJ0U2hhcGUgKHNoYXBlLCB0YWcpIHtcblx0ICByZXR1cm4gdGVtcGxhdGVzLmVsZW1lbnQoe1xuXHQgICAgJ3RhZyc6IHRhZyxcblx0ICAgICd3aWR0aCc6IHNoYXBlLndpZHRoLFxuXHQgICAgJ2hlaWdodCc6IHNoYXBlLmhlaWdodCxcblx0ICAgICdmaWxsJzogc2hhcGUucHJvcGVydGllcy5maWxsXG5cdCAgfSk7XG5cdH1cblxuXHRmdW5jdGlvbiB0ZXh0Q3NzIChwcm9wZXJ0aWVzKSB7XG5cdCAgcmV0dXJuIHV0aWxzLmNzc1Byb3BzKHtcblx0ICAgICdmaWxsJzogcHJvcGVydGllcy5maWxsLFxuXHQgICAgJ2ZvbnQtd2VpZ2h0JzogcHJvcGVydGllcy5mb250LndlaWdodCxcblx0ICAgICdmb250LWZhbWlseSc6IHByb3BlcnRpZXMuZm9udC5mYW1pbHkgKyAnLCBtb25vc3BhY2UnLFxuXHQgICAgJ2ZvbnQtc2l6ZSc6IHByb3BlcnRpZXMuZm9udC5zaXplICsgcHJvcGVydGllcy5mb250LnVuaXRzXG5cdCAgfSk7XG5cdH1cblxuXHRmdW5jdGlvbiBvdXRsaW5lUGF0aCAoYmdXaWR0aCwgYmdIZWlnaHQsIG91dGxpbmVXaWR0aCkge1xuXHQgIHZhciBvdXRsaW5lT2Zmc2V0V2lkdGggPSBvdXRsaW5lV2lkdGggLyAyO1xuXG5cdCAgcmV0dXJuIFtcblx0ICAgICdNJywgb3V0bGluZU9mZnNldFdpZHRoLCBvdXRsaW5lT2Zmc2V0V2lkdGgsXG5cdCAgICAnSCcsIGJnV2lkdGggLSBvdXRsaW5lT2Zmc2V0V2lkdGgsXG5cdCAgICAnVicsIGJnSGVpZ2h0IC0gb3V0bGluZU9mZnNldFdpZHRoLFxuXHQgICAgJ0gnLCBvdXRsaW5lT2Zmc2V0V2lkdGgsXG5cdCAgICAnVicsIDAsXG5cdCAgICAnTScsIDAsIG91dGxpbmVPZmZzZXRXaWR0aCxcblx0ICAgICdMJywgYmdXaWR0aCwgYmdIZWlnaHQgLSBvdXRsaW5lT2Zmc2V0V2lkdGgsXG5cdCAgICAnTScsIDAsIGJnSGVpZ2h0IC0gb3V0bGluZU9mZnNldFdpZHRoLFxuXHQgICAgJ0wnLCBiZ1dpZHRoLCBvdXRsaW5lT2Zmc2V0V2lkdGhcblx0ICBdLmpvaW4oJyAnKTtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNjZW5lR3JhcGgsIHJlbmRlclNldHRpbmdzKSB7XG5cdCAgdmFyIGVuZ2luZVNldHRpbmdzID0gcmVuZGVyU2V0dGluZ3MuZW5naW5lU2V0dGluZ3M7XG5cdCAgdmFyIHN0eWxlc2hlZXRzID0gZW5naW5lU2V0dGluZ3Muc3R5bGVzaGVldHM7XG5cdCAgdmFyIHN0eWxlc2hlZXRYbWwgPSBzdHlsZXNoZWV0cy5tYXAoZnVuY3Rpb24gKHN0eWxlc2hlZXQpIHtcblx0ICAgIHJldHVybiAnPD94bWwtc3R5bGVzaGVldCByZWw9XCJzdHlsZXNoZWV0XCIgaHJlZj1cIicgKyBzdHlsZXNoZWV0ICsgJ1wiPz4nO1xuXHQgIH0pLmpvaW4oJ1xcbicpO1xuXG5cdCAgdmFyIGhvbGRlcklkID0gJ2hvbGRlcl8nICsgTnVtYmVyKG5ldyBEYXRlKCkpLnRvU3RyaW5nKDE2KTtcblxuXHQgIHZhciByb290ID0gc2NlbmVHcmFwaC5yb290O1xuXHQgIHZhciB0ZXh0R3JvdXAgPSByb290LmNoaWxkcmVuLmhvbGRlclRleHRHcm91cDtcblxuXHQgIHZhciBjc3MgPSAnIycgKyBob2xkZXJJZCArICcgdGV4dCB7ICcgKyB0ZXh0Q3NzKHRleHRHcm91cC5wcm9wZXJ0aWVzKSArICcgfSAnO1xuXG5cdCAgLy8gcHVzaCB0ZXh0IGRvd24gdG8gYmUgZXF1YWxseSB2ZXJ0aWNhbGx5IGFsaWduZWQgd2l0aCBjYW52YXMgcmVuZGVyZXJcblx0ICB0ZXh0R3JvdXAueSArPSB0ZXh0R3JvdXAudGV4dFBvc2l0aW9uRGF0YS5ib3VuZGluZ0JveC5oZWlnaHQgKiAwLjg7XG5cblx0ICB2YXIgd29yZFRhZ3MgPSBbXTtcblxuXHQgIE9iamVjdC5rZXlzKHRleHRHcm91cC5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAobGluZUtleSkge1xuXHQgICAgdmFyIGxpbmUgPSB0ZXh0R3JvdXAuY2hpbGRyZW5bbGluZUtleV07XG5cblx0ICAgIE9iamVjdC5rZXlzKGxpbmUuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKHdvcmRLZXkpIHtcblx0ICAgICAgdmFyIHdvcmQgPSBsaW5lLmNoaWxkcmVuW3dvcmRLZXldO1xuXHQgICAgICB2YXIgeCA9IHRleHRHcm91cC54ICsgbGluZS54ICsgd29yZC54O1xuXHQgICAgICB2YXIgeSA9IHRleHRHcm91cC55ICsgbGluZS55ICsgd29yZC55O1xuXG5cdCAgICAgIHZhciB3b3JkVGFnID0gdGVtcGxhdGVzLmVsZW1lbnQoe1xuXHQgICAgICAgICd0YWcnOiAndGV4dCcsXG5cdCAgICAgICAgJ2NvbnRlbnQnOiB3b3JkLnByb3BlcnRpZXMudGV4dCxcblx0ICAgICAgICAneCc6IHgsXG5cdCAgICAgICAgJ3knOiB5XG5cdCAgICAgIH0pO1xuXG5cdCAgICAgIHdvcmRUYWdzLnB1c2god29yZFRhZyk7XG5cdCAgICB9KTtcblx0ICB9KTtcblxuXHQgIHZhciB0ZXh0ID0gdGVtcGxhdGVzLmVsZW1lbnQoe1xuXHQgICAgJ3RhZyc6ICdnJyxcblx0ICAgICdjb250ZW50Jzogd29yZFRhZ3Ncblx0ICB9KTtcblxuXHQgIHZhciBvdXRsaW5lID0gbnVsbDtcblxuXHQgIGlmIChyb290LmNoaWxkcmVuLmhvbGRlckJnLnByb3BlcnRpZXMub3V0bGluZSkge1xuXHQgICAgdmFyIG91dGxpbmVQcm9wZXJ0aWVzID0gcm9vdC5jaGlsZHJlbi5ob2xkZXJCZy5wcm9wZXJ0aWVzLm91dGxpbmU7XG5cdCAgICBvdXRsaW5lID0gdGVtcGxhdGVzLmVsZW1lbnQoe1xuXHQgICAgICAndGFnJzogJ3BhdGgnLFxuXHQgICAgICAnZCc6IG91dGxpbmVQYXRoKHJvb3QuY2hpbGRyZW4uaG9sZGVyQmcud2lkdGgsIHJvb3QuY2hpbGRyZW4uaG9sZGVyQmcuaGVpZ2h0LCBvdXRsaW5lUHJvcGVydGllcy53aWR0aCksXG5cdCAgICAgICdzdHJva2Utd2lkdGgnOiBvdXRsaW5lUHJvcGVydGllcy53aWR0aCxcblx0ICAgICAgJ3N0cm9rZSc6IG91dGxpbmVQcm9wZXJ0aWVzLmZpbGwsXG5cdCAgICAgICdmaWxsJzogJ25vbmUnXG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICB2YXIgYmcgPSBjb252ZXJ0U2hhcGUocm9vdC5jaGlsZHJlbi5ob2xkZXJCZywgJ3JlY3QnKTtcblxuXHQgIHZhciBzY2VuZUNvbnRlbnQgPSBbXTtcblxuXHQgIHNjZW5lQ29udGVudC5wdXNoKGJnKTtcblx0ICBpZiAob3V0bGluZVByb3BlcnRpZXMpIHtcblx0ICAgIHNjZW5lQ29udGVudC5wdXNoKG91dGxpbmUpO1xuXHQgIH1cblx0ICBzY2VuZUNvbnRlbnQucHVzaCh0ZXh0KTtcblxuXHQgIHZhciBzY2VuZSA9IHRlbXBsYXRlcy5lbGVtZW50KHtcblx0ICAgICd0YWcnOiAnZycsXG5cdCAgICAnaWQnOiBob2xkZXJJZCxcblx0ICAgICdjb250ZW50Jzogc2NlbmVDb250ZW50XG5cdCAgfSk7XG5cblx0ICB2YXIgc3R5bGUgPSB0ZW1wbGF0ZXMuZWxlbWVudCh7XG5cdCAgICAndGFnJzogJ3N0eWxlJyxcblx0ICAgIC8vdG9kbzogZmlndXJlIG91dCBob3cgdG8gYWRkIENEQVRBIGRpcmVjdGl2ZVxuXHQgICAgJ2NvbnRlbnQnOiBjc3MsXG5cdCAgICAndHlwZSc6ICd0ZXh0L2Nzcydcblx0ICB9KTtcblxuXHQgIHZhciBkZWZzID0gdGVtcGxhdGVzLmVsZW1lbnQoe1xuXHQgICAgJ3RhZyc6ICdkZWZzJyxcblx0ICAgICdjb250ZW50Jzogc3R5bGVcblx0ICB9KTtcblxuXHQgIHZhciBzdmcgPSB0ZW1wbGF0ZXMuZWxlbWVudCh7XG5cdCAgICAndGFnJzogJ3N2ZycsXG5cdCAgICAnY29udGVudCc6IFtkZWZzLCBzY2VuZV0sXG5cdCAgICAnd2lkdGgnOiByb290LnByb3BlcnRpZXMud2lkdGgsXG5cdCAgICAnaGVpZ2h0Jzogcm9vdC5wcm9wZXJ0aWVzLmhlaWdodCxcblx0ICAgICd4bWxucyc6IFNWR19OUyxcblx0ICAgICd2aWV3Qm94JzogWzAsIDAsIHJvb3QucHJvcGVydGllcy53aWR0aCwgcm9vdC5wcm9wZXJ0aWVzLmhlaWdodF0uam9pbignICcpLFxuXHQgICAgJ3ByZXNlcnZlQXNwZWN0UmF0aW8nOiAnbm9uZSdcblx0ICB9KTtcblxuXHQgIHZhciBvdXRwdXQgPSBzaGF2ZW4oc3ZnKTtcblx0ICBcblx0ICBvdXRwdXQgPSBzdHlsZXNoZWV0WG1sICsgb3V0cHV0WzBdO1xuXG5cdCAgdmFyIHN2Z1N0cmluZyA9IFNWRy5zdmdTdHJpbmdUb0RhdGFVUkkob3V0cHV0LCByZW5kZXJTZXR0aW5ncy5tb2RlID09PSAnYmFja2dyb3VuZCcpO1xuXHQgIHJldHVybiBzdmdTdHJpbmc7XG5cdH07XG5cbi8qKiovIH0sXG4vKiAxMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGVzY2FwZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpXG5cblx0Ly8gVE9ETzogcmVtb3ZlIG5hbWVzcGFjZVxuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hhdmVuIChhcnJheSwgbmFtZXNwYWNlLCByZXR1cm5PYmplY3QpIHtcblxuXHRcdCd1c2Ugc3RyaWN0J1xuXG5cdFx0dmFyIGkgPSAxXG5cdFx0dmFyIGRvZXNFc2NhcGUgPSB0cnVlXG5cdFx0dmFyIEhUTUxTdHJpbmdcblx0XHR2YXIgYXR0cmlidXRlS2V5XG5cdFx0dmFyIGNhbGxiYWNrXG5cdFx0dmFyIGtleVxuXG5cblx0XHRyZXR1cm5PYmplY3QgPSByZXR1cm5PYmplY3QgfHwge31cblxuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoc3VnYXJTdHJpbmcpIHtcblxuXHRcdFx0dmFyIHRhZ3MgPSBzdWdhclN0cmluZy5tYXRjaCgvXltcXHctXSsvKVxuXHRcdFx0dmFyIGVsZW1lbnQgPSB7XG5cdFx0XHRcdHRhZzogdGFncyA/IHRhZ3NbMF0gOiAnZGl2Jyxcblx0XHRcdFx0YXR0cjoge30sXG5cdFx0XHRcdGNoaWxkcmVuOiBbXVxuXHRcdFx0fVxuXHRcdFx0dmFyIGlkID0gc3VnYXJTdHJpbmcubWF0Y2goLyMoW1xcdy1dKykvKVxuXHRcdFx0dmFyIHJlZmVyZW5jZSA9IHN1Z2FyU3RyaW5nLm1hdGNoKC9cXCQoW1xcdy1dKykvKVxuXHRcdFx0dmFyIGNsYXNzTmFtZXMgPSBzdWdhclN0cmluZy5tYXRjaCgvXFwuW1xcdy1dKy9nKVxuXG5cblx0XHRcdC8vIEFzc2lnbiBpZCBpZiBpcyBzZXRcblx0XHRcdGlmIChpZCkge1xuXHRcdFx0XHRlbGVtZW50LmF0dHIuaWQgPSBpZFsxXVxuXG5cdFx0XHRcdC8vIEFkZCBlbGVtZW50IHRvIHRoZSByZXR1cm4gb2JqZWN0XG5cdFx0XHRcdHJldHVybk9iamVjdFtpZFsxXV0gPSBlbGVtZW50XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyZWZlcmVuY2UpXG5cdFx0XHRcdHJldHVybk9iamVjdFtyZWZlcmVuY2VbMV1dID0gZWxlbWVudFxuXG5cdFx0XHRpZiAoY2xhc3NOYW1lcylcblx0XHRcdFx0ZWxlbWVudC5hdHRyLmNsYXNzID0gY2xhc3NOYW1lcy5qb2luKCcgJykucmVwbGFjZSgvXFwuL2csICcnKVxuXG5cdFx0XHRpZiAoc3VnYXJTdHJpbmcubWF0Y2goLyYkL2cpKVxuXHRcdFx0XHRkb2VzRXNjYXBlID0gZmFsc2VcblxuXHRcdFx0cmV0dXJuIGVsZW1lbnRcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXBsYWNlciAoa2V5LCB2YWx1ZSkge1xuXG5cdFx0XHRpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHJldHVyblxuXG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKVxuXHRcdFx0XHRyZXR1cm4gU3RyaW5nKHZhbHVlKVxuXG5cdFx0XHRyZXR1cm4gdmFsdWVcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBlc2NhcGVBdHRyaWJ1dGUgKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIChzdHJpbmcgfHwgc3RyaW5nID09PSAwKSA/XG5cdFx0XHRcdFN0cmluZyhzdHJpbmcpXG5cdFx0XHRcdFx0LnJlcGxhY2UoLyYvZywgJyZhbXA7Jylcblx0XHRcdFx0XHQucmVwbGFjZSgvXCIvZywgJyZxdW90OycpIDpcblx0XHRcdFx0Jydcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBlc2NhcGVIVE1MIChzdHJpbmcpIHtcblx0XHRcdHJldHVybiBTdHJpbmcoc3RyaW5nKVxuXHRcdFx0XHQucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuXHRcdFx0XHQucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG5cdFx0XHRcdC5yZXBsYWNlKC8nL2csICcmYXBvczsnKVxuXHRcdFx0XHQucmVwbGFjZSgvPC9nLCAnJmx0OycpXG5cdFx0XHRcdC5yZXBsYWNlKC8+L2csICcmZ3Q7Jylcblx0XHR9XG5cblxuXHRcdGlmICh0eXBlb2YgYXJyYXlbMF0gPT09ICdzdHJpbmcnKVxuXHRcdFx0YXJyYXlbMF0gPSBjcmVhdGVFbGVtZW50KGFycmF5WzBdKVxuXG5cdFx0ZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcnJheVswXSkpXG5cdFx0XHRpID0gMFxuXG5cdFx0ZWxzZVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHQnRmlyc3QgZWxlbWVudCBvZiBhcnJheSBtdXN0IGJlIGEgc3RyaW5nLCAnICtcblx0XHRcdFx0J29yIGFuIGFycmF5IGFuZCBub3QgJyArIEpTT04uc3RyaW5naWZ5KGFycmF5WzBdKVxuXHRcdFx0KVxuXG5cblx0XHRmb3IgKDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cblx0XHRcdC8vIERvbid0IHJlbmRlciBlbGVtZW50IGlmIHZhbHVlIGlzIGZhbHNlIG9yIG51bGxcblx0XHRcdGlmIChhcnJheVtpXSA9PT0gZmFsc2UgfHwgYXJyYXlbaV0gPT09IG51bGwpIHtcblx0XHRcdFx0YXJyYXlbMF0gPSBmYWxzZVxuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250aW51ZSB3aXRoIG5leHQgYXJyYXkgdmFsdWUgaWYgY3VycmVudCB2YWx1ZSBpcyB1bmRlZmluZWQgb3IgdHJ1ZVxuXHRcdFx0ZWxzZSBpZiAoYXJyYXlbaV0gPT09IHVuZGVmaW5lZCB8fCBhcnJheVtpXSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0fVxuXG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgYXJyYXlbaV0gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGlmIChkb2VzRXNjYXBlKVxuXHRcdFx0XHRcdGFycmF5W2ldID0gZXNjYXBlSFRNTChhcnJheVtpXSlcblxuXHRcdFx0XHRhcnJheVswXS5jaGlsZHJlbi5wdXNoKGFycmF5W2ldKVxuXHRcdFx0fVxuXG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgYXJyYXlbaV0gPT09ICdudW1iZXInKSB7XG5cblx0XHRcdFx0YXJyYXlbMF0uY2hpbGRyZW4ucHVzaChhcnJheVtpXSlcblx0XHRcdH1cblxuXHRcdFx0ZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcnJheVtpXSkpIHtcblxuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcnJheVtpXVswXSkpIHtcblx0XHRcdFx0XHRhcnJheVtpXS5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAoc3ViQXJyYXkpIHtcblx0XHRcdFx0XHRcdGFycmF5LnNwbGljZShpICsgMSwgMCwgc3ViQXJyYXkpXG5cdFx0XHRcdFx0fSlcblxuXHRcdFx0XHRcdGlmIChpICE9PSAwKVxuXHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRpKytcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNoYXZlbihhcnJheVtpXSwgbmFtZXNwYWNlLCByZXR1cm5PYmplY3QpXG5cblx0XHRcdFx0aWYgKGFycmF5W2ldWzBdKVxuXHRcdFx0XHRcdGFycmF5WzBdLmNoaWxkcmVuLnB1c2goYXJyYXlbaV1bMF0pXG5cdFx0XHR9XG5cblx0XHRcdGVsc2UgaWYgKHR5cGVvZiBhcnJheVtpXSA9PT0gJ2Z1bmN0aW9uJylcblx0XHRcdFx0Y2FsbGJhY2sgPSBhcnJheVtpXVxuXG5cblx0XHRcdGVsc2UgaWYgKHR5cGVvZiBhcnJheVtpXSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yIChhdHRyaWJ1dGVLZXkgaW4gYXJyYXlbaV0pXG5cdFx0XHRcdFx0aWYgKGFycmF5W2ldLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZUtleSkpXG5cdFx0XHRcdFx0XHRpZiAoYXJyYXlbaV1bYXR0cmlidXRlS2V5XSAhPT0gbnVsbCAmJlxuXHRcdFx0XHRcdFx0XHRhcnJheVtpXVthdHRyaWJ1dGVLZXldICE9PSBmYWxzZSlcblx0XHRcdFx0XHRcdFx0aWYgKGF0dHJpYnV0ZUtleSA9PT0gJ3N0eWxlJyAmJlxuXHRcdFx0XHRcdFx0XHRcdHR5cGVvZiBhcnJheVtpXVthdHRyaWJ1dGVLZXldID09PSAnb2JqZWN0Jylcblx0XHRcdFx0XHRcdFx0XHRhcnJheVswXS5hdHRyW2F0dHJpYnV0ZUtleV0gPSBKU09OXG5cdFx0XHRcdFx0XHRcdFx0XHQuc3RyaW5naWZ5KGFycmF5W2ldW2F0dHJpYnV0ZUtleV0sIHJlcGxhY2VyKVxuXHRcdFx0XHRcdFx0XHRcdFx0LnNsaWNlKDIsIC0yKVxuXHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1wiLFwiL2csICc7Jylcblx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9cIjpcIi9nLCAnOicpXG5cdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvXFxcXFwiL2csICdcXCcnKVxuXG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRhcnJheVswXS5hdHRyW2F0dHJpYnV0ZUtleV0gPSBhcnJheVtpXVthdHRyaWJ1dGVLZXldXG5cdFx0XHR9XG5cblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignXCInICsgYXJyYXlbaV0gKyAnXCIgaXMgbm90IGFsbG93ZWQgYXMgYSB2YWx1ZS4nKVxuXHRcdH1cblxuXG5cdFx0aWYgKGFycmF5WzBdICE9PSBmYWxzZSkge1xuXG5cdFx0XHRIVE1MU3RyaW5nID0gJzwnICsgYXJyYXlbMF0udGFnXG5cblx0XHRcdGZvciAoa2V5IGluIGFycmF5WzBdLmF0dHIpXG5cdFx0XHRcdGlmIChhcnJheVswXS5hdHRyLmhhc093blByb3BlcnR5KGtleSkpXG5cdFx0XHRcdFx0SFRNTFN0cmluZyArPSAnICcgKyBrZXkgKyAnPVwiJyArXG5cdFx0XHRcdFx0XHRlc2NhcGVBdHRyaWJ1dGUoYXJyYXlbMF0uYXR0cltrZXldKSArICdcIidcblxuXHRcdFx0SFRNTFN0cmluZyArPSAnPidcblxuXHRcdFx0YXJyYXlbMF0uY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcblx0XHRcdFx0SFRNTFN0cmluZyArPSBjaGlsZFxuXHRcdFx0fSlcblxuXHRcdFx0SFRNTFN0cmluZyArPSAnPC8nICsgYXJyYXlbMF0udGFnICsgJz4nXG5cblx0XHRcdGFycmF5WzBdID0gSFRNTFN0cmluZ1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiByb290IGVsZW1lbnQgb24gaW5kZXggMFxuXHRcdHJldHVybk9iamVjdFswXSA9IGFycmF5WzBdXG5cblx0XHRpZiAoY2FsbGJhY2spXG5cdFx0XHRjYWxsYmFjayhhcnJheVswXSlcblxuXHRcdC8vIHJldHVybnMgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGVsZW1lbnRzIHdpdGggYW4gaWQgYW5kIHRoZSByb290IGVsZW1lbnRcblx0XHRyZXR1cm4gcmV0dXJuT2JqZWN0XG5cdH1cblxuXG4vKioqLyB9LFxuLyogMTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdC8qIVxuXHQgKiBlc2NhcGUtaHRtbFxuXHQgKiBDb3B5cmlnaHQoYykgMjAxMi0yMDEzIFRKIEhvbG93YXljaHVrXG5cdCAqIENvcHlyaWdodChjKSAyMDE1IEFuZHJlYXMgTHViYmVcblx0ICogQ29weXJpZ2h0KGMpIDIwMTUgVGlhbmNoZW5nIFwiVGltb3RoeVwiIEd1XG5cdCAqIE1JVCBMaWNlbnNlZFxuXHQgKi9cblxuXHQndXNlIHN0cmljdCc7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSB2YXJpYWJsZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXG5cdHZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICogQHB1YmxpY1xuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IGVzY2FwZUh0bWw7XG5cblx0LyoqXG5cdCAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxuXHQgKlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGVzY2FwZSBmb3IgaW5zZXJ0aW5nIGludG8gSFRNTFxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqIEBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcblx0ICB2YXIgc3RyID0gJycgKyBzdHJpbmc7XG5cdCAgdmFyIG1hdGNoID0gbWF0Y2hIdG1sUmVnRXhwLmV4ZWMoc3RyKTtcblxuXHQgIGlmICghbWF0Y2gpIHtcblx0ICAgIHJldHVybiBzdHI7XG5cdCAgfVxuXG5cdCAgdmFyIGVzY2FwZTtcblx0ICB2YXIgaHRtbCA9ICcnO1xuXHQgIHZhciBpbmRleCA9IDA7XG5cdCAgdmFyIGxhc3RJbmRleCA9IDA7XG5cblx0ICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuXHQgICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcblx0ICAgICAgY2FzZSAzNDogLy8gXCJcblx0ICAgICAgICBlc2NhcGUgPSAnJnF1b3Q7Jztcblx0ICAgICAgICBicmVhaztcblx0ICAgICAgY2FzZSAzODogLy8gJlxuXHQgICAgICAgIGVzY2FwZSA9ICcmYW1wOyc7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGNhc2UgMzk6IC8vICdcblx0ICAgICAgICBlc2NhcGUgPSAnJiMzOTsnO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBjYXNlIDYwOiAvLyA8XG5cdCAgICAgICAgZXNjYXBlID0gJyZsdDsnO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBjYXNlIDYyOiAvLyA+XG5cdCAgICAgICAgZXNjYXBlID0gJyZndDsnO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBkZWZhdWx0OlxuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuXHQgICAgICBodG1sICs9IHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCk7XG5cdCAgICB9XG5cblx0ICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcblx0ICAgIGh0bWwgKz0gZXNjYXBlO1xuXHQgIH1cblxuXHQgIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4XG5cdCAgICA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpXG5cdCAgICA6IGh0bWw7XG5cdH1cblxuXG4vKioqLyB9LFxuLyogMTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBET00gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHR2YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGNhbnZhcyA9IERPTS5uZXdFbCgnY2FudmFzJyk7XG5cdCAgICB2YXIgY3R4ID0gbnVsbDtcblxuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKHNjZW5lR3JhcGgpIHtcblx0ICAgICAgICBpZiAoY3R4ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGRwciA9IHV0aWxzLmNhbnZhc1JhdGlvKCk7XG5cdCAgICAgICAgdmFyIHJvb3QgPSBzY2VuZUdyYXBoLnJvb3Q7XG5cdCAgICAgICAgY2FudmFzLndpZHRoID0gZHByICogcm9vdC5wcm9wZXJ0aWVzLndpZHRoO1xuXHQgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkcHIgKiByb290LnByb3BlcnRpZXMuaGVpZ2h0IDtcblx0ICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cblx0ICAgICAgICB2YXIgYmcgPSByb290LmNoaWxkcmVuLmhvbGRlckJnO1xuXHQgICAgICAgIHZhciBiZ1dpZHRoID0gZHByICogYmcud2lkdGg7XG5cdCAgICAgICAgdmFyIGJnSGVpZ2h0ID0gZHByICogYmcuaGVpZ2h0O1xuXHQgICAgICAgIC8vdG9kbzogcGFyYW1ldHJpemUgb3V0bGluZSB3aWR0aCAoZS5nLiBpbiBzY2VuZSBvYmplY3QpXG5cdCAgICAgICAgdmFyIG91dGxpbmVXaWR0aCA9IDI7XG5cdCAgICAgICAgdmFyIG91dGxpbmVPZmZzZXRXaWR0aCA9IG91dGxpbmVXaWR0aCAvIDI7XG5cblx0ICAgICAgICBjdHguZmlsbFN0eWxlID0gYmcucHJvcGVydGllcy5maWxsO1xuXHQgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBiZ1dpZHRoLCBiZ0hlaWdodCk7XG5cblx0ICAgICAgICBpZiAoYmcucHJvcGVydGllcy5vdXRsaW5lKSB7XG5cdCAgICAgICAgICAgIC8vdG9kbzogYWJzdHJhY3QgdGhpcyBpbnRvIGEgbWV0aG9kXG5cdCAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGJnLnByb3BlcnRpZXMub3V0bGluZS5maWxsO1xuXHQgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gYmcucHJvcGVydGllcy5vdXRsaW5lLndpZHRoO1xuXHQgICAgICAgICAgICBjdHgubW92ZVRvKG91dGxpbmVPZmZzZXRXaWR0aCwgb3V0bGluZU9mZnNldFdpZHRoKTtcblx0ICAgICAgICAgICAgLy8gVEwsIFRSLCBCUiwgQkxcblx0ICAgICAgICAgICAgY3R4LmxpbmVUbyhiZ1dpZHRoIC0gb3V0bGluZU9mZnNldFdpZHRoLCBvdXRsaW5lT2Zmc2V0V2lkdGgpO1xuXHQgICAgICAgICAgICBjdHgubGluZVRvKGJnV2lkdGggLSBvdXRsaW5lT2Zmc2V0V2lkdGgsIGJnSGVpZ2h0IC0gb3V0bGluZU9mZnNldFdpZHRoKTtcblx0ICAgICAgICAgICAgY3R4LmxpbmVUbyhvdXRsaW5lT2Zmc2V0V2lkdGgsIGJnSGVpZ2h0IC0gb3V0bGluZU9mZnNldFdpZHRoKTtcblx0ICAgICAgICAgICAgY3R4LmxpbmVUbyhvdXRsaW5lT2Zmc2V0V2lkdGgsIG91dGxpbmVPZmZzZXRXaWR0aCk7XG5cdCAgICAgICAgICAgIC8vIERpYWdvbmFsc1xuXHQgICAgICAgICAgICBjdHgubW92ZVRvKDAsIG91dGxpbmVPZmZzZXRXaWR0aCk7XG5cdCAgICAgICAgICAgIGN0eC5saW5lVG8oYmdXaWR0aCwgYmdIZWlnaHQgLSBvdXRsaW5lT2Zmc2V0V2lkdGgpO1xuXHQgICAgICAgICAgICBjdHgubW92ZVRvKDAsIGJnSGVpZ2h0IC0gb3V0bGluZU9mZnNldFdpZHRoKTtcblx0ICAgICAgICAgICAgY3R4LmxpbmVUbyhiZ1dpZHRoLCBvdXRsaW5lT2Zmc2V0V2lkdGgpO1xuXHQgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHRleHRHcm91cCA9IHJvb3QuY2hpbGRyZW4uaG9sZGVyVGV4dEdyb3VwO1xuXHQgICAgICAgIGN0eC5mb250ID0gdGV4dEdyb3VwLnByb3BlcnRpZXMuZm9udC53ZWlnaHQgKyAnICcgKyAoZHByICogdGV4dEdyb3VwLnByb3BlcnRpZXMuZm9udC5zaXplKSArIHRleHRHcm91cC5wcm9wZXJ0aWVzLmZvbnQudW5pdHMgKyAnICcgKyB0ZXh0R3JvdXAucHJvcGVydGllcy5mb250LmZhbWlseSArICcsIG1vbm9zcGFjZSc7XG5cdCAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRHcm91cC5wcm9wZXJ0aWVzLmZpbGw7XG5cblx0ICAgICAgICBmb3IgKHZhciBsaW5lS2V5IGluIHRleHRHcm91cC5jaGlsZHJlbikge1xuXHQgICAgICAgICAgICB2YXIgbGluZSA9IHRleHRHcm91cC5jaGlsZHJlbltsaW5lS2V5XTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgd29yZEtleSBpbiBsaW5lLmNoaWxkcmVuKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd29yZCA9IGxpbmUuY2hpbGRyZW5bd29yZEtleV07XG5cdCAgICAgICAgICAgICAgICB2YXIgeCA9IGRwciAqICh0ZXh0R3JvdXAueCArIGxpbmUueCArIHdvcmQueCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgeSA9IGRwciAqICh0ZXh0R3JvdXAueSArIGxpbmUueSArIHdvcmQueSArICh0ZXh0R3JvdXAucHJvcGVydGllcy5sZWFkaW5nIC8gMikpO1xuXG5cdCAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQod29yZC5wcm9wZXJ0aWVzLnRleHQsIHgsIHkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuXHQgICAgfTtcblx0fSkoKTtcblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuKGZ1bmN0aW9uKGN0eCwgaXNNZXRlb3JQYWNrYWdlKSB7XG4gICAgaWYgKGlzTWV0ZW9yUGFja2FnZSkge1xuICAgICAgICBIb2xkZXIgPSBjdHguSG9sZGVyO1xuICAgIH1cbn0pKHRoaXMsIHR5cGVvZiBNZXRlb3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBQYWNrYWdlICE9PSAndW5kZWZpbmVkJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9ob2xkZXJqcy9ob2xkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\nvar Holder = __webpack_require__(0);\n\nHolder.addTheme('vue', { bg: '#4FC08D', fg: '#FFFFFF' });\nHolder.addTheme('facebook', { bg: '#3b5998', fg: '#FFFFFF' });\nHolder.addTheme('twitter', { bg: '#55acee', fg: '#FFFFFF' });\nHolder.addTheme('youtube', { bg: '#bb0000', fg: '#FFFFFF' });\nHolder.addTheme('tumblr', { bg: '#32506d', fg: '#FFFFFF' });\nHolder.addTheme('github', { bg: '#000000', fg: '#FFFFFF' });\nHolder.addTheme('whatsapp', { bg: '#4dc247', fg: '#FFFFFF' });\n\nvar holderJS = {\n\tinstall: function install(Vue) {\n\t\tvar options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tVue.directive('holder', {\n\t\t\tbind: function bind(el, binding) {\n\t\t\t\tif (!binding.value) {\n\t\t\t\t\tel.setAttribute('data-src', 'holder.js/100px100p?auto=yes');\n\t\t\t\t\tHolder.run({ images: el });\n\t\t\t\t} else if (Object.prototype.toString.call(binding.value) === '[object Object]') {\n\t\t\t\t\tvar imageSize = '300x300',\n\t\t\t\t\t    holderOpts = binding.value;\n\t\t\t\t\tif (holderOpts.hasOwnProperty('img')) {\n\t\t\t\t\t\timageSize = holderOpts.img;\n\t\t\t\t\t\tdelete holderOpts['img'];\n\t\t\t\t\t}\n\t\t\t\t\tvar holderStr = '?' + Object.keys(holderOpts).map(function (prop) {\n\t\t\t\t\t\treturn [prop, holderOpts[prop]].map(encodeURIComponent).join('=');\n\t\t\t\t\t}).join('&');\n\t\t\t\t\tel.setAttribute('data-src', 'holder.js/' + imageSize + holderStr);\n\t\t\t\t\tHolder.run({\n\t\t\t\t\t\timages: el\n\t\t\t\t\t});\n\t\t\t\t} else if (Object.prototype.toString.call(binding.value) === '[object String]') {\n\t\t\t\t\tel.setAttribute('data-src', 'holder.js/' + binding.value);\n\t\t\t\t\tHolder.run({\n\t\t\t\t\t\timages: el\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (holderJS);\n\nif (typeof window !== 'undefined' && window.Vue) {\n\twindow.Vue.use(holderJS);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/OTU1MiJdLCJuYW1lcyI6WyJIb2xkZXIiLCJyZXF1aXJlIiwiYWRkVGhlbWUiLCJiZyIsImZnIiwiaG9sZGVySlMiLCJpbnN0YWxsIiwiVnVlIiwib3B0aW9ucyIsImRpcmVjdGl2ZSIsImJpbmQiLCJlbCIsImJpbmRpbmciLCJ2YWx1ZSIsInNldEF0dHJpYnV0ZSIsInJ1biIsImltYWdlcyIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImltYWdlU2l6ZSIsImhvbGRlck9wdHMiLCJoYXNPd25Qcm9wZXJ0eSIsImltZyIsImhvbGRlclN0ciIsImtleXMiLCJtYXAiLCJwcm9wIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwiam9pbiIsIndpbmRvdyIsInVzZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQSxJQUFNQSxTQUFTLG1CQUFBQyxDQUFRLENBQVIsQ0FBZjs7QUFFQUQsT0FBT0UsUUFBUCxDQUFnQixLQUFoQixFQUF1QixFQUFDQyxJQUFJLFNBQUwsRUFBZ0JDLElBQUksU0FBcEIsRUFBdkI7QUFDQUosT0FBT0UsUUFBUCxDQUFnQixVQUFoQixFQUE0QixFQUFDQyxJQUFJLFNBQUwsRUFBZ0JDLElBQUksU0FBcEIsRUFBNUI7QUFDQUosT0FBT0UsUUFBUCxDQUFnQixTQUFoQixFQUEyQixFQUFDQyxJQUFJLFNBQUwsRUFBZ0JDLElBQUksU0FBcEIsRUFBM0I7QUFDQUosT0FBT0UsUUFBUCxDQUFnQixTQUFoQixFQUEyQixFQUFDQyxJQUFJLFNBQUwsRUFBZ0JDLElBQUksU0FBcEIsRUFBM0I7QUFDQUosT0FBT0UsUUFBUCxDQUFnQixRQUFoQixFQUEwQixFQUFDQyxJQUFJLFNBQUwsRUFBZ0JDLElBQUksU0FBcEIsRUFBMUI7QUFDQUosT0FBT0UsUUFBUCxDQUFnQixRQUFoQixFQUEwQixFQUFDQyxJQUFJLFNBQUwsRUFBZ0JDLElBQUksU0FBcEIsRUFBMUI7QUFDQUosT0FBT0UsUUFBUCxDQUFnQixVQUFoQixFQUE0QixFQUFDQyxJQUFJLFNBQUwsRUFBZ0JDLElBQUksU0FBcEIsRUFBNUI7O0FBRUEsSUFBTUMsV0FBVztBQUNoQkMsUUFEZ0IsbUJBQ1JDLEdBRFEsRUFDVztBQUFBLE1BQWRDLE9BQWMsdUVBQUosRUFBSTs7QUFDMUJELE1BQUlFLFNBQUosQ0FBYyxRQUFkLEVBQXdCO0FBQ3ZCQyxPQUR1QixnQkFDbEJDLEVBRGtCLEVBQ2RDLE9BRGMsRUFDTDtBQUNqQixRQUFJLENBQUNBLFFBQVFDLEtBQWIsRUFBb0I7QUFDbkJGLFFBQUdHLFlBQUgsQ0FBZ0IsVUFBaEIsRUFBNEIsOEJBQTVCO0FBQ0FkLFlBQU9lLEdBQVAsQ0FBVyxFQUFDQyxRQUFRTCxFQUFULEVBQVg7QUFDQSxLQUhELE1BR08sSUFBSU0sT0FBT0MsU0FBUCxDQUFpQkMsUUFBakIsQ0FBMEJDLElBQTFCLENBQStCUixRQUFRQyxLQUF2QyxNQUFrRCxpQkFBdEQsRUFBeUU7QUFDL0UsU0FBSVEsWUFBWSxTQUFoQjtBQUFBLFNBQ0NDLGFBQWFWLFFBQVFDLEtBRHRCO0FBRUEsU0FBSVMsV0FBV0MsY0FBWCxDQUEwQixLQUExQixDQUFKLEVBQXNDO0FBQ3JDRixrQkFBWUMsV0FBV0UsR0FBdkI7QUFDQSxhQUFPRixXQUFXLEtBQVgsQ0FBUDtBQUNBO0FBQ0QsU0FBSUcsWUFBWSxNQUFNUixPQUFPUyxJQUFQLENBQVlKLFVBQVosRUFBd0JLLEdBQXhCLENBQTRCLFVBQVVDLElBQVYsRUFBZ0I7QUFDakUsYUFBTyxDQUFDQSxJQUFELEVBQU9OLFdBQVdNLElBQVgsQ0FBUCxFQUF5QkQsR0FBekIsQ0FBNkJFLGtCQUE3QixFQUFpREMsSUFBakQsQ0FBc0QsR0FBdEQsQ0FBUDtBQUNBLE1BRnFCLEVBRW5CQSxJQUZtQixDQUVkLEdBRmMsQ0FBdEI7QUFHQW5CLFFBQUdHLFlBQUgsQ0FBZ0IsVUFBaEIsRUFBNEIsZUFBZU8sU0FBZixHQUEyQkksU0FBdkQ7QUFDQXpCLFlBQU9lLEdBQVAsQ0FBVztBQUNWQyxjQUFRTDtBQURFLE1BQVg7QUFHQSxLQWRNLE1BY0EsSUFBSU0sT0FBT0MsU0FBUCxDQUFpQkMsUUFBakIsQ0FBMEJDLElBQTFCLENBQStCUixRQUFRQyxLQUF2QyxNQUFrRCxpQkFBdEQsRUFBeUU7QUFDL0VGLFFBQUdHLFlBQUgsQ0FBZ0IsVUFBaEIsRUFBNEIsZUFBZUYsUUFBUUMsS0FBbkQ7QUFDQWIsWUFBT2UsR0FBUCxDQUFXO0FBQ1ZDLGNBQVFMO0FBREUsTUFBWDtBQUdBO0FBQ0Q7QUF6QnNCLEdBQXhCO0FBMkJBO0FBN0JlLENBQWpCOztBQWdDQSwrREFBZU4sUUFBZjs7QUFFQSxJQUFJLE9BQU8wQixNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxPQUFPeEIsR0FBNUMsRUFBaUQ7QUFDaER3QixRQUFPeEIsR0FBUCxDQUFXeUIsR0FBWCxDQUFlM0IsUUFBZjtBQUNBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBIb2xkZXIgPSByZXF1aXJlKCdob2xkZXJqcycpO1xuXG5Ib2xkZXIuYWRkVGhlbWUoJ3Z1ZScsIHtiZzogJyM0RkMwOEQnLCBmZzogJyNGRkZGRkYnfSk7XG5Ib2xkZXIuYWRkVGhlbWUoJ2ZhY2Vib29rJywge2JnOiAnIzNiNTk5OCcsIGZnOiAnI0ZGRkZGRid9KTtcbkhvbGRlci5hZGRUaGVtZSgndHdpdHRlcicsIHtiZzogJyM1NWFjZWUnLCBmZzogJyNGRkZGRkYnfSk7XG5Ib2xkZXIuYWRkVGhlbWUoJ3lvdXR1YmUnLCB7Ymc6ICcjYmIwMDAwJywgZmc6ICcjRkZGRkZGJ30pO1xuSG9sZGVyLmFkZFRoZW1lKCd0dW1ibHInLCB7Ymc6ICcjMzI1MDZkJywgZmc6ICcjRkZGRkZGJ30pO1xuSG9sZGVyLmFkZFRoZW1lKCdnaXRodWInLCB7Ymc6ICcjMDAwMDAwJywgZmc6ICcjRkZGRkZGJ30pO1xuSG9sZGVyLmFkZFRoZW1lKCd3aGF0c2FwcCcsIHtiZzogJyM0ZGMyNDcnLCBmZzogJyNGRkZGRkYnfSk7XG5cbmNvbnN0IGhvbGRlckpTID0ge1xuXHRpbnN0YWxsKFZ1ZSwgb3B0aW9ucyA9IHt9KSB7XG5cdFx0VnVlLmRpcmVjdGl2ZSgnaG9sZGVyJywge1xuXHRcdFx0YmluZChlbCwgYmluZGluZykge1xuXHRcdFx0XHRpZiAoIWJpbmRpbmcudmFsdWUpIHtcblx0XHRcdFx0XHRlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3JjJywgJ2hvbGRlci5qcy8xMDBweDEwMHA/YXV0bz15ZXMnKTtcblx0XHRcdFx0XHRIb2xkZXIucnVuKHtpbWFnZXM6IGVsfSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJpbmRpbmcudmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuXHRcdFx0XHRcdGxldCBpbWFnZVNpemUgPSAnMzAweDMwMCcsXG5cdFx0XHRcdFx0XHRob2xkZXJPcHRzID0gYmluZGluZy52YWx1ZTtcblx0XHRcdFx0XHRpZiAoaG9sZGVyT3B0cy5oYXNPd25Qcm9wZXJ0eSgnaW1nJykpIHtcblx0XHRcdFx0XHRcdGltYWdlU2l6ZSA9IGhvbGRlck9wdHMuaW1nO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIGhvbGRlck9wdHNbJ2ltZyddO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsZXQgaG9sZGVyU3RyID0gJz8nICsgT2JqZWN0LmtleXMoaG9sZGVyT3B0cykubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gW3Byb3AsIGhvbGRlck9wdHNbcHJvcF1dLm1hcChlbmNvZGVVUklDb21wb25lbnQpLmpvaW4oJz0nKTtcblx0XHRcdFx0XHR9KS5qb2luKCcmJyk7XG5cdFx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdkYXRhLXNyYycsICdob2xkZXIuanMvJyArIGltYWdlU2l6ZSArIGhvbGRlclN0cik7XG5cdFx0XHRcdFx0SG9sZGVyLnJ1bih7XG5cdFx0XHRcdFx0XHRpbWFnZXM6IGVsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJpbmRpbmcudmFsdWUpID09PSAnW29iamVjdCBTdHJpbmddJykge1xuXHRcdFx0XHRcdGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1zcmMnLCAnaG9sZGVyLmpzLycgKyBiaW5kaW5nLnZhbHVlKTtcblx0XHRcdFx0XHRIb2xkZXIucnVuKHtcblx0XHRcdFx0XHRcdGltYWdlczogZWxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBob2xkZXJKUztcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcblx0d2luZG93LlZ1ZS51c2UoaG9sZGVySlMpO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n");

/***/ })
/******/ ]);